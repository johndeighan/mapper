// Generated by CoffeeScript 2.6.1
  // TreeWalker.coffee
import {
  assert,
  undef,
  pass,
  croak,
  isArray,
  isHash,
  isArrayOfHashes
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var TreeWalker = class TreeWalker {
  constructor(root) {
    this.root = root;
    // --- root can be a hash or array of hashes
    pass;
  }

  // ..........................................................
  walk() {
    debug("enter TreeWalker.walk");
    if (isHash(this.root)) {
      debug("walking node");
      this.walkNode(this.root, 0);
    } else if (isArrayOfHashes(this.root)) {
      debug("walking array");
      this.walkNodes(this.root, 0);
    } else {
      croak("TreeWalker: Invalid root", 'ROOT', this.root);
    }
    debug("return from TreeWalker.walk");
  }

  // ..........................................................
  walkSubTrees(lSubTrees, level) {
    var i, len, subtree;
    for (i = 0, len = lSubTrees.length; i < len; i++) {
      subtree = lSubTrees[i];
      if (subtree != null) {
        if (isArray(subtree)) {
          this.walkNodes(subtree, level);
        } else if (isHash(subtree)) {
          this.walkNode(subtree, level);
        } else {
          croak("Invalid subtree", 'SUBTREE', subtree);
        }
      }
    }
  }

  // ..........................................................
  walkNode(node, level) {
    var lSubTrees;
    lSubTrees = this.visit(node, level);
    if (lSubTrees) {
      this.walkSubTrees(lSubTrees, level + 1);
    }
    return this.endVisit(node, level);
  }

  // ..........................................................
  walkNodes(lNodes, level = 0) {
    var i, len, node;
    for (i = 0, len = lNodes.length; i < len; i++) {
      node = lNodes[i];
      this.walkNode(node, level);
    }
  }

  // ..........................................................
  // --- return lSubTrees, if any
  visit(node, level) {
    return node.body; // it's handled ok if node.body is undef
  }

  
    // ..........................................................
  // --- called after all subtrees have been visited
  endVisit(node, level) {}

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var ASTWalker = class ASTWalker extends TreeWalker {
  constructor(ast) {
    super(ast.program);
    this.ast = ast.program;
    this.lImportedSymbols = [];
    this.lUsedSymbols = [];
    // --- subarrays start out as list of formal parameters
    //     to which are added locally assigned variables
    this.lLocalSymbols = [[]];
  }

  // ..........................................................
  isLocalSymbol(name) {
    var i, len, ref, subarray;
    ref = this.lLocalSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      subarray = ref[i];
      if (subarray.includes(name)) {
        return true;
      }
    }
    return false;
  }

  // ..........................................................
  addImport(name, lib) {
    assert(name, "addImport: empty name");
    if (this.lImportedSymbols.includes(name)) {
      croak(`Duplicate import: ${name}`);
    } else {
      this.lImportedSymbols.push(name);
    }
  }

  // ..........................................................
  addUsedSymbol(name, value = {}) {
    assert(name, "addUsedSymbol(): empty name");
    if (!this.isLocalSymbol(name) && !this.lUsedSymbols.includes(name)) {
      this.lUsedSymbols.push(name);
    }
  }

  // ..........................................................
  addLocalSymbol(name) {
    var lSymbols;
    assert(this.lLocalSymbols.length > 0, "no lLocalSymbols");
    lSymbols = this.lLocalSymbols[this.lLocalSymbols.length - 1];
    lSymbols.push(name);
  }

  // ..........................................................
  visit(node, level) {
    var add, hSpec, i, importKind, imported, j, lNames, lSubTrees, len, len1, lib, local, name, param, parm, ref, source, specifiers, type;
    // --- add to local vars & formal params, where appropriate
    switch (node.type) {
      case 'Identifier':
        // --- Identifiers that are not local vars or formal params
        //     are symbols that should be imported
        name = node.name;
        if (!this.isLocalSymbol(name)) {
          this.addUsedSymbol(name);
        }
        return;
      case 'ImportDeclaration':
        ({specifiers, source, importKind} = node);
        if ((importKind === 'value') && (source.type === 'StringLiteral')) {
          lib = source.value; // e.g. '@jdeighan/coffee-utils'
          for (i = 0, len = specifiers.length; i < len; i++) {
            hSpec = specifiers[i];
            ({type, imported, local, importKind} = hSpec);
            if ((type === 'ImportSpecifier') && (imported != null) && (imported.type === 'Identifier')) {
              this.addImport(imported.name, lib);
            }
          }
        }
        return;
      case 'CatchClause':
        param = node.param;
        if ((param != null) && param.type === 'Identifier') {
          this.lLocalSymbols.push(param.name);
        }
        break;
      case 'FunctionExpression':
        lNames = [];
        ref = node.params;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          parm = ref[j];
          if (parm.type === 'Identifier') {
            lNames.push(parm.name);
          }
        }
        this.lLocalSymbols.push(lNames);
        break;
      case 'For':
        lNames = [];
        if ((node.name != null) && (node.name.type === 'Identifier')) {
          lNames.push(node.name.name);
        }
        if ((node.index != null) && (node.name.type === 'Identifier')) {
          lNames.push(node.index.name);
        }
        this.lLocalSymbols.push(lNames);
        break;
      case 'AssignmentExpression':
        if (node.left.type === 'Identifier') {
          this.addLocalSymbol(node.left.name);
        }
        break;
      case 'AssignmentPattern':
        if (node.left.type === 'Identifier') {
          this.addLocalSymbol(node.left.name);
        }
    }
    // --- Build and return array of subtrees
    lSubTrees = [];
    add = function(...subtrees) {
      return lSubTrees.push(...subtrees);
    };
    switch (node.type) {
      case 'AssignmentExpression':
        add(node.left, node.right);
        break;
      case 'AssignmentPattern':
        add(node.left, node.right);
        break;
      case 'BinaryExpression':
        add(node.left, node.right);
        break;
      case 'BlockStatement':
        add(node.body);
        break;
      case 'CallExpression':
        add(node.callee, node.arguments);
        break;
      case 'CatchClause':
        add(node.body);
        break;
      case 'ClassDeclaration':
        add(node.body);
        break;
      case 'ClassBody':
        add(node.body);
        break;
      case 'ClassMethod':
        add(node.body);
        break;
      case 'ExpressionStatement':
        add(node.expression);
        break;
      case 'For':
        add(node.body, node.source);
        break;
      case 'FunctionExpression':
        add(node.params, node.body);
        break;
      case 'IfStatement':
        add(node.test, node.consequent);
        break;
      case 'MemberExpression':
        add(node.object);
        break;
      case 'Program':
        add(node.body);
        break;
      case 'SwitchCase':
        add(node.test, node.consequent);
        break;
      case 'SwitchStatement':
        add(node.cases);
        break;
      case 'TryStatement':
        add(node.block, node.handler, node.finalizer);
        break;
      case 'WhileStatement':
        add(node.test, node.body);
    }
    return lSubTrees;
  }

  // ..........................................................
  endVisit(node, level) {
    // --- Called after the node's entire subtree has been walked
    switch (node.type) {
      case 'FunctionExpression':
      case 'For':
      case 'CatchClause':
        this.lLocalSymbols.pop();
    }
  }

  // ..........................................................
  getSymbols() {
    var i, lNeededSymbols, len, name, ref;
    debug("enter CodeWalker.getNeededSymbols()");
    this.lImportedSymbols = []; // filled in during walking
    this.lUsedSymbols = []; // filled in during walking
    debug("walking");
    this.walk();
    debug("done walking");
    lNeededSymbols = [];
    ref = this.lUsedSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      if (!this.lImportedSymbols.includes(name)) {
        lNeededSymbols.push(name);
      }
    }
    debug("return from CodeWalker.getNeededSymbols()");
    return {
      lImported: this.lImportedSymbols,
      lUsed: this.lUsedSymbols,
      lNeeded: lNeededSymbols
    };
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var TreeStringifier = class TreeStringifier extends TreeWalker {
  constructor(tree) {
    super(tree); // sets @tree
    this.lLines = [];
  }

  // ..........................................................
  visit(node, level) {
    var str;
    assert(node != null, "TreeStringifier.visit(): empty node");
    debug("enter visit()");
    str = indented(this.stringify(node), level);
    debug(`stringified: '${str}'`);
    this.lLines.push(str);
    if (node.body) {
      debug("return from visit() - has subtree 'body'");
      return node.body;
    } else {
      debug("return from visit()");
      return undef;
    }
  }

  // ..........................................................
  get() {
    this.walk();
    return this.lLines.join('\n');
  }

  // ..........................................................
  excludeKey(key) {
    return key === 'body';
  }

  // ..........................................................
  // --- override this
  stringify(node) {
    var key, newnode, value;
    assert(isHash(node), `TreeStringifier.stringify(): node '${node}' is not a hash`);
    newnode = {};
    for (key in node) {
      value = node[key];
      if (!this.excludeKey(key)) {
        newnode[key] = node[key];
      }
    }
    return JSON.stringify(newnode);
  }

};
