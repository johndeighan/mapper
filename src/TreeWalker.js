// Generated by CoffeeScript 2.7.0
  // TreeWalker.coffee
import {
  assert,
  undef,
  pass,
  croak,
  defined,
  OL,
  rtrim,
  isString,
  isNumber,
  isEmpty,
  nonEmpty,
  isArray,
  isHash,
  isInteger
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  splitLine,
  indentLevel,
  indented,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Mapper
} from '@jdeighan/mapper';

import {
  lineToParts,
  mapHereDoc,
  addHereDocType
} from '@jdeighan/mapper/heredoc';

import {
  FuncHereDoc
} from '@jdeighan/mapper/func';

import {
  TAMLHereDoc
} from '@jdeighan/mapper/taml';

// ===========================================================================
//   class TreeWalker
//      - map() returns {item, level, lineNum} or undef
//   to use, override:
//      mapStr(str, level) - returns user object, default returns str
//      handleCmd()
//      beginWalk() -
//      visit(uobj, level, lineNum) -
//      endVisit(uobj, level, lineNum) -
//      endWalk() -
export var TreeWalker = class TreeWalker extends Mapper {
  constructor(source = undef, collection = undef, hOptions = {}) {
    super(source, collection, hOptions);
    this.lMinuses = []; // used to adjust level in #ifdef and #ifndef
  }

  
    // ..........................................................
  // --- Should always return either:
  //        undef
  //        object with {uobj, level, lineNum}
  // --- Will only receive non-special lines
  map(item) {
    var hResult, lExtLines, level, lineNum, newstr, str, uobj;
    debug("enter map()", item);
    // --- a TreeWalker makes no sense unless items are strings
    assert(isString(item), `non-string: ${OL(item)}`);
    lineNum = this.lineNum; // save in case we fetch more lines
    [level, str] = splitLine(item);
    debug(`split: level = ${OL(level)}, str = ${OL(str)}`);
    assert(nonEmpty(str), "empty string should be special");
    // --- check for extension lines
    debug("check for extension lines");
    lExtLines = this.fetchLinesAtLevel(level + 2);
    assert(isArray(lExtLines), "lExtLines not an array");
    if (nonEmpty(lExtLines)) {
      newstr = this.joinExtensionLines(str, lExtLines);
      if (newstr !== str) {
        str = newstr;
        debug(`=> ${OL(str)}`);
      }
    }
    // --- handle HEREDOCs
    debug("check for HEREDOC");
    if (str.indexOf('<<<') >= 0) {
      hResult = this.handleHereDoc(str, level);
      // --- NOTE: hResult.lObjects is not currently used
      //           but I want to use it in the future to
      //           prevent having to construct an object from the line
      if (hResult.line !== str) {
        str = hResult.line;
        debug(`=> ${OL(str)}`);
      }
    }
    // --- NOTE: mapStr() may return undef, meaning to ignore
    item = this.mapStr(str, level, lineNum);
    if (defined(item)) {
      uobj = {
        item,
        level: this.realLevel(level),
        lineNum
      };
      debug("return from map()", uobj);
      return uobj;
    } else {
      debug("return undef from map()");
      return undef;
    }
  }

  // ..........................................................
  // --- designed to override
  mapStr(str, level, lineNum) {
    return str;
  }

  // ..........................................................
  joinExtensionLines(line, lExtLines) {
    var contLine, j, len;
// --- There might be empty lines in lExtLines
//     but we'll skip them here
    for (j = 0, len = lExtLines.length; j < len; j++) {
      contLine = lExtLines[j];
      if (nonEmpty(contLine)) {
        line += ' ' + contLine.trim();
      }
    }
    return line;
  }

  // ..........................................................
  handleHereDoc(line, level) {
    var hResult, j, lLines, lNewParts, lObjects, lParts, len, part;
    // --- Indentation has been removed from line
    // --- Find each '<<<' and replace with result of mapHereDoc()
    debug("enter handleHereDoc()", line, level);
    assert(isString(line), "not a string");
    lParts = lineToParts(line);
    debug('lParts', lParts);
    lObjects = [];
    lNewParts = []; // to be joined to form new line
    for (j = 0, len = lParts.length; j < len; j++) {
      part = lParts[j];
      if (part === '<<<') {
        debug(`get HEREDOC lines at level ${level + 1}`);
        lLines = this.fetchLinesAtLevel(level + 1, ''); // stop on blank line
        lLines = undented(lLines, level + 1);
        debug('lLines', lLines);
        hResult = mapHereDoc(arrayToBlock(lLines));
        debug('hResult', hResult);
        lObjects.push(hResult.obj);
        lNewParts.push(hResult.str);
      } else {
        lNewParts.push(part); // keep as is
      }
    }
    hResult = {
      line: lNewParts.join(''),
      lObjects: lObjects
    };
    debug("return from handleHereDoc", hResult);
    return hResult;
  }

  // ..........................................................
  extSep(str, nextStr) {
    return ' ';
  }

  // ..........................................................
  isEmptyHereDocLine(str) {
    return str === '.';
  }

  // ..........................................................
  // --- We define commands 'ifdef' and 'ifndef'
  handleCmd(cmd, argstr, prefix, h) {
    var isEnv, item, keep, lSkipLines, level, lineNum, name, ok, realLevel, uobj, value;
    // --- h has keys 'cmd','argstr' and 'prefix'
    //     but may contain additional keys
    debug("enter TreeWalker.handleCmd()", h);
    level = indentLevel(prefix);
    realLevel = this.realLevel(level);
    lineNum = this.lineNum;
    // --- Handle our commands, returning if found
    switch (cmd) {
      case 'ifdef':
      case 'ifndef':
        [name, value, isEnv] = this.splitDef(argstr);
        assert(defined(name), `Invalid ${cmd}, argstr=${OL(argstr)}`);
        ok = this.isDefined(name, value, isEnv);
        keep = cmd === 'ifdef' ? ok : !ok;
        if (keep) {
          this.lMinuses.push(level);
        } else {
          lSkipLines = this.fetchLinesAtLevel(level + 1);
          debug(`Skip ${lSkipLines.length} lines`);
        }
        debug("return undef from TreeWalker.handleCmd()");
        return undef;
    }
    debug("call super");
    item = super.handleCmd(cmd, argstr, prefix, h);
    if (defined(item)) {
      uobj = {
        level: realLevel,
        lineNum,
        item
      };
      debug("return from TreeWalker.handleCmd()", uobj);
      return uobj;
    } else {
      debug("return undef from TreeWalker.handleCmd()");
      return undef;
    }
  }

  // ..........................................................
  getResult(result, prefix) {
    if (result === undef) {
      return undef;
    } else {
      assert(this.lineNum > 0, `lineNum is ${OL(this.lineNum)} in getResult()`);
      return {
        item: result,
        level: this.realLevel(indentLevel(prefix)),
        lineNum: this.lineNum
      };
    }
  }

  // ..........................................................
  realLevel(level) {
    var adjustment, i, j, lNewMinuses, len, ref;
    lNewMinuses = [];
    adjustment = 0;
    ref = this.lMinuses;
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      if (level > i) {
        adjustment += 1;
        lNewMinuses.push(i);
      }
    }
    this.lMinuses = lNewMinuses;
    return level - adjustment;
  }

  // ..........................................................
  splitDef(argstr) {
    var _, env, isEnv, lMatches, name, value;
    lMatches = argstr.match(/^(env\.)?([A-Za-z_][A-Za-z0-9_]*)\s*(.*)$/);
    if (lMatches) {
      [_, env, name, value] = lMatches;
      isEnv = nonEmpty(env) ? true : false;
      if (isEmpty(value)) {
        value = undef;
      }
      return [name, value, isEnv];
    } else {
      return [undef, undef, undef];
    }
  }

  // ..........................................................
  fetchLinesAtLevel(atLevel, stopOn = undef) {
    var item, lLines;
    // --- Does NOT remove any indentation
    debug(`enter TreeWalker.fetchLinesAtLevel(${OL(atLevel)}, ${OL(stopOn)})`);
    assert(atLevel > 0, "atLevel is 0");
    lLines = [];
    while (defined(item = this.fetch()) && debug(`item = ${OL(item)}`) && isString(item) && ((stopOn === undef) || (item !== stopOn)) && debug("OK") && (isEmpty(item) || (indentLevel(item) >= atLevel))) {
      debug(`push ${OL(item)}`);
      lLines.push(item);
    }
    // --- Cases:                            unfetch?
    //        1. item is undef                 NO
    //        2. item not a string             YES
    //        3. item == stopOn (& defined)    NO
    //        4. item nonEmpty and undented    YES
    if ((item === undef) || (item === stopOn)) {
      debug("don't unfetch");
    } else {
      debug("do unfetch");
      this.unfetch(item);
    }
    debug("return from TreeWalker.fetchLinesAtLevel()", lLines);
    return lLines;
  }

  // ..........................................................
  fetchBlockAtLevel(atLevel, stopOn = undef) {
    var lLines, result;
    debug(`enter TreeWalker.fetchBlockAtLevel(${OL(atLevel)})`);
    lLines = this.fetchLinesAtLevel(atLevel, stopOn);
    debug('lLines', lLines);
    lLines = undented(lLines, atLevel);
    debug("undented lLines", lLines);
    result = arrayToBlock(lLines);
    debug("return from TreeWalker.fetchBlockAtLevel()", result);
    return result;
  }

  // ..........................................................
  // --- override these for tree walking
  beginWalk() {
    return undef;
  }

  // ..........................................................
  visit(item, level, lineNum, hUser) {
    var result;
    debug("enter visit()", item, level, lineNum, hUser);
    assert(level >= 0, `level = ${OL(level)}`);
    result = indented(item, level);
    debug("return from visit()", result);
    return result;
  }

  // ..........................................................
  endVisit(item, level, lineNum, hUser) {
    return undef;
  }

  // ..........................................................
  endWalk() {
    return undef;
  }

  // ..........................................................
  // ..........................................................
  isDefined(name, value, isEnv) {
    if (isEnv) {
      if (defined(value)) {
        return process.env[name] === value;
      } else {
        return defined(process.env[name]);
      }
    } else {
      if (defined(value)) {
        return this.getConst(name) === value;
      } else {
        return defined(this.getConst(name));
      }
    }
    return true;
  }

  // ..........................................................
  whichCmd(uobj) {
    if (isHash(uobj) && uobj.hasOwnProperty('cmd')) {
      return uobj.cmd;
    }
    return undef;
  }

  // ..........................................................
  checkUserObj(uobj) {
    var item, level, lineNum;
    assert(defined(uobj), "user object is undef");
    assert(isHash(uobj), `user object is ${OL(uobj)}`);
    ({item, level, lineNum} = uobj);
    assert(defined(item), "item is undef");
    assert(isInteger(level), `level is ${OL(level)}`);
    assert(level >= 0, `level is ${OL(level)}`);
    assert(isInteger(lineNum), `lineNum is ${OL(lineNum)}`);
    assert(lineNum >= -1, `lineNum is ${OL(lineNum)}`);
  }

  // ..........................................................
  visitNode(uobj, hUser, lStack) {
    var item, level, line, lineNum;
    this.checkUserObj(uobj);
    ({item, level, lineNum} = uobj);
    line = this.visit(item, level, lineNum, hUser, lStack);
    if (defined(line)) {
      this.addLine(line);
    }
  }

  // ..........................................................
  endVisitNode(node, lStack) {
    var hUser, item, level, line, lineNum, uobj;
    assert(isHash(node), `node is ${OL(node)}`);
    ({uobj, hUser} = node);
    this.checkUserObj(uobj);
    assert(isHash(hUser), `hUser is ${OL(hUser)}`);
    ({item, level, lineNum} = uobj);
    line = this.endVisit(item, level, lineNum, hUser, lStack);
    if (defined(line)) {
      this.addLine(line);
    }
  }

  // ..........................................................
  walk() {
    var hUser, item, lStack, level, line, lineNum, node, ref, result, uobj;
    debug("enter walk()");
    // --- lStack is stack of {
    //        uobj: {item, level, lineNum}
    //        hUser: {}
    //        }
    this.lLines = []; // --- resulting lines
    lStack = [];
    debug("begin walk");
    line = this.beginWalk();
    if (defined(line)) {
      this.addLine(line);
    }
    debug("getting uobj's");
    ref = this.allMapped();
    for (uobj of ref) {
      this.checkUserObj(uobj);
      ({item, level, lineNum} = uobj);
      while (lStack.length > level) {
        node = lStack.pop();
        this.endVisitNode(node, lStack);
      }
      // --- Create a user hash that the user can add to/modify
      //     and will see again at endVisit
      hUser = {};
      this.visitNode(uobj, hUser, lStack);
      lStack.push({uobj, hUser});
    }
    while (lStack.length > 0) {
      node = lStack.pop();
      this.endVisitNode(node, lStack);
    }
    line = this.endWalk();
    if (defined(line)) {
      this.addLine(line);
    }
    result = arrayToBlock(this.lLines);
    debug("return from walk()", result);
    return result;
  }

  // ..........................................................
  addLine(line) {
    assert(defined(line), "line is undef");
    debug(`enter addLine(${OL(line)})`, line);
    if (isArray(line)) {
      debug("line is an array");
      this.lLines.push(...line);
    } else {
      this.lLines.push(line);
    }
    debug("return from addLine()");
  }

  // ..........................................................
  getBlock() {
    var result;
    debug("enter getBlock()");
    result = this.walk();
    debug("return from getBlock()", result);
    return result;
  }

};

// ---------------------------------------------------------------------------
export var TraceWalker = class TraceWalker extends TreeWalker {
  // ..........................................................
  //     builds a trace of the tree
  //        which is returned by endWalk()
  beginWalk() {
    this.lTrace = ["BEGIN WALK"]; // an array of strings
  }

  // ..........................................................
  visit(item, level, lineNum, hUser) {
    this.lTrace.push(`VISIT ${lineNum} ${level} ${OL(item)}`);
  }

  // ..........................................................
  endVisit(item, level, lineNum, hUser) {
    this.lTrace.push(`END VISIT ${lineNum} ${level} ${OL(item)}`);
  }

  // ..........................................................
  endWalk() {
    var block;
    this.lTrace.push("END WALK");
    block = arrayToBlock(this.lTrace);
    this.lTrace = undef;
    return block;
  }

};

// ---------------------------------------------------------------------------
addHereDocType(new TAMLHereDoc()); //  ---

addHereDocType(new FuncHereDoc()); //  () ->
