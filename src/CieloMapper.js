// Generated by CoffeeScript 2.7.0
  // CieloMapper.coffee
import {
  TreeWalker
} from '@jdeighan/mapper/tree';

// ---------------------------------------------------------------------------
export var CieloMapper = class CieloMapper extends TreeWalker {
  // - removes blank lines (but can be overridden)
  // - does NOT remove comments (but can be overridden)
  // - joins continuation lines
  // - handles HEREDOCs
  // - handles #define <name> <value> and __<name>__ substitution
  constructor(content, source) {
    super(content, source);
    debug(`enter CieloMapper(source='${source}')`, content);
    this.hVars = {
      FILE: this.filename,
      DIR: this.hSourceInfo.dir,
      LINE: 0
    };
    // --- This should only be used in mapLine(), where
    //     it keeps track of the level we're at, to be passed
    //     to handleEmptyLine() since the empty line itself
    //     is always at level 0
    this.curLevel = 0;
    debug("return from CieloMapper()");
  }

  // ..........................................................
  // --- designed to override with a mapping method
  //     NOTE: line does not include the indentation
  mapLine(line, level) {
    var cmd, hResult, lContLines, lParts, longline, orgLineNum, replaced, result, tail, verylongline;
    debug(`enter CieloMapper.mapLine(${OL(line)}, ${level})`);
    assert(line != null, "mapLine(): line is undef");
    assert(isString(line), `mapLine(): ${OL(line)} not a string`);
    if (isEmpty(line)) {
      result = this.handleEmptyLine(this.curLevel);
      debug(`return ${OL(result)} from CieloMapper.mapLine() - empty line`);
      return result;
    }
    debug("line is not empty, checking for command");
    lParts = this.splitCommand(line);
    if (lParts) {
      debug("found command", lParts);
      [cmd, tail] = lParts;
      result = this.handleCommand(cmd, tail, level);
      debug(`return ${OL(result)} from CieloMapper.mapLine() - command handled`);
      return result;
    }
    if (isComment(line)) {
      result = this.handleComment(line, level);
      debug(`return ${OL(result)} from CieloMapper.mapLine() - comment`);
      return result;
    }
    debug("hVars", this.hVars);
    replaced = replaceVars(line, this.hVars);
    if (replaced !== line) {
      debug("replaced", replaced);
    }
    orgLineNum = this.lineNum;
    this.curLevel = level;
    // --- Merge in any continuation lines
    debug("check for continuation lines");
    lContLines = this.getContLines(level);
    if (isEmpty(lContLines)) {
      debug("no continuation lines found");
      longline = replaced;
    } else {
      debug(`${lContLines.length} continuation lines found`);
      longline = this.joinContLines(replaced, lContLines);
      debug(`line becomes ${OL(longline)}`);
    }
    // --- handle HEREDOCs
    debug("check for HEREDOC");
    if (line.indexOf('<<<') === -1) {
      verylongline = longline;
    } else {
      hResult = this.handleHereDoc(longline, level);
      verylongline = hResult.line;
      debug(`line becomes ${OL(verylongline)}`);
    }
    debug("mapping string");
    result = this.mapString(verylongline, level);
    debug(`return ${OL(result)} from CieloMapper.mapLine()`);
    return result;
  }

  // ..........................................................
  handleEmptyLine(level) {
    debug("in CieloMapper.handleEmptyLine()");
    // --- remove blank lines by default
    //     return '' to retain empty lines
    return undef;
  }

  // ..........................................................
  splitCommand(line, level) {
    var _, argstr, cmd, lMatches, lResult;
    debug("enter CieloMapper.splitCommand()");
    if (lMatches = line.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, cmd, argstr] = lMatches;
      lResult = [cmd, argstr];
      debug("return from CieloMapper.splitCommand()", lResult);
      return lResult;
    } else {
      // --- not a command
      debug("return undef from CieloMapper.splitCommand()");
      return undef;
    }
  }

  // ..........................................................
  handleCommand(cmd, argstr, level) {
    var _, lMatches, name, prefix, tail;
    debug(`enter handleCommand ${cmd} '${argstr}', ${level}`);
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, prefix, name, tail] = lMatches;
          tail = tail.trim();
          if (prefix) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setVariable(name, tail);
          }
        }
    }
    debug("return undef from handleCommand()");
    return undef; // return value added to output if not undef
  }

  
    // ..........................................................
  setVariable(name, value) {
    debug(`enter setVariable('${name}')`, value);
    assert(isString(name), "name is not a string");
    assert(isString(value), "value is not a string");
    assert((name !== 'DIR' && name !== 'FILE' && name !== 'LINE' && name !== 'END'), `Bad var name '${name}'`);
    this.hVars[name] = value;
    debug("return from setVariable()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc) {
    super.incLineNum(inc); // adjusts property @lineNum
    this.hVars.LINE = this.lineNum;
  }

  // ..........................................................
  getContLines(curlevel) {
    var lLines, nextLevel, nextLine, nextStr;
    lLines = [];
    while (((nextLine = this.fetch(true)) != null) && (nonEmpty(nextLine)) && ([nextLevel, nextStr] = splitLine(nextLine)) && (nextLevel >= curlevel + 2)) {
      lLines.push(nextStr);
    }
    if (nextLine != null) {
      // --- we fetched a line we didn't want
      this.unfetch(nextLine);
    }
    return lLines;
  }

  // ..........................................................
  joinContLines(line, lContLines) {
    var contLine, i, lMatches, len, n;
    for (i = 0, len = lContLines.length; i < len; i++) {
      contLine = lContLines[i];
      if (lMatches = line.match(/\s*\\$/)) {
        n = lMatches[0].length;
        line = line.substr(0, line.length - n);
      }
      line += ' ' + contLine;
    }
    return line;
  }

  // ..........................................................
  isComment(line, level) {
    debug("in CieloMapper.isComment()");
    return stdIsComment(line, level);
  }

  // ..........................................................
  handleComment(line, level) {
    debug("in CieloMapper.handleComment()");
    return line; // keep comments by default
  }

  
    // ..........................................................
  mapString(line, level) {
    // --- NOTE: line has indentation removed
    //     when overriding, may return anything
    //     return undef to generate nothing
    assert(isString(line), `default mapString(): ${OL(line)} is not a string`);
    return line;
  }

  // ..........................................................
  mapHereDoc(block) {
    var hResult;
    // --- A method you can override
    //     Distinct from the mapHereDoc() function found in /heredoc
    hResult = mapHereDoc(block);
    assert(isHash(hResult), "mapHereDoc(): hResult not a hash");
    return hResult;
  }

  // ..........................................................
  handleHereDoc(line, level) {
    var hResult, lLines, lNewParts, lObjects, lParts, part;
    // --- Indentation has been removed from line
    // --- Find each '<<<' and replace with result of mapHereDoc()
    assert(isString(line), "handleHereDoc(): not a string");
    debug(`enter handleHereDoc(${OL(line)})`);
    lParts = lineToParts(line);
    lObjects = [];
    lNewParts = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = lParts.length; i < len; i++) {
        part = lParts[i];
        if (part === '<<<') {
          lLines = this.getHereDocLines(level + 1);
          hResult = this.mapHereDoc(arrayToBlock(lLines));
          lObjects.push(hResult.obj);
          results.push(hResult.str);
        } else {
          results.push(part); // keep as is
        }
      }
      return results;
    }).call(this);
    hResult = {
      line: lNewParts.join(''),
      lParts: lParts,
      lObjects: lObjects
    };
    debug("return from handleHereDoc", hResult);
    return hResult;
  }

  // ..........................................................
  getHereDocLines(atLevel) {
    var lLines, line, newline;
    // --- Get all lines until addHereDocLine() returns undef
    //     atLevel will be one greater than the indent
    //        of the line containing <<<

    // --- NOTE: splitLine() removes trailing whitespace
    debug("enter CieloMapper.getHereDocLines()");
    lLines = [];
    while (((line = this.fetch()) != null) && ((newline = this.hereDocLine(undented(line, atLevel))) != null)) {
      assert(indentLevel(line) >= atLevel, "invalid indentation in HEREDOC section");
      lLines.push(newline);
    }
    assert(isArray(lLines), "getHereDocLines(): retval not an array");
    debug("return from CieloMapper.getHereDocLines()", lLines);
    return lLines;
  }

  // ..........................................................
  hereDocLine(line) {
    if (isEmpty(line)) {
      return undef; // end the HEREDOC section
    } else if (line === '.') {
      return ''; // interpret '.' as blank line
    } else {
      return line;
    }
  }

};
