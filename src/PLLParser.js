// Generated by CoffeeScript 2.5.1
  // PLLParser.coffee
import {
  strict as assert
} from 'assert';

import {
  say,
  undef,
  error,
  isArray,
  isFunction,
  isEmpty,
  isComment,
  escapeStr,
  isTAML,
  taml
} from '@jdeighan/coffee-utils';

import {
  splitLine,
  undentedBlock
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  StringInput
} from '@jdeighan/string-input';

// ---------------------------------------------------------------------------
// --- To derive a class from this:
//        1. Extend this class
//        2. Override mapString(), which gets the line with
//           any continuation lines appended, plus any
//           HEREDOC sections
//        3. If desired, override patchLine, which patches
//           HEREDOC lines into the original string
export var PLLParser = class PLLParser extends StringInput {
  constructor(content, hOptions = {}) {
    super(content, hOptions);
    debug(content, "new PLLParser: contents");
  }

  getContLines(curlevel) {
    var lLines, nextLevel, nextLine, nextStr;
    lLines = [];
    while ((nextLine = this.fetch()) && ([nextLevel, nextStr] = splitLine(nextLine)) && (nextLevel >= curlevel + 2)) {
      lLines.push(nextStr);
    }
    if (nextLine) {
      // --- we fetched a line we didn't want
      this.unfetch(nextLine);
    }
    return lLines;
  }

  // ..........................................................
  joinContLines(line, lContLines) {
    var i, len1, str;
    for (i = 0, len1 = lContLines.length; i < len1; i++) {
      str = lContLines[i];
      line += ' ' + str;
    }
    return line;
  }

  // ..........................................................
  // ..........................................................
  getHereDocLines() {
    var lLines, line, orgLineNum;
    // --- Get all lines until empty line is found
    //     BUT treat line of a single period as empty line
    orgLineNum = this.lineNum;
    lLines = [];
    while ((this.lBuffer.length > 0) && !isEmpty(this.lBuffer[0])) {
      line = this.fetch();
      if (line.match(/^\s*\.\s*$/)) {
        lLines.push('');
      } else {
        lLines.push(line);
      }
    }
    if (this.lBuffer.length > 0) {
      this.fetch(); // empty line
    }
    return lLines;
  }

  // ..........................................................
  heredocStr(str) {
    // --- return replacement string for '<<<'
    return str.replace(/\n/g, ' ');
  }

  // ..........................................................
  patchLine(line) {
    var lLines, lParts, pos, result, start;
    // --- Find each '<<<' and replace with result of heredocStr()
    debug(`enter patchLine('${line}')`);
    lParts = []; // joined at the end
    pos = 0;
    while ((start = line.indexOf('<<<', pos)) !== -1) {
      lParts.push(line.substring(pos, start));
      lLines = this.getHereDocLines();
      if ((lLines != null) && (lLines.length > 0)) {
        lParts.push(this.heredocStr(undentedBlock(lLines)));
      }
      pos = start + 3;
    }
    if (line.indexOf('<<<', pos) !== -1) {
      error(`patchLine(): Not all ${n} HEREDOC markers were replaced` + `in '${line}'`);
    }
    lParts.push(line.substring(pos, line.length));
    result = lParts.join('');
    debug(`return '${result}'`);
    return result;
  }

  // ..........................................................
  handleEmptyLine(lineNum) {
    return undef; // skip blank lines by default
  }

  
    // ..........................................................
  handleComment(lineNum) {
    return undef; // skip comments by default
  }

  
    // ..........................................................
  mapString(line, level) {
    // --- NOTE: line has indentation removed
    return line;
  }

  // ..........................................................
  mapLine(orgLine) {
    var lContLines, level, line, mapped, orgLineNum;
    assert(orgLine != null, "mapLine(): orgLine is undef");
    if (isEmpty(orgLine)) {
      return this.handleEmptyLine(this.lineNum);
    }
    if (isComment(orgLine)) {
      return this.handleComment(this.lineNum);
    }
    [level, line] = splitLine(orgLine);
    orgLineNum = this.lineNum;
    // --- Merge in any continuation lines
    lContLines = this.getContLines(level);
    line = this.joinContLines(line, lContLines);
    // --- handle HEREDOCs
    line = this.patchLine(line);
    mapped = this.mapString(line, level);
    if (mapped != null) {
      return [level, orgLineNum, mapped];
    } else {
      return undef;
    }
  }

  // ..........................................................
  getTree() {
    var lLines;
    debug("enter getTree()");
    lLines = this.getAll();
    assert(lLines != null, "lLines is undef");
    assert(isArray(lLines), "getTree(): lLines is not an array");
    debug(`return ${lLines.length} lines from getTree()`);
    return treeify(lLines);
  }

};

// ---------------------------------------------------------------------------
// Each item must be a sub-array with 3 items: [<level>, <lineNum>, <node>]
export var treeify = function(lItems, atLevel = 0) {
  var body, h, item, lNodes, len, level, lineNum, node;
  // --- stop when an item of lower level is found, or at end of array
  debug("enter treeify()");
  debug(lItems, "lItems:");
  lNodes = [];
  while ((lItems.length > 0) && (lItems[0][0] >= atLevel)) {
    item = lItems.shift();
    assert(isArray(item), "treeify(): item is not an array");
    len = item.length;
    assert(len === 3, `treeify(): item has length ${len}`);
    [level, lineNum, node] = item;
    assert(level === atLevel, `treeify(): item at level ${level}, should be ${atLevel}`);
    h = {node, lineNum};
    body = treeify(lItems, atLevel + 1);
    if (body != null) {
      h.body = body;
    }
    lNodes.push(h);
  }
  if (lNodes.length === 0) {
    debug("return undef from treeify");
    return undef;
  } else {
    debug(`return ${lNodes.length} nodes from treeify`);
    return lNodes;
  }
};
