// Generated by CoffeeScript 2.5.1
  // StringInput.coffee
import {
  strict as assert
} from 'assert';

import fs from 'fs';

import pathlib from 'path';

import {
  undef,
  say,
  pass,
  croak,
  isString,
  isEmpty,
  isComment,
  isArray,
  isHash,
  escapeStr,
  deepCopy,
  stringToArray,
  unitTesting,
  oneline
} from '@jdeighan/coffee-utils';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  splitLine,
  indented,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  getFileContents,
  brewCoffee
} from '@jdeighan/string-input/convert';

// ---------------------------------------------------------------------------
//   class StringInput - stream in lines from a string or array
export var StringInput = class StringInput {
  constructor(content, hOptions1 = {}) {
    var base, filename;
    this.hOptions = hOptions1;
    // --- Valid options:
    //        filename
    ({filename} = this.hOptions);
    if (isEmpty(content)) {
      this.lBuffer = [];
    } else if (isString(content)) {
      this.lBuffer = stringToArray(content);
    } else if (isArray(content)) {
      // -- make a deep copy
      this.lBuffer = deepCopy(content);
    } else {
      croak("StringInput(): content must be array or string", content, "CONTENT");
    }
    this.lineNum = 0;
    if (filename) {
      try {
        // --- We only want the bare filename
        ({base} = pathlib.parse(filename));
        this.filename = base;
      } catch (error) {
        this.filename = filename;
      }
    } else {
      this.filename = 'unit test';
    }
    this.lookahead = undef; // lookahead token, placed by unget
    this.altInput = undef;
    this.altLevel = undef; // controls prefix prepended to lines
  }

  
    // ..........................................................
  // --- designed to override with a mapping method
  //     NOTE: line includes the indentation
  mapLine(line) {
    return line;
  }

  // ..........................................................
  unget(item) {
    // --- item has already been mapped
    debug(item, 'enter unget() with:');
    assert(this.lookahead == null);
    this.lookahead = item;
    debug('return from unget()');
  }

  // ..........................................................
  peek() {
    var item;
    debug('enter peek():');
    if (this.lookahead != null) {
      debug("return lookahead token");
      return this.lookahead;
    }
    item = this.get();
    if (item == null) {
      return undef;
    }
    this.unget(item);
    debug(item, 'return with:');
    return item;
  }

  // ..........................................................
  skip() {
    debug('enter skip():');
    if (this.lookahead != null) {
      this.lookahead = undef;
      debug("return: clear lookahead token");
      return;
    }
    this.get();
    debug('return from skip()');
  }

  // ..........................................................
  // --- Returns undef if either:
  //        1. there's no alt input
  //        2. get from alt input returns undef (then closes alt input)
  getFromAlt() {
    var result;
    debug("enter getFromAlt()");
    if (!this.altInput) {
      croak("getFromAlt(): There is no alt input");
    }
    result = this.altInput.get();
    if (result != null) {
      debug(result, "return with:");
      return indented(result, this.altLevel);
    } else {
      this.altInput = undef;
      this.altLevel = undef;
      debug("return: alt returned undef, alt input removed");
      return undef;
    }
  }

  // ..........................................................
  // --- Returns undef if either:
  //        1. there's no alt input
  //        2. get from alt input returns undef (then closes alt input)
  fetchFromAlt() {
    var result;
    debug("enter fetchFromAlt()");
    if (!this.altInput) {
      croak("fetchFromAlt(): There is no alt input");
    }
    result = this.altInput.fetch();
    if (result != null) {
      debug(result, "return with:");
      return indented(result, this.altLevel);
    } else {
      debug("return: alt returned undef, alt input removed");
      this.altInput = undef;
      this.altLevel = undef;
      return undef;
    }
  }

  // ..........................................................
  get() {
    var line, result, saved;
    debug(`enter StringInput.get() - from ${this.filename}`);
    if (this.lookahead != null) {
      saved = this.lookahead;
      this.lookahead = undef;
      debug(`return lookahead token - from ${this.filename}`);
      return saved;
    }
    if (this.altInput && ((line = this.getFromAlt()) != null)) {
      debug(`return with '${oneline(line)}' - from alt ${this.filename}`);
      return line;
    }
    line = this.fetch(); // will handle #include
    debug(`LINE: '${oneline(line)}'`);
    if (line == null) {
      debug(`return with undef at EOF - from ${this.filename}`);
      return undef;
    }
    result = this.mapLine(line);
    while ((result == null) && (this.lBuffer.length > 0)) {
      line = this.fetch();
      result = this.mapLine(line);
    }
    debug(`return '${oneline(result)}' - from ${this.filename}`);
    return result;
  }

  // ..........................................................
  // --- This should be used to fetch from @lBuffer
  //     to maintain proper @lineNum for error messages
  //     MUST handle #include
  fetch() {
    var _, altLine, contents, fname, lMatches, level, line, result, str;
    debug("enter fetch()");
    if (this.altInput && ((result = this.fetchFromAlt()) != null)) {
      debug(result, "return from alt with:");
      return result;
    }
    if (this.lBuffer.length === 0) {
      debug("return - empty buffer, return undef");
      return undef;
    }
    this.lineNum += 1;
    line = this.lBuffer.shift();
    [level, str] = splitLine(line);
    if (lMatches = str.match(/^\#include\s+(\S.*)$/)) {
      [_, fname] = lMatches;
      assert(!this.altInput, "fetch(): altInput already set");
      if (unitTesting) {
        debug(`return 'Contents of ${fname}' - unit testing`);
        return indented(`Contents of ${fname}`, level);
      }
      contents = getFileContents(fname);
      this.altInput = new StringInput(contents);
      this.altLevel = level;
      debug(`alt input created at level ${level}`);
      // --- We just created an alt input
      //     we need to get its first line
      altLine = this.getFromAlt();
      if (altLine != null) {
        debug(`fetch(): getFromAlt returned '${altLine}'`);
        line = altLine;
      } else {
        debug(`fetch(): alt was undef, retain line '${line}'`);
      }
    }
    debug(`return '${oneline(line)}' from buffer:`);
    return line;
  }

  // ..........................................................
  // --- Put one or more lines back into lBuffer, to be fetched later
  unfetch(str) {
    debug(str, "enter unfetch() with:");
    this.lBuffer.unshift(str);
    this.lineNum -= 1;
    debug('return from unfetch()');
  }

  // ..........................................................
  // --- Fetch a block of text at level or greater than 'level'
  //     as one long string
  // --- Designed to use in mapLine()
  fetchBlock(atLevel) {
    var lLines, level, line, result, retval, str;
    debug(`enter fetchBlock(atLevel = ${atLevel})`);
    lLines = [];
    // --- NOTE: I absolutely hate using a backslash for line continuation
    //           but CoffeeScript doesn't continue while there is an
    //           open parenthesis like Python does :-(
    line = undef;
    while ((line = this.fetch()) != null) {
      debug(`LINE IS '${oneline(line)}'`);
      assert(isString(line), `StringInput.fetchBlock(${atLevel}) - not a string: ${line}`);
      if (isEmpty(line)) {
        debug("empty line");
        lLines.push('');
        continue;
      }
      [level, str] = splitLine(line);
      debug(`LOOP: level = ${level}, str = '${oneline(str)}'`);
      if (level < atLevel) {
        this.unfetch(line);
        debug("RESULT: unfetch the line");
        break;
      }
      result = indented(str, level - atLevel);
      debug(result, "RESULT:");
      lLines.push(result);
    }
    retval = lLines.join('\n');
    debug(retval, `return with (${lLines.length} lines):`);
    return retval;
  }

  // ..........................................................
  getAll() {
    var lLines, line;
    debug("enter getAll()");
    lLines = [];
    line = this.get();
    while (line != null) {
      lLines.push(line);
      line = this.get();
    }
    debug(`return ${lLines.length} lines from getAll()`);
    return lLines;
  }

  // ..........................................................
  getAllText() {
    return this.getAll().join('\n');
  }

};

// ---------------------------------------------------------------------------
/*

- removes blank lines and comments

- converts
		<varname> <== <expr>
	to:
		`$: <varname> = <expr>;`

- converts
		<== <expr>
	to:
		`$: <expr>;`

- converts
		<===
			<code>
	to:
		```
		$: {
			<code>
			}
*/
// ---------------------------------------------------------------------------
// --- export to allow unit testing
export var CoffeeMapper = class CoffeeMapper extends StringInput {
  // - removes blank lines and comments
  // - converts <var> <== <expr> to `$: <var> = <expr>
  constructor(content, hOptions) {
    super(content, hOptions);
  }

  mapLine(orgLine) {
    var _, code, err, expr, jsCode, jsExpr, lMatches, level, line, result, varname;
    debug("enter mapLine()");
    [level, line] = splitLine(orgLine);
    if (isEmpty(line) || line.match(/^#\s/)) {
      return undef;
    }
    if (lMatches = line.match(/^(?:([A-Za-z][A-Za-z0-9_]*)\s*)?\<\=\=\s*(.*)$/)) { // variable name
      [_, varname, expr] = lMatches;
      if (expr) {
        try {
          // --- convert to JavaScript if not unit testing ---
          jsExpr = brewCoffee(expr).trim(); // will have trailing ';'
        } catch (error) {
          err = error;
          croak(err, expr, "EXPR");
        }
        if (varname) {
          result = indented(`\`\$\: ${varname} = ${jsExpr}\``, level);
        } else {
          result = indented(`\`\$\: ${jsExpr}\``, level);
        }
      } else {
        if (varname) {
          croak("Invalid syntax - variable name not allowed", orgLine, 'orgLine');
        }
        code = this.fetchBlock(level + 1);
        try {
          jsCode = brewCoffee(code);
        } catch (error) {
          err = error;
          croak(err, code, 'CODE');
        }
        result = `\`\`\`
\$\: {
${indented(jsCode, 1)}
${indented('}', 1)}
\`\`\``;
      }
      debug("return from mapLine()");
      return indented(result, level);
    } else {
      debug("return from mapLine() - no match");
      return orgLine;
    }
  }

};

// ---------------------------------------------------------------------------
export var SassMapper = class SassMapper extends StringInput {
  // --- only removes comments
  mapLine(line) {
    if (isComment(line)) {
      return undef;
    }
    return line;
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//   class FileInput - contents from a file
export var FileInput = class FileInput extends StringInput {
  constructor(filename, hOptions = {}) {
    var base, content, dir, ext, root;
    ({root, dir, base, ext} = pathlib.parse(filename.trim()));
    hOptions.filename = base;
    if (unitTesting) {
      content = `Contents of ${base}`;
    } else {
      if (!fs.existsSync(filename)) {
        croak(`FileInput(): file '${filename}' does not exist`);
      }
      content = slurp(filename);
    }
    super(content, hOptions);
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// --- To derive a class from this:
//        1. Extend this class
//        2. Override mapString(), which gets the line with
//           any continuation lines appended, plus any
//           HEREDOC sections
//        3. If desired, override patchLine, which patches
//           HEREDOC lines into the original string
export var PLLParser = class PLLParser extends StringInput {
  constructor(content, hOptions = {}) {
    super(content, hOptions);
    debug(content, "new PLLParser: contents");
  }

  getContLines(curlevel) {
    var lLines, nextLevel, nextLine, nextStr;
    lLines = [];
    while ((nextLine = this.fetch()) && ([nextLevel, nextStr] = splitLine(nextLine)) && (nextLevel >= curlevel + 2)) {
      lLines.push(nextStr);
    }
    if (nextLine) {
      // --- we fetched a line we didn't want
      this.unfetch(nextLine);
    }
    return lLines;
  }

  // ..........................................................
  joinContLines(line, lContLines) {
    var i, len1, str;
    for (i = 0, len1 = lContLines.length; i < len1; i++) {
      str = lContLines[i];
      line += ' ' + str;
    }
    return line;
  }

  // ..........................................................
  // ..........................................................
  patchLine(line) {
    var lLines, lParts, newstr, pos, result, start, str;
    // --- Find each '<<<' and replace with result of heredocStr()
    assert(isString(line), "patchLine(): not a string");
    debug(`enter patchLine('${escapeStr(line)}')`);
    lParts = []; // joined at the end
    pos = 0;
    while ((start = line.indexOf('<<<', pos)) !== -1) {
      lParts.push(line.substring(pos, start));
      lLines = this.getHereDocLines();
      assert(isArray(lLines), "patchLine(): lLines is not an array");
      if (lLines.length > 0) {
        str = undented(lLines).join('\n');
        newstr = this.heredocStr(str);
        assert(isString(newstr), "patchLine(): newstr is not a string");
        lParts.push(newstr);
      }
      pos = start + 3;
    }
    assert(line.indexOf('<<<', pos) === -1, "patchLine(): Not all HEREDOC markers were replaced" + `in '${line}'`);
    lParts.push(line.substring(pos, line.length));
    result = lParts.join('');
    debug(`return '${result}'`);
    return result;
  }

  // ..........................................................
  getHereDocLines() {
    var lLines, line, orgLineNum;
    // --- Get all lines until empty line is found
    //     BUT treat line of a single period as empty line
    orgLineNum = this.lineNum;
    lLines = [];
    while ((this.lBuffer.length > 0) && !isEmpty(this.lBuffer[0])) {
      line = this.fetch();
      if (line.trim() === '.') {
        lLines.push('');
      } else {
        lLines.push(line);
      }
    }
    if (this.lBuffer.length > 0) {
      this.fetch(); // empty line
    }
    return lLines;
  }

  // ..........................................................
  heredocStr(str) {
    // --- return replacement string for '<<<'
    return str.replace(/\n/g, ' ');
  }

  // ..........................................................
  handleEmptyLine(lineNum) {
    return undef; // skip blank lines by default
  }

  
    // ..........................................................
  handleComment(lineNum) {
    return undef; // skip comments by default
  }

  
    // ..........................................................
  mapString(line, level) {
    // --- NOTE: line has indentation removed
    return line;
  }

  // ..........................................................
  mapLine(orgLine) {
    var lContLines, level, line, mapped, orgLineNum;
    assert(orgLine != null, "mapLine(): orgLine is undef");
    if (isEmpty(orgLine)) {
      return this.handleEmptyLine(this.lineNum);
    }
    if (isComment(orgLine)) {
      return this.handleComment(this.lineNum);
    }
    [level, line] = splitLine(orgLine);
    orgLineNum = this.lineNum;
    // --- Merge in any continuation lines
    lContLines = this.getContLines(level);
    line = this.joinContLines(line, lContLines);
    // --- handle HEREDOCs
    line = this.patchLine(line);
    mapped = this.mapString(line, level);
    if (mapped != null) {
      return [level, orgLineNum, mapped];
    } else {
      return undef;
    }
  }

  // ..........................................................
  getTree() {
    var lLines;
    debug("enter getTree()");
    lLines = this.getAll();
    assert(lLines != null, "lLines is undef");
    assert(isArray(lLines), "getTree(): lLines is not an array");
    debug(`return ${lLines.length} lines from getTree()`);
    return treeify(lLines);
  }

};

// ---------------------------------------------------------------------------
// Each item must be a sub-array with 3 items: [<level>, <lineNum>, <node>]
export var treeify = function(lItems, atLevel = 0) {
  var body, h, item, lNodes, len, level, lineNum, node;
  // --- stop when an item of lower level is found, or at end of array
  debug("enter treeify()");
  debug(lItems, "lItems:");
  lNodes = [];
  while ((lItems.length > 0) && (lItems[0][0] >= atLevel)) {
    item = lItems.shift();
    assert(isArray(item), "treeify(): item is not an array");
    len = item.length;
    assert(len === 3, `treeify(): item has length ${len}`);
    [level, lineNum, node] = item;
    assert(level === atLevel, `treeify(): item at level ${level}, should be ${atLevel}`);
    h = {node, lineNum};
    body = treeify(lItems, atLevel + 1);
    if (body != null) {
      h.body = body;
    }
    lNodes.push(h);
  }
  if (lNodes.length === 0) {
    debug("return undef from treeify");
    return undef;
  } else {
    debug(`return ${lNodes.length} nodes from treeify`);
    return lNodes;
  }
};
