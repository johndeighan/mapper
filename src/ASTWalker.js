// Generated by CoffeeScript 2.7.0
// ASTWalker.coffee
var hAllHandlers;

import {
  assert,
  croak,
  debug,
  LOG,
  LOGVALUE
} from '@jdeighan/exceptions';

import {
  fromTAML,
  toTAML
} from '@jdeighan/exceptions/taml';

import {
  undef,
  pass,
  defined,
  notdefined,
  OL,
  words,
  deepCopy,
  getOptions,
  isString,
  nonEmpty,
  isArray,
  isHash,
  isArrayOfHashes,
  removeKeys
} from '@jdeighan/coffee-utils';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  toBlock
} from '@jdeighan/coffee-utils/block';

import {
  coffeeCodeToAST
} from '@jdeighan/mapper/coffee';

import {
  Context
} from '@jdeighan/mapper/context';

hAllHandlers = fromTAML(`---
File:
	lWalkTrees:
		- program
Program:
	lWalkTrees:
		- body
ArrayExpression:
	lWalkTrees:
		- elements
AssignmentExpression:
	lDefined:
		- left
	lUsed:
		- right
AssignmentPattern:
	lDefined:
		- left
	lWalkTrees:
		- right
BinaryExpression:
	lUsed:
		- left
		- right
BlockStatement:
	lWalkTrees:
		- body
ClassBody:
	lWalkTrees:
		- body
ClassDeclaration:
	lWalkTrees:
		- body
ClassMethod:
	lWalkTrees:
		- body
ExpressionStatement:
	lWalkTrees:
		- expression
IfStatement:
	lWalkTrees:
		- test
		- consequent
		- alternate
LogicalExpression:
	lWalkTrees:
		- left
		- right
SpreadElement:
	lWalkTrees:
		- argument
SwitchStatement:
	lWalkTrees:
		- cases
SwitchCase:
	lWalkTrees:
		- test
		- consequent
TemplateLiteral:
	lWalkTrees:
		- expressions
TryStatement:
	lWalkTrees:
		- block
		- handler
		- finalizer
WhileStatement:
	lWalkTrees:
		- test
		- body`);

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var ASTWalker = class ASTWalker {
  constructor(from) {
    debug("enter ASTWalker()");
    if (isString(from)) {
      this.ast = coffeeCodeToAST(from);
    } else {
      this.ast = from;
    }
    // --- @ast can be a hash or array of hashes
    if (isHash(this.ast)) {
      debug("tree was hash - constructing list from it");
      this.ast = [this.ast];
    }
    assert(isArrayOfHashes(this.ast), `not array of hashes: ${OL(this.ast)}`);
    // --- Info to accumulate
    this.lImportedSymbols = [];
    this.lExportedSymbols = [];
    this.lUsedSymbols = [];
    this.lMissingSymbols = [];
    this.context = new Context();
    debug("return from ASTWalker()");
  }

  // ..........................................................
  addImport(name, lib) {
    debug(`enter addImport('${name}')`);
    this.check(name);
    if (this.lImportedSymbols.includes(name)) {
      LOG(`Duplicate import: ${name}`);
    } else {
      this.lImportedSymbols.push(name);
    }
    this.context.addGlobal(name);
    debug("return from addImport()");
  }

  // ..........................................................
  addExport(name, lib) {
    debug(`enter addExport('${name}')`);
    this.check(name);
    if (this.lExportedSymbols.includes(name)) {
      LOG(`Duplicate export: ${name}`);
    } else {
      this.lExportedSymbols.push(name);
    }
    debug("return from addExport()");
  }

  // ..........................................................
  addDefined(name, value = {}) {
    debug(`enter addDefined('${name}')`);
    this.check(name);
    if (this.context.atGlobalLevel()) {
      this.context.addGlobal(name);
    } else {
      this.context.add(name);
    }
    debug("return from addDefined()");
  }

  // ..........................................................
  addUsed(name, value = {}) {
    debug(`enter addUsed('${name}')`);
    this.check(name);
    if (!this.lUsedSymbols.includes(name)) {
      this.lUsedSymbols.push(name);
    }
    if (!this.context.has(name) && !this.lMissingSymbols.includes(name)) {
      this.lMissingSymbols.push(name);
    }
    debug("return from addUsed()");
  }

  // ..........................................................
  walk(options = undef) {
    var asText, hInfo, i, j, k, lLines, lNotNeeded, label, len, len1, len2, name, node, ref, ref1, ref2, result;
    // --- Valid options:
    //        asText
    debug("enter walk()");
    ref = this.ast;
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      this.visit(node, 0);
    }
    // --- get symbols to return

    // --- not needed if:
    //        1. in lImported
    //        2. not in lUsedSymbols
    //        3. not in lExportedSymbols
    lNotNeeded = [];
    ref1 = this.lImportedSymbols;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      name = ref1[j];
      if (!this.lUsedSymbols.includes(name) && !this.lExportedSymbols.includes(name)) {
        lNotNeeded.push(name);
      }
    }
    hInfo = {
      lImported: this.lImportedSymbols,
      lExported: this.lExportedSymbols,
      lUsed: this.lUsedSymbols,
      lMissing: this.lMissingSymbols,
      lNotNeeded
    };
    ({asText} = getOptions(options));
    if (asText) {
      lLines = [];
      ref2 = words('lImported lExported lMissing');
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        label = ref2[k];
        if (nonEmpty(hInfo[label])) {
          lLines.push(`${label}: ${hInfo[label].join(' ')}`);
        }
      }
      result = toBlock(lLines);
    } else {
      result = hInfo;
    }
    debug("return from walk()", result);
    return result;
  }

  // ..........................................................
  walkTree(tree, level = 0) {
    var i, len, node;
    debug("enter walkTree()");
    if (isArray(tree)) {
      for (i = 0, len = tree.length; i < len; i++) {
        node = tree[i];
        this.walkTree(node, level);
      }
    } else {
      assert(isHash(tree, ['type']), `bad tree: ${OL(tree)}`);
      this.visit(tree, level);
    }
    debug("return from walkTree()");
  }

  // ..........................................................
  // --- return true if handled, false if not
  handle(node, level) {
    var hHandlers, i, j, k, key, l, lDefined, lUsed, lWalkTrees, len, len1, len2, len3, subnode, tree, type;
    debug("enter handle()");
    ({type} = node);
    debug(`type is ${OL(type)}`);
    hHandlers = hAllHandlers[type];
    if (notdefined(hHandlers)) {
      debug("return false from handle()");
      return false;
    }
    ({lWalkTrees, lDefined, lUsed} = hHandlers);
    if (defined(lDefined)) {
      debug("has lDefined");
      for (i = 0, len = lDefined.length; i < len; i++) {
        key = lDefined[i];
        subnode = node[key];
        if (subnode.type === 'Identifier') {
          this.addDefined(subnode.name);
        } else {
          this.walkTree(subnode, level + 1);
        }
      }
    }
    if (defined(lUsed)) {
      debug("has lUsed");
      for (j = 0, len1 = lUsed.length; j < len1; j++) {
        key = lUsed[j];
        subnode = node[key];
        if (subnode.type === 'Identifier') {
          this.addUsed(subnode.name);
        } else {
          this.walkTree(subnode, level + 1);
        }
      }
    }
    if (defined(lWalkTrees)) {
      debug("has lWalkTrees");
      for (k = 0, len2 = lWalkTrees.length; k < len2; k++) {
        key = lWalkTrees[k];
        subnode = node[key];
        if (isArray(subnode)) {
          for (l = 0, len3 = subnode.length; l < len3; l++) {
            tree = subnode[l];
            this.walkTree(tree, level + 1);
          }
        } else if (defined(subnode)) {
          this.walkTree(subnode, level + 1);
        }
      }
    }
    debug("return true from handle()");
    return true;
  }

  // ..........................................................
  visit(node, level) {
    var arg, argument, callee, declaration, hSpec, i, id, importKind, imported, j, k, l, lParmNames, left, len, len1, len2, len3, len4, lib, local, m, name, object, param, parm, ref, ref1, ref2, right, source, spec, specifiers, type;
    debug(`enter ASTWalker.visit(type=${node.type})`);
    assert(defined(node), "node is undef");
    if (this.handle(node, level)) {
      debug("return from ASTWalker.visit()");
      return;
    }
    switch (node.type) {
      case 'CallExpression':
        ({callee} = node);
        if (callee.type === 'Identifier') {
          this.addUsed(callee.name);
        } else {
          this.walkTree(callee, level + 1);
        }
        ref = node.arguments;
        for (i = 0, len = ref.length; i < len; i++) {
          arg = ref[i];
          if (arg.type === 'Identifier') {
            this.addUsed(arg.name);
          } else {
            this.walkTree(arg, level + 1);
          }
        }
        break;
      case 'CatchClause':
        param = node.param;
        if (defined(param) && (param.type === 'Identifier')) {
          this.addDefined(param.name);
        }
        this.walkTree(node.body, level + 1);
        break;
      case 'ExportNamedDeclaration':
        ({specifiers, declaration} = node);
        if (defined(declaration)) {
          ({type, id, left} = declaration);
          if (type === 'ClassDeclaration') {
            this.addExport(id.name);
          } else if (type === 'AssignmentExpression') {
            if (left.type === 'Identifier') {
              this.addExport(left.name);
            }
          }
          this.walkTree(declaration, level + 1);
        }
        if (defined(specifiers)) {
          for (j = 0, len1 = specifiers.length; j < len1; j++) {
            spec = specifiers[j];
            name = spec.exported.name;
            this.addExport(name);
          }
        }
        break;
      case 'For':
        if (defined(node.name) && (node.name.type === 'Identifier')) {
          this.addDefined(node.name.name);
        }
        if (defined(node.index) && (node.name.type === 'Identifier')) {
          this.addDefined(node.index.name);
        }
        this.walkTree(node.source, level + 1);
        this.walkTree(node.body, level + 1);
        break;
      case 'FunctionExpression':
      case 'ArrowFunctionExpression':
        lParmNames = [];
        if (defined(node.params)) {
          ref1 = node.params;
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            parm = ref1[k];
            switch (parm.type) {
              case 'Identifier':
                lParmNames.push(parm.name);
                break;
              case 'AssignmentPattern':
                ({left, right} = parm);
                if (left.type === 'Identifier') {
                  lParmNames.push(left.name);
                }
                if (right.type === 'Identifier') {
                  this.addUsed(right.name);
                } else {
                  this.walkTree(right, level + 1);
                }
            }
          }
        }
        this.context.beginScope('<unknown>', lParmNames);
        this.walkTree(node.params, level + 1);
        this.walkTree(node.body, level + 1);
        this.context.endScope();
        break;
      case 'ImportDeclaration':
        ({specifiers, source, importKind} = node);
        if ((importKind === 'value') && (source.type === 'StringLiteral')) {
          lib = source.value; // e.g. '@jdeighan/coffee-utils'
          for (l = 0, len3 = specifiers.length; l < len3; l++) {
            hSpec = specifiers[l];
            ({type, imported, local, importKind} = hSpec);
            if ((type === 'ImportSpecifier') && defined(imported) && (imported.type === 'Identifier')) {
              this.addImport(imported.name, lib);
            }
          }
        }
        break;
      case 'NewExpression':
        if (node.callee.type === 'Identifier') {
          this.addUsed(node.callee.name);
        }
        ref2 = node.arguments;
        for (m = 0, len4 = ref2.length; m < len4; m++) {
          arg = ref2[m];
          if (arg.type === 'Identifier') {
            this.addUsed(arg.name);
          } else {
            this.walkSubtree(arg);
          }
        }
        break;
      case 'MemberExpression':
        ({object} = node);
        if (object.type === 'Identifier') {
          this.addUsed(object.name);
        }
        this.walkTree(object);
        break;
      case 'ReturnStatement':
        ({argument} = node);
        if (defined(argument)) {
          if (argument.type === 'Identifier') {
            this.addUsed(argument.name);
          } else {
            this.walkTree(argument);
          }
        }
    }
    debug("return from ASTWalker.visit()");
  }

  // ..........................................................
  check(name) {
    assert(nonEmpty(name), "empty name");
  }

  // ..........................................................
  getBasicAST(asTAML = true) {
    var ast, lSortBy, lToRemove;
    ast = deepCopy(this.ast);
    lToRemove = words('start end extra declarations loc range tokens comments', 'assertions implicit optional async generator id hasIndentedBody');
    lSortBy = words("type params body left right");
    removeKeys(ast, lToRemove);
    if (asTAML) {
      return toTAML(ast, {
        sortKeys: lSortBy
      });
    } else {
      return ast;
    }
  }

};
