// Generated by CoffeeScript 2.5.1
// StringInput.coffee
var hasProp = {}.hasOwnProperty;

import {
  strict as assert
} from 'assert';

import fs from 'fs';

import pathlib from 'path';

import {
  undef,
  deepCopy,
  stringToArray,
  say,
  pass,
  error,
  sep_dash,
  isString,
  unitTesting
} from '@jdeighan/coffee-utils';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  splitLine,
  indentedStr,
  indentation
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

// ---------------------------------------------------------------------------
//   class StringInput - stream in lines from a string or array
export var StringInput = class StringInput {
  constructor(content, hOptions1 = {}) {
    var base, dir, ext, filename, hIncludePaths, ref;
    this.hOptions = hOptions1;
    // --- Valid options:
    //        filename
    //        hIncludePaths    { <ext>: <dir>, ... }
    ({filename, hIncludePaths} = this.hOptions);
    if (isString(content)) {
      this.lBuffer = stringToArray(content);
    } else if (isArray(content)) {
      // -- make a deep copy
      this.lBuffer = deepCopy(content);
    } else {
      error("StringInput(): content must be array or string");
    }
    this.lineNum = 0;
    if (filename) {
      try {
        // --- We only want the bare filename
        ({base} = pathlib.parse(filename));
        this.filename = base;
      } catch (error1) {
        this.filename = filename;
      }
    } else {
      this.filename = 'unit test';
    }
    this.hIncludePaths = this.hOptions.hIncludePaths || {};
    if (!unitTesting) {
      ref = this.hIncludePaths;
      for (ext in ref) {
        if (!hasProp.call(ref, ext)) continue;
        dir = ref[ext];
        assert(ext.indexOf('.') === 0, "invalid key in hIncludePaths");
        assert(fs.existsSync(dir), `dir ${dir} does not exist`);
      }
    }
    this.lookahead = undef; // lookahead token, placed by unget
    this.altInput = undef;
    this.altLevel = undef; // controls prefix prepended to lines
  }

  
    // ........................................................................
  // --- designed to override with a mapping method
  mapLine(line) {
    return line;
  }

  // ........................................................................
  unget(item) {
    // --- item has already been mapped
    debug(item, 'enter unget() with:');
    assert(this.lookahead == null);
    this.lookahead = item;
    debug('return from unget()');
  }

  // ........................................................................
  // --- Put one or more lines back into lBuffer, to be fetched later
  unfetch(str) {
    debug(str, "enter unfetch() with:");
    this.lBuffer.unshift(str);
    this.lineNum -= 1;
    debug('return from unfetch()');
  }

  // ........................................................................
  peek() {
    var item;
    debug('enter peek():');
    if (this.lookahead != null) {
      debug("return lookahead token");
      return this.lookahead;
    }
    item = this.get();
    this.unget(item);
    debug(item, 'return with:');
    return item;
  }

  // ........................................................................
  skip() {
    debug('enter skip():');
    if (this.lookahead != null) {
      this.lookahead = undef;
      debug("return: clear lookahead token");
      return;
    }
    this.get();
    debug('return');
  }

  // ........................................................................
  // --- returns [dir, base] if a valid #include
  checkForInclude(str) {
    var _, base, dir, ext, filename, fname, lMatches, root;
    debug(`enter checkForInclude('${str}')`);
    assert(!str.match(/^\s/), "checkForInclude(): string has indentation");
    if (lMatches = str.match(/^\#include\s+(\S.*)$/)) {
      [_, fname] = lMatches;
      filename = fname.trim();
      ({root, dir, base, ext} = pathlib.parse(filename));
      debug(`found #include ${fname}`);
      if (!root && !dir && this.hIncludePaths && (dir = this.hIncludePaths[ext])) {
        assert(base === filename, `base = ${base}, filename = ${filename}`);
        // --- It's a plain file name with an extension
        //     that we can handle
        debug(`return ['${dir}', '${base}']`);
        return [dir, base];
      } else {
        // --- Output messages if debugging
        if (root || dir) {
          debug(`root='${root}', dir='${dir}'`);
        } else if (!this.hIncludePaths) {
          debug("no hIncludePaths");
        } else if (!this.hIncludePaths[ext]) {
          debug(`no hIncludePaths for ext '${ext}'`);
        }
      }
    }
    debug("return: no #include found");
    return undef;
  }

  // ........................................................................
  // --- Returns undef if either:
  //        1. there's no alt input
  //        2. get from alt input returns undef (then closes alt input)
  getFromAlt() {
    var result;
    debug("enter getFromAlt()");
    if (!this.altInput) {
      error("getFromAlt(): There is no alt input");
    }
    result = this.altInput.get();
    if (result != null) {
      debug(result, "return with:");
      return indentedStr(result, this.altLevel);
    } else {
      debug("return: alt returned undef, alt input removed");
      this.altInput = undef;
      this.altLevel = undef;
      return undef;
    }
  }

  // ........................................................................
  // --- Returns undef if either:
  //        1. there's no alt input
  //        2. get from alt input returns undef (then closes alt input)
  fetchFromAlt() {
    var result;
    debug("enter fetchFromAlt()");
    if (!this.altInput) {
      error("fetchFromAlt(): There is no alt input");
    }
    result = this.altInput.fetch();
    if (result != null) {
      debug(result, "return with:");
      return indentedStr(result, this.altLevel);
    } else {
      debug("return: alt returned undef, alt input removed");
      this.altInput = undef;
      this.altLevel = undef;
      return undef;
    }
  }

  // ........................................................................
  get() {
    var line, result, saved;
    debug(`enter get() (from ${this.filename}):`);
    if (this.lookahead != null) {
      saved = this.lookahead;
      this.lookahead = undef;
      debug(`return (from ${this.filename}) with lookahead token`);
      return saved;
    }
    if (this.altInput && ((line = this.getFromAlt()) != null)) {
      debug(`return with '${line}' (from alt ${this.filename})`);
      return line;
    }
    line = this.fetch(); // will handle #include
    debug(line, "line =");
    if (line == null) {
      debug(`return with undef (from ${this.filename}) at EOF`);
      return undef;
    }
    result = this.mapLine(line);
    while ((result == null) && (this.lBuffer.length > 0)) {
      line = this.fetch();
      result = this.mapLine(line);
    }
    debug(result, `return (from ${this.filename})`);
    return result;
  }

  // ........................................................................
  // --- This should be used to fetch from @lBuffer
  //     to maintain proper @lineNum for error messages
  //     MUST handle #include
  fetch() {
    var altLine, base, dir, lResult, level, line, result, str;
    debug("enter fetch()");
    if (this.altInput && ((result = this.fetchFromAlt()) != null)) {
      debug(result, "return with:");
      return result;
    }
    if (this.lBuffer.length === 0) {
      debug("return - empty buffer, return undef");
      return undef;
    }
    this.lineNum += 1;
    line = this.lBuffer.shift();
    [level, str] = splitLine(line);
    if (lResult = this.checkForInclude(str)) {
      assert(!this.altInput, "get(): altInput already set");
      [dir, base] = lResult;
      this.altInput = new FileInput(`${dir}/${base}`, {
        hIncludePaths: this.hIncludePaths
      });
      this.altLevel = level;
      debug(`alt input created at level ${level}`);
      // --- We just created an alt input
      //     we need to get its first line
      altLine = this.getFromAlt();
      if (altLine != null) {
        debug(`fetch(): getFromAlt returned '${altLine}'`);
        line = altLine;
      } else {
        debug(`fetch(): alt was undef, retain line '${line}'`);
      }
    }
    debug(line, "return from buffer:");
    return line;
  }

  // ........................................................................
  // --- Fetch a block of text at level or greater than 'level'
  //     as one long string
  // --- Designed to use in mapLine()
  fetchBlock(atLevel) {
    var lLines, level, line, result, retval, str;
    debug(`enter fetchBlock(${atLevel})`);
    lLines = [];
    // --- NOTE: I absolutely hate using a backslash for line continuation
    //           but CoffeeScript doesn't continue while there is an
    //           open parenthesis like Python does :-(
    line = undef;
    while ((line = this.fetch())) {
      [level, str] = splitLine(line);
      debug(`LOOP: level = ${level}, str = '${str}'`);
      if (level < atLevel) {
        this.unfetch(line);
        debug("RESULT: unfetch the line");
        break;
      }
      result = this.mapLine(str);
      if (result != null) {
        result = indentedStr(result, level - atLevel);
        debug(result, "RESULT from mapLine() was:");
        lLines.push(result);
      } else {
        debug("RESULT from mapLine() was undef");
      }
    }
    retval = lLines.join('\n');
    debug(retval, "return with:");
    return retval;
  }

  // ........................................................................
  getAll() {
    var lLines, line;
    lLines = [];
    line = this.get();
    while (line != null) {
      lLines.push(line);
      line = this.get();
    }
    return lLines;
  }

  // ........................................................................
  getAllText() {
    return this.getAll().join('\n');
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//   class FileInput - contents from a file
export var FileInput = class FileInput extends StringInput {
  constructor(filename, hOptions = {}) {
    var base, content, dir, ext, root;
    ({root, dir, base, ext} = pathlib.parse(filename.trim()));
    hOptions.filename = base;
    if (unitTesting) {
      content = `Contents of ${base}`;
    } else {
      if (!fs.existsSync(filename)) {
        error(`FileInput(): file '${filename}' does not exist`);
      }
      content = slurp(filename);
    }
    super(content, hOptions);
  }

};

// ---------------------------------------------------------------------------
