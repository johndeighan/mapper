// Generated by CoffeeScript 2.7.0
  // TreeWalker.coffee
import {
  assert,
  undef,
  croak,
  defined,
  OL,
  rtrim,
  isString,
  isNumber,
  isEmpty,
  nonEmpty,
  isArray,
  isHash
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  splitLine,
  indentLevel,
  indented,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  debug,
  debugDebug
} from '@jdeighan/coffee-utils/debug';

import {
  Mapper
} from '@jdeighan/mapper';

import {
  lineToParts,
  mapHereDoc
} from '@jdeighan/mapper/heredoc';

// ===========================================================================
//   class TreeWalker
//      - map() returns {uobj, level, lineNum} or undef
//   to use, override:
//      mapStr(str, level) - returns user object, default returns str
//      handleCmd()
//      beginWalk() -
//      visit(uobj, level, lineNum) -
//      endVisit(uobj, level, lineNum) -
//      endWalk() -
export var TreeWalker = class TreeWalker extends Mapper {
  // ..........................................................
  // --- Should always return either:
  //        undef
  //        object with {uobj, level, lineNum}
  // --- Will only receive non-special lines
  map(line) {
    var hResult, lExtLines, level, lineNum, result, str, uobj;
    debug("enter TreeWalker.map()", line);
    // --- a TreeWalker makes no sense unless items are strings
    assert(isString(line), `non-string: ${OL(line)}`);
    lineNum = this.lineNum; // so extension lines aren't counted
    [level, str] = splitLine(line);
    debug(`split: str = ${OL(str)}, level = ${level}`);
    assert(nonEmpty(str), "empty string should be special");
    // --- check for extension lines
    debug("check for extension lines");
    lExtLines = this.fetchLinesAtLevel(level + 2);
    assert(isArray(lExtLines), "lExtLines not an array");
    str = this.joinExtensionLines(str, lExtLines);
    debug("call super");
    str = super.map(str); // performs variable replacement
    debug("from super", str);
    // --- handle HEREDOCs
    debug("check for HEREDOC");
    if (str.indexOf('<<<') >= 0) {
      hResult = this.handleHereDoc(str, level);
      if (hResult.line !== str) {
        str = hResult.line;
        debug(`line becomes ${OL(str)}`);
      }
    }
    // --- NOTE: mapStr() may return undef, meaning to ignore
    uobj = this.mapStr(str, level);
    if (defined(uobj)) {
      result = {uobj, level, lineNum};
      debug("return from TreeWalker.map()", result);
      return result;
    } else {
      debug("return undef from TreeWalker.map()");
      return undef;
    }
  }

  // ..........................................................
  // --- designed to override
  mapStr(str, level) {
    return str;
  }

  // ..........................................................
  unmap(h) {
    return croak("TreeWalker.unmap() called!");
  }

  // ..........................................................
  joinExtensionLines(line, lExtLines) {
    var contLine, j, len;
// --- There might be empty lines in lExtLines
//     but we'll skip them here
    for (j = 0, len = lExtLines.length; j < len; j++) {
      contLine = lExtLines[j];
      if (nonEmpty(contLine)) {
        line += ' ' + contLine.trim();
      }
    }
    return line;
  }

  // ..........................................................
  handleHereDoc(line, level) {
    var hResult, lLines, lNewParts, lObjects, lParts, part;
    // --- Indentation has been removed from line
    // --- Find each '<<<' and replace with result of mapHereDoc()
    debug(`enter handleHereDoc(level=${OL(level)})`, line);
    assert(isString(line), "not a string");
    lParts = lineToParts(line);
    debug('lParts', lParts);
    lObjects = [];
    lNewParts = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = lParts.length; j < len; j++) {
        part = lParts[j];
        if (part === '<<<') {
          lLines = this.getHereDocLines(level + 1);
          debug('lLines', lLines);
          hResult = mapHereDoc(arrayToBlock(lLines));
          debug('hResult', hResult);
          lObjects.push(hResult.obj);
          results.push(hResult.str);
        } else {
          results.push(part); // keep as is
        }
      }
      return results;
    }).call(this);
    hResult = {
      line: lNewParts.join(''),
      lParts: lParts,
      lObjects: lObjects
    };
    debug("return from handleHereDoc", hResult);
    return hResult;
  }

  // ..........................................................
  getHereDocLines(atLevel) {
    var lLines, result;
    // --- Get all lines until addHereDocLine() returns undef
    //     atLevel will be one greater than the indent
    //        of the line containing <<<
    debug("enter TreeWalker.getHereDocLines()");
    assert(atLevel > 0, `atLevel = ${OL(atLevel)}, should not be 0`);
    lLines = this.fetchLinesAtLevel(atLevel, ''); // stop on blank line
    assert(isArray(lLines), "lLines not an array");
    result = undented(lLines, atLevel);
    debug("return from TreeWalker.getHereDocLines()", result);
    return result;
  }

  // ..........................................................
  extSep(str, nextStr) {
    return ' ';
  }

  // ..........................................................
  isEmptyHereDocLine(str) {
    return str === '.';
  }

  // ..........................................................
  // --- We don't define any new commands, but
  //     we need to determine level from indentation
  handleCmd(h) {
    var level, result, uobj;
    debug("enter TreeWalker.handleCmd()");
    result = super.handleCmd(h);
    if (result === undef) {
      debug("return undef from TreeWalker.handleCmd() - super undef");
      return undef;
    }
    assert(isString(result), `TreeWalker non-string ${OL(result)}`);
    [level, uobj] = splitLine(result);
    result = {
      uobj,
      level,
      lineNum: this.lineNum
    };
    debug("return from TreeWalker.handleCmd()", result);
    return result;
  }

  // ..........................................................
  fetchLinesAtLevel(atLevel, stopOn = undef) {
    var item, lLines;
    // --- Does NOT remove any indentation
    debug(`enter TreeWalker.fetchLinesAtLevel(${OL(atLevel)}, ${OL(stopOn)})`);
    assert(atLevel > 0, "atLevel is 0");
    lLines = [];
    while (defined(item = this.fetch()) && debug(`item = ${OL(item)}`) && isString(item) && ((stopOn === undef) || (item !== stopOn)) && debug("OK") && (isEmpty(item) || (indentLevel(item) >= atLevel))) {
      debug(`push ${OL(item)}`);
      lLines.push(item);
    }
    // --- Cases:                            unfetch?
    //        1. item is undef                 NO
    //        2. item not a string             YES
    //        3. item == stopOn (& defined)    NO
    //        4. item nonEmpty and undented    YES
    if ((item === undef) || (item === stopOn)) {
      debug("don't unfetch");
    } else {
      debug("do unfetch");
      this.unfetch(item);
    }
    debug("return from TreeWalker.fetchLinesAtLevel()", lLines);
    return lLines;
  }

  // ..........................................................
  fetchBlockAtLevel(atLevel, stopOn = undef) {
    var lLines, result;
    debug(`enter TreeWalker.fetchBlockAtLevel(${OL(atLevel)})`);
    lLines = this.fetchLinesAtLevel(atLevel, stopOn);
    debug('lLines', lLines);
    lLines = undented(lLines, atLevel);
    debug("undented lLines", lLines);
    result = arrayToBlock(lLines);
    debug("return from TreeWalker.fetchBlockAtLevel()", result);
    return result;
  }

  // ..........................................................
  // --- override these for tree walking
  beginWalk() {
    return undef;
  }

  // ..........................................................
  visit(uobj, level, lineNum) {
    return indented(uobj, level);
  }

  // ..........................................................
  endVisit(uobj, level, lineNum) {
    return undef;
  }

  // ..........................................................
  endWalk() {
    return undef;
  }

  // ..........................................................
  walk() {
    var hUser, i, lStack, level, line, lineNum, newNode, node, ref, result, uobj;
    debug("enter walk()");
    // --- stack of {
    //        node: {uobj, level, lineNum},
    //        hUser: {_parent: <parent node>, ...}
    //        }
    lStack = [];
    this.lLines = []; // --- resulting lines
    debug("begin walk");
    line = this.beginWalk();
    if (defined(line)) {
      this.addLine(line);
    }
    debug("getting nodes");
    i = 0;
    ref = this.allMapped();
    for (newNode of ref) {
      i += 1;
      debug(`NODE ${i}`, newNode);
      while (lStack.length > newNode.level) {
        ({node, hUser} = lStack.pop());
        ({uobj, level, lineNum} = node);
        line = this.endVisit(uobj, level, lineNum, hUser);
        if (defined(line)) {
          this.addLine(line);
        }
      }
      // --- Create a user hash that the user can add to/modify
      //     and will see again at endVisit
      if (lStack.length === 0) {
        hUser = {
          _parent: undef
        };
      } else {
        hUser = {
          _parent: lStack[lStack.length - 1].node
        };
      }
      lStack.push({
        node: newNode,
        hUser
      });
      ({uobj, level, lineNum} = newNode);
      line = this.visit(uobj, level, lineNum, hUser);
      if (defined(line)) {
        this.addLine(line);
      }
    }
    debug(`${i} nodes found`);
    while (lStack.length > 0) {
      ({node, hUser} = lStack.pop());
      ({uobj, level, lineNum} = node);
      line = this.endVisit(uobj, level, lineNum, hUser);
      if (defined(line)) {
        this.addLine(line);
      }
    }
    line = this.endWalk();
    if (defined(line)) {
      this.addLine(line);
    }
    result = arrayToBlock(this.lLines);
    debug("return from walk()", result);
    return result;
  }

  // ..........................................................
  addLine(line) {
    assert(defined(line), "line is undef");
    debug(`enter addLine(${OL(line)})`, line);
    if (isArray(line)) {
      debug("line is an array");
      this.lLines.push(...line);
    } else {
      this.lLines.push(line);
    }
    debug("return from addLine()");
  }

  // ..........................................................
  getBlock() {
    var result;
    debug("enter getBlock()");
    result = this.walk();
    debug("return from getBlock()", result);
    return result;
  }

};

// ---------------------------------------------------------------------------
export var TraceWalker = class TraceWalker extends TreeWalker {
  // ..........................................................
  //     builds a trace of the tree
  //        which is returned by endWalk()
  beginWalk() {
    this.lTrace = ["begin"]; // an array of strings
  }

  // ..........................................................
  visit(uobj, level, lineNum) {
    this.lTrace.push("|.".repeat(level) + `> ${OL(uobj)}`);
  }

  // ..........................................................
  endVisit(uobj, level, lineNum) {
    this.lTrace.push("|.".repeat(level) + `< ${OL(uobj)}`);
  }

  // ..........................................................
  endWalk() {
    var block;
    this.lTrace.push("end");
    block = arrayToBlock(this.lTrace);
    this.lTrace = undef;
    return block;
  }

};
