// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  assert,
  undef,
  croak,
  isString,
  isEmpty,
  nonEmpty,
  OL
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  splitLine,
  indented,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  LineFetcher
} from '@jdeighan/mapper/fetcher';

// ===========================================================================
//   class Mapper
//      - keep track of indentation
//      - allow mapping of lines, including skipping lines
//      - implement look ahead via peekPair()
export var Mapper = class Mapper extends LineFetcher {
  constructor(source, content) {
    super(source, content);
    this.lLookAhead = [];
    // --- cache in case getAllPairs() is called multiple times
    //     each pair is [<mapped str>, <level>]
    this.lAllPairs = undef;
  }

  // ..........................................................
  getPair() {
    var lResult, level, line, pair, result, str;
    debug(`enter Mapper.getPair() - from ${this.filename}`);
    if (this.lLookAhead.length > 0) {
      pair = this.lLookAhead.shift();
      debug("return lookahead pair from Mapper.getPair()", pair);
      return pair;
    }
    line = this.fetch(); // will handle #include
    debug("FETCH LINE", line);
    if (line == null) {
      debug("return undef from Mapper.getPair() - at EOF");
      return undef;
    }
    [level, str] = splitLine(line);
    assert(indentLevel(str) === 0, "splitLine() returned indented str");
    assert((str != null) && isString(str), "Mapper.getPair(): not a string");
    result = this.mapLine(str, level);
    debug(`MAP: '${str}' => ${OL(result)}`);
    while ((result == null) && !this.eof()) {
      line = this.fetch();
      [level, str] = splitLine(line);
      assert(indentLevel(str) === 0, "splitLine() returned indented str");
      result = this.mapLine(str, level);
      debug(`MAP: '${str}' => ${OL(result)}`);
    }
    lResult = [result, level];
    debug("return from Mapper.getPair()", lResult);
    return lResult;
  }

  // ..........................................................
  ungetPair(lPair) {
    // --- lPair will always be [<item>, <level>]
    //     <item> can be anything - i.e. it's been mapped
    debug('enter ungetPair()', lPair);
    this.lLookAhead.unshift(lPair);
    debug('return from ungetPair()');
  }

  // ..........................................................
  peekPair() {
    var lPair, pair;
    debug('enter peekPair():');
    if (this.lLookAhead.length > 0) {
      pair = this.lLookAhead[0];
      debug("return lookahead from peekPair()", pair);
      return pair;
    }
    lPair = this.getPair();
    if (lPair == null) {
      debug("return undef from peekPair() - getPair() returned undef");
      return undef;
    }
    this.ungetPair(lPair);
    debug(`return ${OL(lPair)} from peekPair()`);
    return lPair;
  }

  // ..........................................................
  skipPair() {
    debug('enter skipPair():');
    if (this.lLookAhead.length > 0) {
      this.lLookAhead.shift();
      debug("return from skipPair(): remove lookahead");
      return;
    }
    this.getPair();
    debug('return from skipPair()');
  }

  // ..........................................................
  // --- designed to override with a mapping method
  //     which can map to any valid JavaScript value
  mapLine(line, level) {
    return line;
  }

  // ..........................................................
  // --- Fetch a block of text at level or greater than 'level'
  //     as one long string
  // --- Designed to use in mapLine()
  fetchBlock(atLevel) {
    var block, lLines, level, line, result, str;
    debug(`enter Mapper.fetchBlock(${atLevel})`);
    lLines = [];
    line = undef;
    while ((line = this.fetch()) != null) {
      debug(`LINE IS ${OL(line)}`);
      assert(isString(line), `Mapper.fetchBlock() - not a string: ${OL(line)}`);
      if (isEmpty(line)) {
        debug("empty line");
        lLines.push('');
        continue;
      }
      [level, str] = splitLine(line);
      assert(indentLevel(str) === 0, "Mapper.fetchBlock(): splitLine() returned indented str");
      debug(`LOOP: level = ${level}, str = ${OL(str)}`);
      if (level < atLevel) {
        this.unfetch(line);
        debug("RESULT: unfetch the line");
        break;
      }
      assert(level >= atLevel, "Mapper.fetchBlock(): bad level");
      result = indented(str, level - atLevel);
      debug("RESULT", result);
      lLines.push(result);
    }
    block = arrayToBlock(lLines);
    debug("return from Mapper.fetchBlock()", block);
    return block;
  }

  // ..........................................................
  getAllPairs() {
    var lPair, lPairs;
    debug("enter Mapper.getAllPairs()");
    if (this.lAllPairs != null) {
      debug("return cached lAllPairs from Mapper.getAllPairs()");
      return this.lAllPairs;
    }
    // --- Each pair is [<result>, <level>],
    //     where <result> can be anything
    lPairs = [];
    while ((lPair = this.getPair()) != null) {
      debug("GOT PAIR", lPair);
      lPairs.push(lPair);
    }
    this.lAllPairs = lPairs; // cache
    debug("return from Mapper.getAllPairs()", lPairs);
    return lPairs;
  }

  // ..........................................................
  getBlock() {
    var block, i, lLines, len, level, line, ref;
    // --- You can only call getBlock() if mapLine() always
    //     returns undef or a string
    debug("enter Mapper.getBlock()");
    lLines = [];
    ref = this.getAllPairs();
    for (i = 0, len = ref.length; i < len; i++) {
      [line, level] = ref[i];
      if (line != null) {
        assert(isString(line), `getBlock(): got non-string '${OL(line)}'`);
        lLines.push(indented(line, level));
      }
    }
    block = arrayToBlock(lLines);
    debug("return from Mapper.getBlock()", block);
    return block;
  }

};

// ===========================================================================
export var doMap = function(inputClass, source, text) {
  var className, lMatches, oInput, result;
  assert(inputClass != null, "Missing input class");
  if (lMatches = inputClass.toString().match(/class\s+(\w+)/)) {
    className = lMatches[1];
  } else {
    croak("doMap(): Bad input class");
  }
  debug(`enter doMap(${className}) source='${source}'`);
  oInput = new inputClass(source, text);
  assert(oInput instanceof Mapper, "doMap() requires a Mapper or subclass");
  result = oInput.getBlock();
  debug("return from doMap()", result);
  return result;
};
