// Generated by CoffeeScript 2.5.1
// coffee.coffee
var indexOf = [].indexOf;

import {
  strict as assert
} from 'assert';

import CoffeeScript from 'coffeescript';

import {
  unitTesting,
  croak,
  arrayToString,
  oneline,
  isEmpty,
  nonEmpty,
  words,
  undef,
  deepCopy
} from '@jdeighan/coffee-utils';

import {
  log
} from '@jdeighan/coffee-utils/log';

import {
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  mydir,
  pathTo,
  slurp,
  barf
} from '@jdeighan/coffee-utils/fs';

import {
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  CoffeeMapper,
  CoffeePostMapper,
  SmartInput
} from '@jdeighan/string-input';

import {
  ASTWalker
} from '@jdeighan/string-input/tree';

import {
  tamlStringify
} from '@jdeighan/string-input/taml';

// ---------------------------------------------------------------------------
export var brewExpr = function(expr, force = false) {
  var err, newexpr, pos;
  assert(indentLevel(expr) === 0, "brewCoffee(): has indentation");
  if (unitTesting && !force) {
    return expr;
  }
  try {
    newexpr = CoffeeScript.compile(expr, {
      bare: true
    }).trim();
    // --- Remove any trailing semicolon
    pos = newexpr.length - 1;
    if (newexpr.substr(pos, 1) === ';') {
      newexpr = newexpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, "brewExpr", expr);
  }
  return newexpr;
};

// ---------------------------------------------------------------------------
export var brewCoffee = function(...lBlocks) {
  var blk, err, hAllNeeded, hNeeded, i, j, lResult, len, newblk, script;
  debug("enter brewCoffee()");
  lResult = [];
  hAllNeeded = {}; // { <lib>: [ <symbol>, ...], ...}
  for (i = j = 0, len = lBlocks.length; j < len; i = ++j) {
    blk = lBlocks[i];
    debug(`BLOCK ${i}`, blk);
    newblk = preProcessCoffee(blk);
    debug("NEW BLOCK", newblk);
    // --- returns {<lib>: [<symbol>,... ],... }
    hNeeded = getNeededSymbols(newblk);
    mergeNeededSymbols(hAllNeeded, hNeeded);
    if (unitTesting) {
      lResult.push(newblk);
    } else {
      try {
        script = CoffeeScript.compile(newblk, {
          bare: true
        });
        debug("BREWED SCRIPT", script);
        lResult.push(postProcessCoffee(script));
      } catch (error) {
        err = error;
        log("Mapped Text:", newblk);
        croak(err, "Original Text", blk);
      }
    }
  }
  lResult.push(buildImportList(hAllNeeded));
  return lResult;
};

// ---------------------------------------------------------------------------
export var preProcessCoffee = function(code) {
  var newcode, oInput;
  // --- Removes blank lines and comments
  //     inteprets <== as svelte reactive statement or block
  assert(indentLevel(code) === 0, "preProcessCoffee(): has indentation");
  oInput = new CoffeeMapper(code);
  newcode = oInput.getAllText();
  debug('newcode', newcode);
  return newcode;
};

// ---------------------------------------------------------------------------
export var postProcessCoffee = function(code) {
  var oInput;
  // --- variable declaration immediately following one of:
  //        $:{
  //        $:
  //     should be moved above this line
  oInput = new CoffeePostMapper(code);
  return oInput.getAllText();
};

// ---------------------------------------------------------------------------
export var addImports = function(text, lImports) {
  var stmt;
  if (!unitTesting) {
    lImports = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = lImports.length; j < len; j++) {
        stmt = lImports[j];
        results.push(`${stmt};`);
      }
      return results;
    })();
  }
  return joinBlocks(...lImports, text);
};

// ---------------------------------------------------------------------------
export var mergeNeededSymbols = function(hAllNeeded, hNeeded) {
  var j, k, len, len1, lib, ref, ref1, sym;
  ref = Object.keys(hNeeded);
  //  both are: { <lib>: [ <symbol>, ...], ...}
  for (j = 0, len = ref.length; j < len; j++) {
    lib = ref[j];
    if (hAllNeeded[lib] != null) {
      ref1 = hNeeded[lib];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        sym = ref1[k];
        if (indexOf.call(hAllNeeded[lib], sym) < 0) {
          hAllNeeded[lib].push(sym);
        }
      }
    } else {
      hAllNeeded[lib] = deepCopy(hNeeded[lib]);
    }
  }
};

// ---------------------------------------------------------------------------
export var getNeededSymbols = function(code, hOptions = {}) {
  var hAvailSymbols, hMissing, hNeeded, j, len, lib, ref, sym;
  // --- Valid options:
  //        dumpfile: <filepath>   - where to dump ast
  // --- returns { <lib>: [ <symbol>, ... ], ... }
  debug("enter getNeededSymbols()");
  hMissing = getMissingSymbols(code, hOptions);
  if (isEmpty(hMissing)) {
    debug("return {} from getNeededSymbols() - no missing symbols");
    return {};
  }
  hAvailSymbols = getAvailSymbols();
  if (isEmpty(hAvailSymbols)) {
    debug("return {} from getNeededSymbols() - no avail symbols");
    return {};
  }
  hNeeded = {}; // { <lib>: [ <symbol>, ...], ...}
  ref = Object.keys(hMissing);
  for (j = 0, len = ref.length; j < len; j++) {
    sym = ref[j];
    if (lib = hAvailSymbols[sym]) {
      if (hNeeded[lib]) {
        hNeeded[lib].push(sym);
      } else {
        hNeeded[lib] = [sym];
      }
    }
  }
  return hNeeded;
};

// ---------------------------------------------------------------------------
export var buildImportList = function(hNeeded) {
  var j, lImports, len, lib, ref, symbols;
  lImports = [];
  ref = Object.keys(hNeeded).sort();
  for (j = 0, len = ref.length; j < len; j++) {
    lib = ref[j];
    symbols = hNeeded[lib].join(',');
    lImports.push(`import {${symbols}} from '${lib}'`);
  }
  return lImports;
};

// ---------------------------------------------------------------------------
export var getNeededImports = function(code, hOptions = {}) {
  var hNeeded, j, lImports, len, lib, ref, symbols;
  // --- Valid options:
  //        dumpfile: <filepath>   - where to dump ast
  // --- returns lImports
  debug("enter getNeededImports()");
  hNeeded = getNeededSymbols(code, hOptions);
  lImports = [];
  ref = Object.keys(hNeeded);
  for (j = 0, len = ref.length; j < len; j++) {
    lib = ref[j];
    symbols = hNeeded[lib].join(',');
    lImports.push(`import {${symbols}} from '${lib}'`);
  }
  debug("return from getNeededImports()");
  return lImports;
};

// ---------------------------------------------------------------------------
export var getMissingSymbols = function(code, hOptions = {}) {
  var ast, err, hMissingSymbols, walker;
  // --- Valid options:
  //        dumpfile: <filepath>   - where to dump ast
  debug("enter getMissingSymbols()");
  try {
    debug("COMPILE CODE", code);
    ast = CoffeeScript.compile(code, {
      ast: true
    });
    assert(ast != null, "getMissingSymbols(): ast is empty");
  } catch (error) {
    err = error;
    croak(err, 'CODE (in getMissingSymbols)', code);
  }
  walker = new ASTWalker(ast);
  hMissingSymbols = walker.getMissingSymbols();
  if (hOptions.dumpfile) {
    barf(hOptions.dumpfile, "AST:\n" + tamlStringify(walker.ast));
  }
  debug("return from getMissingSymbols()");
  return hMissingSymbols;
};

// ---------------------------------------------------------------------------
// export to allow unit testing
export var getAvailSymbols = function() {
  var SymbolParser, contents, filepath, hSymbols, parser, searchFromDir;
  debug("enter getAvailSymbols()");
  searchFromDir = process.env.DIR_SYMBOLS || mydir(import.meta.url);
  debug(`search for .symbols from '${searchFromDir}'`);
  filepath = pathTo('.symbols', searchFromDir, 'up');
  if (filepath == null) {
    debug("return from getAvailSymbols() - no .symbols file found");
    return {};
  }
  debug(`.symbols file found at '${filepath}'`);
  SymbolParser = class SymbolParser extends SmartInput {
    // --- We want to allow blank lines and comments
    //     We want to allow continuation lines
    constructor(content) {
      super(content);
      this.curLib = undef;
      this.hSymbols = {};
    }

    mapString(line, level) {
      var j, len, ref, symbol;
      if (level === 0) {
        this.curLib = line;
      } else if (level === 1) {
        assert(this.curLib != null, "SymbolFileParser: curLib not defined");
        ref = words(line);
        for (j = 0, len = ref.length; j < len; j++) {
          symbol = ref[j];
          assert(this.hSymbols[symbol] == null);
          this.hSymbols[symbol] = this.curLib;
        }
      } else {
        croak(`Bad .symbols file - level = ${level}`);
      }
      return undef; // doesn't matter what we return
    }

    getSymbols() {
      this.skipAll();
      return this.hSymbols;
    }

  };
  contents = slurp(filepath);
  debug('Contents of .symbols', contents);
  parser = new SymbolParser(contents);
  hSymbols = parser.getSymbols();
  debug(`return ${oneline(hSymbols)} from getAvailSymbols()`);
  return hSymbols;
};
