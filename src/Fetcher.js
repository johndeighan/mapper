// Generated by CoffeeScript 2.7.0
// Fetcher.coffee
import fs from 'fs';

import {
  LOG,
  LOGVALUE,
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  getOptions
} from '@jdeighan/base-utils/utils';

import {
  dbg,
  dbgEnter,
  dbgReturn,
  dbgYield,
  dbgResume
} from '@jdeighan/base-utils/debug';

import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  notdefined,
  escapeStr,
  isString,
  isHash,
  isArray,
  isInteger,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  indentLevel,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  toBlock,
  toArray
} from '@jdeighan/coffee-utils/block';

import {
  parseSource,
  slurp,
  isSimpleFileName,
  isDir,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

// ---------------------------------------------------------------------------
//   class Fetcher
//      - sets @hSourceInfo
//      - fetch()
//      - handles extension lines
//      - removes trailing WS from strings
//      - stops at __END__
//      - all() - generator
//      - allUntil() - generator
export var Fetcher = class Fetcher {
  constructor(hInput, options = {}) {
    var addLevel, content, fullpath, source;
    dbgEnter("Fetcher", hInput, options);
    // --- We need to set:
    //        @hSourceInfo - information about the source of input
    //        @iterator    - must be an iterator

    // --- hInput can be a plain string,
    //     or a hash with keys 'source' and/or 'content'
    if (isString(hInput)) {
      this.hSourceInfo = {
        filename: '<unknown>'
      };
      content = hInput;
    } else {
      assert(isHash(hInput), `not a hash: ${OL(hInput)}`);
      ({source, content} = hInput);
      assert(defined(source) || defined(content), "No source or content");
      if (defined(source)) {
        this.hSourceInfo = parseSource(source);
      } else {
        dbg("No source, so filename is <unknown>");
        this.hSourceInfo = {
          filename: '<unknown>'
        };
      }
      if (!defined(content)) {
        dbg("No content - check for fullpath");
        fullpath = this.hSourceInfo.fullpath;
        assert(fullpath, "No content and no fullpath");
        dbg(`slurping ${fullpath}`);
        content = slurp(fullpath);
      }
    }
    // --- @hSourceInfo must exist and have a filename key
    dbg('hSourceInfo', this.hSourceInfo);
    assert(this.hSourceInfo.filename, "parseSource returned no filename");
    // --- content must be iterable
    if (isString(content)) {
      content = toArray(content);
    }
    assert(isIterable(content), "content not iterable");
    this.iterator = content[Symbol.iterator]();
    // --- Handle options
    ({addLevel} = getOptions(options));
    this.addLevel = addLevel || 0;
    this.lookahead = undef; // if defined, [level, str]
    this.numBlankLines = 0; // num blank lines to return before lookahead
    this.altInput = undef; // implements #include
    this.lineNum = 0;
    this.oneIndent = undef; // set from 1st line with indentation
    this.forcedEOF = false;
    this.init();
    dbgReturn("Fetcher");
  }

  // ..........................................................
  init() {}

  // ..........................................................
  // --- returns [level, str] or [undef, undef]
  //     handles:
  //        return lookahead if defined
  //        return undef if __END__ previously found
  //        return undef if iterator at EOF
  //        check for __END__
  //        Determine level, set @oneIndent if possible
  fetchLine() {
    var _, done, lMatches, level, line, prefix, result, str;
    dbgEnter("Fetcher.fetchLine");
    // --- return any blank lines
    if (this.numBlankLines > 0) {
      dbg(`found ${this.numBlankLines} blank lines`);
      this.numBlankLines = -1;
      this.incLineNum();
      dbgReturn("Fetcher.fetchLine", '');
      return [0, ''];
    }
    // --- return anything in @lookahead,
    //     even if @forcedEOF is true
    if (defined(this.lookahead)) {
      dbg("found lookahead");
      result = this.lookahead;
      this.lookahead = undef;
      this.incLineNum();
      dbgReturn("Fetcher.fetchLine", result);
      return result;
    }
    dbg("no lookahead");
    if (this.forcedEOF) {
      dbg("forced EOF");
      dbgReturn("Fetcher.fetchLine", [undef, undef]);
      return [undef, undef];
    }
    dbg("not at forced EOF");
    ({
      value: line,
      done
    } = this.iterator.next());
    dbg("iterator returned", {line, done});
    if (done) {
      dbg("iterator DONE");
      dbgReturn("Fetcher.fetchLine", [undef, undef]);
      return [undef, undef];
    }
    assert(isString(line), `line is ${OL(line)}`);
    if (lMatches = line.match(/^(\s*)__END__$/)) {
      [_, prefix] = lMatches;
      assert(prefix === '', "__END__ should be at level 0");
      this.forceEOF();
      dbg("found __END__");
      dbgReturn("Fetcher.fetchLine", [undef, undef]);
      return [undef, undef];
    }
    this.incLineNum();
    [prefix, str] = splitPrefix(line);
    // --- Determine level
    if (prefix === '') {
      level = 0;
    } else if (defined(this.oneIndent)) {
      level = indentLevel(prefix, this.oneIndent);
    } else {
      // --- Set @oneIndent
      if (lMatches = prefix.match(/^\t+$/)) {
        this.oneIndent = "\t";
        level = prefix.length;
      } else {
        this.oneIndent = prefix;
        level = 1;
      }
      dbg("oneIndent", this.oneIndent);
    }
    assert((prefix === '') || defined(this.oneIndent), `Bad prefix ${OL(prefix)}`);
    result = [level, str];
    dbgReturn("Fetcher.fetchLine", result);
    return result;
  }

  // ..........................................................
  // --- returns hNode with keys:
  //        source
  //        lineNum
  //        str
  //        srcLevel - level in source code
  //        level    - includes added levels when #include'ing
  fetch() {
    var _, actualLineNum, fname, hNode, lMatches, level, nextLevel, nextStr, str;
    dbgEnter("Fetcher.fetch");
    // --- Check if data available from @altInput
    if (defined(this.altInput)) {
      dbg("has altInput");
      hNode = this.altInput.fetch();
      // --- NOTE: hNode.str will never be #include
      //           because altInput's fetch would handle it
      if (defined(hNode)) {
        // --- NOTE: altInput was created knowing how many levels
        //           to add due to indentation in #include statement
        assert(hNode instanceof Node, `Not a Node: ${OL(hNode)}`);
        dbg("from alt");
        dbgReturn("Fetcher.fetch", hNode);
        return hNode;
      }
      // --- alternate input is exhausted
      this.altInput = undef;
      dbg("alt EOF");
    } else {
      dbg("there is no altInput");
    }
    // --- At EOF, @fetchLine() returns [undef, undef]
    [level, str] = this.fetchLine();
    assert(notdefined(this.lookahead), `lookahead after fetchLine: ${OL(this.lookahead)}`);
    if (notdefined(str)) {
      dbgReturn("Fetcher.fetch", undef);
      return undef;
    }
    assert(isString(str), `not a string: ${OL(str)}`);
    // --- Handle extension lines
    actualLineNum = this.lineNum; // save current line number
    [nextLevel, nextStr] = this.fetchLine();
    while (defined(nextStr) && (nextLevel >= level + 2)) {
      str += this.extSep(str, nextStr) + nextStr;
      [nextLevel, nextStr] = this.fetchLine();
    }
    if (defined(nextStr)) {
      if (nextStr === '') {
        dbg("inc numBlankLines");
        this.numBlankLines += 1;
      } else {
        dbg("set lookahead", [nextLevel, nextStr]);
        this.lookahead = [nextLevel, nextStr];
      }
      dbg("dec lineNum");
      this.decLineNum();
    }
    // --- check for #include
    if (lMatches = str.match(/^\#include\b\s*(.*)$/)) {
      [_, fname] = lMatches;
      dbg(`#include ${fname}`);
      assert(nonEmpty(fname), "missing file name in #include");
      this.createAltInput(fname, level);
      hNode = this.fetch(); // recursive call
      dbgReturn("Fetcher.fetch", hNode);
      return hNode;
    } else {
      dbg("no #include");
    }
    dbg("create Node object");
    hNode = new Node({
      str: str,
      level: level + this.addLevel,
      source: this.sourceInfoStr(actualLineNum),
      lineNum: actualLineNum
    });
    dbgReturn("Fetcher.fetch", hNode);
    return hNode;
  }

  // ..........................................................
  sourceInfoStr(lineNum) {
    var lParts;
    if (defined(lineNum)) {
      assert(isInteger(lineNum), `Bad lineNum: ${OL(lineNum)}`);
    } else {
      lineNum = this.lineNum;
    }
    lParts = [];
    lParts.push(`${this.hSourceInfo.filename}/${lineNum}`);
    if (defined(this.altInput)) {
      lParts.push(this.altInput.sourceInfoStr());
    }
    return lParts.join(' ');
  }

  // ..........................................................
  extSep(str, nextStr) {
    return ' ';
  }

  // ..........................................................
  createAltInput(fname, level) {
    var dir, fullpath;
    dbgEnter("Fetcher.createAltInput", fname, level);
    // --- Make sure we have a simple file name
    assert(isString(fname), `not a string: ${OL(fname)}`);
    assert(isSimpleFileName(fname), `not a simple file name: ${OL(fname)}`);
    // --- Decide which directory to search for file
    dir = this.hSourceInfo.dir;
    if (dir) {
      assert(isDir(dir), `not a directory: ${OL(dir)}`);
    } else {
      dir = process.cwd(); // --- Use current directory
    }
    fullpath = pathTo(fname, dir);
    dbg("fullpath", fullpath);
    if (fullpath === undef) {
      croak(`Can't find include file ${fname} in dir ${dir}`);
    }
    assert(fs.existsSync(fullpath), `${fullpath} does not exist`);
    this.altInput = new Fetcher({
      source: fullpath
    }, {
      addLevel: level
    });
    dbgReturn("Fetcher.createAltInput");
  }

  // ..........................................................
  incLineNum(inc = 1) {
    dbgEnter("Fetcher.incLineNum", inc);
    this.lineNum += inc;
    dbg(`lineNum = ${this.lineNum}`);
    dbgReturn("Fetcher.incLineNum");
  }

  // ..........................................................
  decLineNum(dec = 1) {
    dbgEnter("Fetcher.decLineNum", dec);
    this.lineNum -= dec;
    dbg(`lineNum = ${this.lineNum}`);
    dbgReturn("Fetcher.decLineNum");
  }

  // ..........................................................
  forceEOF() {
    dbgEnter("forceEOF");
    this.forcedEOF = true;
    dbgReturn("forceEOF");
  }

  // ..........................................................
  // --- GENERATOR
  * all() {
    var hNode;
    dbgEnter("Fetcher.all");
    while (defined(hNode = this.fetch())) {
      dbgYield("Fetcher.all", hNode);
      yield hNode;
      dbgResume("Fetcher.all");
    }
    dbgReturn("Fetcher.all");
  }

  // ..........................................................
  // --- GENERATOR
  * allUntil(func, options = {}) {
    var hNode, keepEndLine, ref;
    // --- stop when func(hNode) returns true
    dbgEnter("Fetcher.allUntil", func, options);
    assert(isFunction(func), "Arg 1 not a function");
    ({keepEndLine} = getOptions(options));
    ref = this.all();
    for (hNode of ref) {
      assert(defined(hNode), "BAD - hNode is undef in allUntil()");
      if (func(hNode)) {
        // --- When func returns true, we're done
        //     We don't return hNode, but might save it
        if (keepEndLine) {
          this.lookahead = hNode;
        }
        dbgReturn("Fetcher.allUntil");
        return;
      }
      dbgYield("Fetcher.allUntil", hNode);
      yield hNode;
      dbgResume("Fetcher.allUntil");
    }
    dbgReturn("Fetcher.allUntil");
  }

  // ..........................................................
  getBlockUntil(func, options = {}) {
    var hNode, lLines, oneIndent, ref, result;
    dbgEnter("Fetcher.getBlockUntil");
    ({oneIndent} = getOptions(options));
    lLines = [];
    ref = this.allUntil(func, options);
    for (hNode of ref) {
      lLines.push(hNode.getLine(oneIndent)); // uses TAB if undef
    }
    result = toBlock(lLines);
    dbgReturn("Fetcher.getBlockUntil", result);
    return result;
  }

  // ..........................................................
  getBlock(options = {}) {
    var hNode, lLines, oneIndent, ref, result;
    dbgEnter("Fetcher.getBlock");
    ({oneIndent} = getOptions(options));
    lLines = [];
    ref = this.all();
    for (hNode of ref) {
      lLines.push(hNode.getLine(oneIndent));
    }
    result = this.finalizeBlock(toBlock(lLines));
    dbgReturn("Fetcher.getBlock", result);
    return result;
  }

  // ..........................................................
  finalizeBlock(block) {
    return block;
  }

};
