// Generated by CoffeeScript 2.5.1
  // TreeWalker.coffee
import {
  strict as assert
} from 'assert';

import CoffeeScript from 'coffeescript';

import {
  say,
  pass,
  undef,
  error,
  warn,
  isString,
  isArray,
  isHash,
  isArrayOfHashes,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  debug,
  debugging
} from '@jdeighan/coffee-utils/debug';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

// ---------------------------------------------------------------------------
export var TreeWalker = class TreeWalker {
  constructor(root) {
    this.root = root;
    // --- root can be a hash or array of hashes
    pass;
  }

  // ..........................................................
  walk() {
    if (isHash(this.root)) {
      this.walkNode(this.root, 0);
    } else if (isArrayOfHashes(this.root)) {
      this.walkNodes(this.root, 0);
    } else {
      error("TreeWalker: Invalid root");
    }
  }

  // ..........................................................
  walkSubTrees(lSubTrees, level) {
    var i, len, subtree;
    for (i = 0, len = lSubTrees.length; i < len; i++) {
      subtree = lSubTrees[i];
      if (subtree != null) {
        if (isArray(subtree)) {
          this.walkNodes(subtree, level);
        } else if (isHash(subtree)) {
          this.walkNode(subtree, level);
        } else {
          error("Invalid subtree");
        }
      }
    }
  }

  // ..........................................................
  walkNode(node, level) {
    var lSubTrees;
    lSubTrees = this.visit(node, level);
    if (lSubTrees) {
      this.walkSubTrees(lSubTrees, level + 1);
    }
    return this.endVisit(node, level);
  }

  // ..........................................................
  walkNodes(lNodes, level = 0) {
    var i, len, node;
    for (i = 0, len = lNodes.length; i < len; i++) {
      node = lNodes[i];
      this.walkNode(node, level);
    }
  }

  // ..........................................................
  // --- return lSubTrees, if any
  visit(node, level) {
    return node.body; // it's handled ok if node.body is undef
  }

  
    // ..........................................................
  // --- called after all subtrees have been visited
  endVisit(node, level) {}

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var TreeStringifier = class TreeStringifier extends TreeWalker {
  constructor(tree) {
    super(tree); // sets @tree
    this.lLines = [];
  }

  // ..........................................................
  visit(node, level) {
    var str;
    assert(node != null, "TreeStringifier.visit(): empty node");
    debug("enter visit()");
    str = indented(this.stringify(node), level);
    debug(`stringified: '${str}'`);
    this.lLines.push(str);
    if (node.body) {
      debug("return from visit() - has subtree 'body'");
      return node.body;
    } else {
      debug("return from visit()");
      return undef;
    }
  }

  // ..........................................................
  get() {
    this.walk();
    return this.lLines.join('\n');
  }

  // ..........................................................
  excludeKey(key) {
    return key === 'body';
  }

  // ..........................................................
  // --- override this
  stringify(node) {
    var key, newnode, value;
    assert(isHash(node), `TreeStringifier.stringify(): node '${node}' is not a hash`);
    newnode = {};
    for (key in node) {
      value = node[key];
      if (!this.excludeKey(key)) {
        newnode[key] = node[key];
      }
    }
    return JSON.stringify(newnode);
  }

};
