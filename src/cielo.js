// Generated by CoffeeScript 2.6.1
  // cielo.coffee
import {
  undef,
  assert,
  croak,
  isString,
  uniq
} from '@jdeighan/coffee-utils';

import {
  log,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  withExt,
  slurp,
  barf,
  newerDestFileExists,
  shortenPath
} from '@jdeighan/coffee-utils/fs';

import {
  doMap,
  StringInput,
  SmartInput
} from '@jdeighan/string-input';

import {
  addHereDocType
} from '@jdeighan/string-input/heredoc';

import {
  getNeededSymbols,
  buildImportList
} from '@jdeighan/string-input/symbols';

import {
  coffeeCodeToJS
} from '@jdeighan/string-input/coffee';

import {
  FuncHereDoc
} from '@jdeighan/string-input/func';

addHereDocType(new FuncHereDoc());

export var convertingCielo = true;

// ---------------------------------------------------------------------------
export var convertCielo = function(flag) {
  convertingCielo = flag;
};

// ---------------------------------------------------------------------------
export var cieloCodeToJS = function(cieloCode, hOptions = {}) {
  var coffeeCode, err, jsCode, jsPostCode, jsPreCode, lNeededSymbols, postmapper, premapper, source;
  // --- cielo => js
  //     Valid Options:
  //        premapper:  SmartInput or subclass
  //        postmapper: SmartInput or subclass
  //        source: name of source file
  //        hCoffeeOptions  - passed to CoffeeScript.parse()
  //           default:
  //              bare: true
  //              header: false
  debug("enter cieloCodeToJS()");
  debug("cieloCode", cieloCode);
  assert(indentLevel(cieloCode) === 0, "cieloCodeToJS(): has indentation");
  premapper = hOptions.premapper || SmartInput;
  postmapper = hOptions.postmapper; // may be undef
  source = hOptions.source;
  // --- Even if no premapper is defined, this will handle
  //     continuation lines, HEREDOCs, etc.
  coffeeCode = doMap(premapper, cieloCode, source);
  if (coffeeCode !== cieloCode) {
    debug("coffeeCode", coffeeCode);
  }
  // --- symbols will always be unique
  lNeededSymbols = getNeededSymbols(coffeeCode);
  debug(`${lNeededSymbols.length} needed symbols: ${lNeededSymbols}`);
  try {
    if (convertingCielo) {
      jsPreCode = coffeeCodeToJS(coffeeCode, hOptions.hCoffeeOptions);
      debug("jsPreCode", jsPreCode);
    } else {
      jsPreCode = cieloCode;
    }
    if (postmapper) {
      jsPostCode = doMap(postmapper, jsPreCode, source);
      if (jsPostCode !== jsPreCode) {
        debug("post mapped", jsPostCode);
      }
    } else {
      jsPostCode = jsPreCode;
    }
    // --- A separator can be specified as 3rd arg
    //     But by default, the variable convertCielo is checked
    //        and the appropriate separator is used
    jsCode = addImports(jsPostCode, lNeededSymbols);
    if (jsCode !== jsPostCode) {
      debug("with imports", jsCode);
    }
  } catch (error) {
    err = error;
    croak(err, "Original Code", cieloCode);
  }
  debug("return from cieloCodeToJS()", jsCode);
  return jsCode;
};

// ---------------------------------------------------------------------------
export var addImports = function(jsCode, lNeededSymbols, sep = undef) {
  var lImportStmts;
  if (sep == null) {
    sep = convertingCielo ? ";\n" : "\n";
  }
  // --- These import statements don't include a trailing ';'
  lImportStmts = buildImportList(lNeededSymbols);
  if (lImportStmts.length === 0) {
    return jsCode;
  }
  return lImportStmts.join(sep) + sep + jsCode;
};

// ---------------------------------------------------------------------------
export var cieloFileToJS = function(srcPath, destPath = undef, hOptions = {}) {
  var cieloCode, dumpfile, i, jsCode, lNeeded, len, n, sym, word;
  if (destPath == null) {
    destPath = withExt(srcPath, '.js', {
      removeLeadingUnderScore: true
    });
  }
  if (hOptions.force || !newerDestFileExists(srcPath, destPath)) {
    cieloCode = slurp(srcPath);
    if (hOptions.saveAST) {
      dumpfile = withExt(srcPath, '.ast');
      lNeeded = getNeededSymbols(cieloCode, {dumpfile});
      if ((lNeeded === undef) || (lNeeded.length === 0)) {
        debug(`NO NEEDED SYMBOLS in ${shortenPath(destPath)}:`);
      } else {
        n = lNeeded.length;
        word = n === 1 ? 'SYMBOL' : 'SYMBOLS';
        debug(`${n} NEEDED ${word} in ${shortenPath(destPath)}:`);
        for (i = 0, len = lNeeded.length; i < len; i++) {
          sym = lNeeded[i];
          debug(`   - ${sym}`);
        }
      }
    }
    jsCode = cieloCodeToJS(cieloCode, hOptions);
    barf(destPath, jsCode);
  }
};
