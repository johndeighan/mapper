// Generated by CoffeeScript 2.5.1
// convert_utils.coffee
var hExtToEnvVar;

import {
  strict as assert
} from 'assert';

import {
  dirname,
  resolve,
  parse as parse_fname
} from 'path';

import CoffeeScript from 'coffeescript';

import marked from 'marked';

import sass from 'sass';

import yaml from 'js-yaml';

import {
  log,
  undef,
  pass,
  croak,
  isEmpty,
  nonEmpty,
  isComment,
  isString,
  unitTesting,
  escapeStr,
  firstLine,
  arrayToString
} from '@jdeighan/coffee-utils';

import {
  splitLine,
  indented,
  undented,
  tabify,
  untabify,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  svelteHtmlEsc
} from '@jdeighan/coffee-utils/svelte';

import {
  StringInput,
  CoffeeMapper,
  CoffeePostMapper,
  SassMapper
} from '@jdeighan/string-input';

import {
  getNeededImports,
  getNeededSymbols,
  mergeNeededSymbols,
  buildImportList
} from '@jdeighan/string-input/code';

// ---------------------------------------------------------------------------
//   isTAML - is the string valid TAML?
export var isTAML = function(input) {
  return firstLine(input).indexOf('---') === 0;
};

// ---------------------------------------------------------------------------
//   taml - convert valid TAML string to a JavaScript value
export var taml = function(str) {
  var header;
  debug(`enter taml('${escapeStr(str)}')`);
  if (str == null) {
    debug("return undef - str is not defined");
    return undef;
  }
  assert(isString(str), "taml(): not a string");
  header = firstLine(str);
  assert(header.indexOf('---') === 0, "taml(): not a TAML string");
  return yaml.load(untabify(str, 1));
};

// ---------------------------------------------------------------------------
//   tamlStringify - convert a data structure into a valid TAML string
export var tamlStringify = function(obj) {
  var str;
  if (obj == null) {
    return 'undef';
  }
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: false,
    lineWidth: -1
  });
  return "---\n" + tabify(str);
};

// ---------------------------------------------------------------------------
//   slurpTAML - read TAML from a file
export var slurpTAML = function(filepath) {
  var contents;
  contents = slurp(filepath);
  return taml(contents);
};

// ---------------------------------------------------------------------------
export var brewExpr = function(expr, force = false) {
  var err, newexpr, pos;
  assert(indentLevel(expr) === 0, "brewCoffee(): has indentation");
  if (unitTesting && !force) {
    return expr;
  }
  try {
    newexpr = CoffeeScript.compile(expr, {
      bare: true
    }).trim();
    // --- Remove any trailing semicolon
    pos = newexpr.length - 1;
    if (newexpr.substr(pos, 1) === ';') {
      newexpr = newexpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, expr, "brewExpr");
  }
  return newexpr;
};

// ---------------------------------------------------------------------------
export var brewCoffee = function(...lBlocks) {
  var blk, err, hAllNeeded, hNeeded, i, j, k, lResult, len, len1, newblk, script;
  debug("enter brewCoffee()");
  for (i = j = 0, len = lBlocks.length; j < len; i = ++j) {
    blk = lBlocks[i];
    debug(blk, `BLOCK ${i}:`);
  }
  lResult = [];
  hAllNeeded = {}; // { <lib>: [ <symbol>, ...], ...}
  for (k = 0, len1 = lBlocks.length; k < len1; k++) {
    blk = lBlocks[k];
    newblk = preProcessCoffee(blk);
    debug(newblk, "NEW BLOCK:");
    // --- returns {<lib>: [<symbol>,... ],... }
    hNeeded = getNeededSymbols(newblk);
    mergeNeededSymbols(hAllNeeded, hNeeded);
    if (unitTesting) {
      lResult.push(newblk);
    } else {
      try {
        script = CoffeeScript.compile(newblk, {
          bare: true
        });
        // --- Unfortunately, the CoffeeScript compiler
        //     adds a semicolon after `$:` or `$:{`  is compiled
        script = script.replace(/\$\:\;/g, '$:');
        script = script.replace(/\$\:\{\;/g, '$:{');
        debug(script, "BREWED SCRIPT:");
        lResult.push(postProcessCoffee(script));
      } catch (error) {
        err = error;
        log(newblk, "Mapped Text:");
        croak(err, blk, "Original Text");
      }
    }
  }
  lResult.push(buildImportList(hAllNeeded));
  return lResult;
};

// ---------------------------------------------------------------------------
export var postProcessCoffee = function(code) {
  var oInput;
  // --- variable declaration immediately following one of:
  //        $:{
  //        $:
  //     should be moved above this line
  oInput = new CoffeePostMapper(code);
  return oInput.getAllText();
};

// ---------------------------------------------------------------------------
export var preProcessCoffee = function(code, addImports = false) {
  var lImports, newcode, oInput;
  assert(indentLevel(code) === 0, "preProcessCoffee(): has indentation");
  oInput = new CoffeeMapper(code);
  newcode = oInput.getAllText();
  if (!addImports) {
    return newcode;
  }
  debug("call getNeededImports()");
  lImports = getNeededImports(newcode);
  if (isEmpty(lImports)) {
    return newcode;
  } else {
    return `${arrayToString(lImports)}\n${newcode}`;
  }
};

// ---------------------------------------------------------------------------
export var markdownify = function(text) {
  var html, result;
  debug(`enter markdownify('${escapeStr(text)}')`);
  if (unitTesting) {
    debug("return original text");
    return text;
  }
  text = undented(text);
  html = marked(text, {
    grm: true,
    headerIds: false
  });
  debug(`marked returned '${escapeStr(html)}'`);
  result = svelteHtmlEsc(html);
  debug(`return '${escapeStr(result)}'`);
  return result;
};

// ---------------------------------------------------------------------------
export var sassify = function(text) {
  var newtext, oInput, result;
  oInput = new SassMapper(text);
  newtext = oInput.getAllText();
  if (unitTesting) {
    return newtext;
  }
  result = sass.renderSync({
    data: newtext,
    indentedSyntax: true,
    indentType: "tab"
  });
  return result.css.toString();
};

// ---------------------------------------------------------------------------
hExtToEnvVar = {
  '.md': 'dir_markdown',
  '.taml': 'dir_data',
  '.txt': 'dir_data'
};

// ---------------------------------------------------------------------------
export var getFileContents = function(fname, convert = false) {
  var base, contents, dir, envvar, ext, fullpath, root;
  debug(`enter getFileContents('${fname}')`);
  if (unitTesting) {
    debug("return - unit testing");
    return `Contents of ${fname}`;
  }
  ({root, dir, base, ext} = parse_fname(fname.trim()));
  assert(!root && !dir, "getFileContents():" + ` root='${root}', dir='${dir}'` + " - full path not allowed");
  envvar = hExtToEnvVar[ext];
  debug(`envvar = '${envvar}'`);
  assert(envvar, `getFileContents() doesn't work for ext '${ext}'`);
  dir = process.env[envvar];
  debug(`dir = '${dir}'`);
  assert(dir, `env var '${envvar}' not set for file extension '${ext}'`);
  fullpath = pathTo(base, dir); // guarantees that file exists
  debug(`fullpath = '${fullpath}'`);
  assert(fullpath, `getFileContents(): Can't find file ${fname}`);
  contents = slurp(fullpath);
  if (!convert) {
    debug("return - not converting");
    return contents;
  }
  switch (ext) {
    case '.md':
      return markdownify(contents);
    case '.taml':
      return taml(contents);
    case '.txt':
      return contents;
    default:
      return croak(`getFileContents(): No handler for ext '${ext}'`);
  }
};
