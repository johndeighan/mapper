// Generated by CoffeeScript 2.7.0
  // CieloMapper.coffee
import {
  undef,
  assert,
  croak,
  OL,
  replaceVars,
  isString,
  isEmpty,
  nonEmpty,
  isArray,
  isHash,
  isBoolean
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  undented,
  splitLine,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Mapper
} from '@jdeighan/mapper';

import {
  lineToParts,
  mapHereDoc
} from '@jdeighan/mapper/heredoc';

// ===========================================================================
export var CieloMapper = class CieloMapper extends Mapper {
  // - removes blank lines (but can be overridden)
  // - does NOT remove comments (but can be overridden)
  // - joins continuation lines
  // - handles HEREDOCs
  // - handles #define <name> <value> and __<name>__ substitution
  constructor(content, source) {
    debug(`enter CieloMapper(source='${source}')`, content);
    super(content, source);
    this.hVars = {
      FILE: this.filename,
      DIR: this.hSourceInfo.dir,
      LINE: 0
    };
    // --- This should only be used in mapLine(), where
    //     it keeps track of the level we're at, to be passed
    //     to handleEmptyLine() since the empty line itself
    //     is always at level 0
    this.curLevel = 0;
    debug("return from CieloMapper()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc) {
    super.incLineNum(inc); // adjusts property @lineNum
    this.hVars.LINE = this.lineNum;
  }

  // ..........................................................
  // --- designed to override with a mapping method
  //     NOTE: line does not include the indentation
  mapLine(line, level) {
    var argstr, cmd, hResult, handled, lContLines, lParts, lResult, newline, orgLineNum, result;
    debug(`enter CieloMapper.mapLine(${OL(line)}, ${level})`);
    assert(line != null, "mapLine(): line is undef");
    assert(isString(line), `mapLine(): ${OL(line)} not a string`);
    if (isEmpty(line)) {
      result = this.handleEmptyLine(this.curLevel);
      debug("return from CieloMapper.mapLine() - empty line", result);
      return result;
    }
    if (this.isComment(line)) {
      result = this.handleComment(line, level);
      debug("return from CieloMapper.mapLine() - comment", result);
      return result;
    }
    lParts = this.isCommand(line);
    if (lParts) {
      debug("COMMAND", lParts);
      [cmd, argstr] = lParts;
      lResult = this.handleCommand(cmd, argstr, level);
      debug(`handleCommand() returned ${OL(lResult)}`);
      assert(isArray(lResult), "handleCommand() failed to return array");
      [handled, result] = lResult;
      assert(isBoolean(handled), "1st arg in handleCommand() result isn't boolean");
      if (handled) {
        debug("return from CieloMapper.mapLine()", result);
        return result;
      } else {
        croak(`Unknown command: '${line}'`);
      }
    }
    // --- Merge in any continuation lines
    debug("check for continuation lines");
    lContLines = this.getContLines(level);
    if (isEmpty(lContLines)) {
      debug("no continuation lines found");
    } else {
      debug(`${lContLines.length} continuation lines found`);
      line = this.joinContLines(line, lContLines);
      debug(`line becomes ${OL(line)}`);
    }
    debug("hVars", this.hVars);
    debug('line', line);
    newline = replaceVars(line, this.hVars);
    if (newline !== line) {
      line = newline;
      debug(`line becomes ${OL(line)}`);
    }
    orgLineNum = this.lineNum;
    this.curLevel = level;
    // --- handle HEREDOCs
    debug("check for HEREDOC");
    if (line.indexOf('<<<') > -1) {
      hResult = this.handleHereDoc(line, level);
      line = hResult.line;
      debug(`line becomes ${OL(line)}`);
    }
    debug("mapping string");
    result = this.mapString(line, level);
    debug(`return ${OL(result)} from CieloMapper.mapLine()`);
    return result;
  }

  // ..........................................................
  handleEmptyLine(level) {
    debug("in CieloMapper.handleEmptyLine()");
    // --- remove blank lines by default
    //     return '' to retain empty lines
    return undef;
  }

  // ..........................................................
  isComment(line, level) {
    var _, ch, hashes, lMatches;
    lMatches = line.match(/^(\#+)(.|$)/); // one or more # characters
    // following character, if any
    if (lMatches) {
      [_, hashes, ch] = lMatches;
      return (hashes.length > 1) || (ch === ' ' || ch === '\t' || ch === '');
    } else {
      return false;
    }
  }

  // ..........................................................
  handleComment(line, level) {
    debug("in CieloMapper.handleComment()");
    return line; // keep comments by default
  }

  
    // ..........................................................
  isCommand(line, level) {
    var _, argstr, cmd, lMatches, lResult;
    debug("enter CieloMapper.isCommand()");
    if (lMatches = line.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, cmd, argstr] = lMatches;
      lResult = [cmd, argstr];
      debug("return from CieloMapper.isCommand()", lResult);
      return lResult;
    } else {
      // --- not a command
      debug("return undef from CieloMapper.isCommand()");
      return undef;
    }
  }

  // ..........................................................
  // --- handleCommand must return a pair:
  //        [handled:boolean, result:any]
  handleCommand(cmd, argstr, level) {
    var _, lMatches, name, prefix, result, tail;
    debug(`enter CieloMapper.handleCommand ${cmd} '${argstr}', ${level}`);
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, prefix, name, tail] = lMatches;
          tail = tail.trim();
          if (prefix) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setVariable(name, tail);
          }
        }
        result = [true, undef];
        break;
      default:
        result = [false, undef];
    }
    debug("return from CieloMapper.handleCommand()", result);
    return result;
  }

  // ..........................................................
  setVariable(name, value) {
    // --- value can be a non-string
    //     if so, when replacement occurs, it will be JSON stringified
    debug(`enter setVariable('${name}')`, value);
    assert(isString(name), "name is not a string");
    if (isString(value)) {
      assert((name !== 'DIR' && name !== 'FILE' && name !== 'LINE' && name !== 'END'), `Bad var name '${name}'`);
    }
    this.hVars[name] = value;
    debug("return from setVariable()");
  }

  // ..........................................................
  handleHereDoc(line, level) {
    var hResult, lLines, lNewParts, lObjects, lParts, part;
    // --- Indentation has been removed from line
    // --- Find each '<<<' and replace with result of replaceHereDoc()
    assert(isString(line), "handleHereDoc(): not a string");
    debug(`enter handleHereDoc(${OL(line)})`);
    lParts = lineToParts(line);
    lObjects = [];
    lNewParts = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = lParts.length; i < len; i++) {
        part = lParts[i];
        if (part === '<<<') {
          lLines = this.getHereDocLines(level + 1);
          hResult = this.replaceHereDoc(arrayToBlock(lLines));
          lObjects.push(hResult.obj);
          results.push(hResult.str);
        } else {
          results.push(part); // keep as is
        }
      }
      return results;
    }).call(this);
    hResult = {
      line: lNewParts.join(''),
      lParts: lParts,
      lObjects: lObjects
    };
    debug("return from handleHereDoc", hResult);
    return hResult;
  }

  // ..........................................................
  replaceHereDoc(block) {
    var hResult;
    // --- A method you can override
    hResult = mapHereDoc(block);
    assert(isHash(hResult), "replaceHereDoc(): hResult not a hash");
    return hResult;
  }

  // ..........................................................
  getHereDocLines(atLevel) {
    var lLines, line, line2;
    // --- Get all lines until addHereDocLine() returns undef
    //     atLevel will be one greater than the indent
    //        of the line containing <<<

    // --- NOTE: splitLine() removes trailing whitespace
    debug("enter CieloMapper.getHereDocLines()");
    lLines = [];
    while (((line = this.fetch()) != null) && ((line2 = this.hereDocLine(undented(line, atLevel))) != null)) {
      assert(indentLevel(line) >= atLevel, "invalid indentation in HEREDOC section");
      lLines.push(line2);
    }
    assert(isArray(lLines), "getHereDocLines(): retval not an array");
    debug("return from CieloMapper.getHereDocLines()", lLines);
    return lLines;
  }

  // ..........................................................
  hereDocLine(line) {
    if (isEmpty(line)) {
      return undef; // end the HEREDOC section
    } else if (line === '.') {
      return ''; // interpret '.' as blank line
    } else {
      return line;
    }
  }

  // ..........................................................
  getContLines(curlevel) {
    var lLines, nextLevel, nextLine, nextStr;
    lLines = [];
    while (((nextLine = this.fetch(true)) != null) && (nonEmpty(nextLine)) && ([nextLevel, nextStr] = splitLine(nextLine)) && (nextLevel >= curlevel + 2)) {
      lLines.push(nextStr);
    }
    if (nextLine != null) {
      // --- we fetched a line we didn't want
      this.unfetch(nextLine);
    }
    return lLines;
  }

  // ..........................................................
  joinContLines(line, lContLines) {
    var contLine, i, lMatches, len, n;
    for (i = 0, len = lContLines.length; i < len; i++) {
      contLine = lContLines[i];
      if (lMatches = line.match(/\s*\\$/)) {
        n = lMatches[0].length;
        line = line.substr(0, line.length - n);
      }
      line += ' ' + contLine;
    }
    return line;
  }

  // ..........................................................
  // ..........................................................
  mapString(line, level) {
    // --- NOTE: line has indentation removed
    //     when overriding, may return anything
    //     return undef to generate nothing
    assert(isString(line), `default mapString(): ${OL(line)} is not a string`);
    return line;
  }

};
