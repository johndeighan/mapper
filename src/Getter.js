// Generated by CoffeeScript 2.7.0
  // Getter.coffee
import {
  LOG,
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  dbg,
  dbgEnter,
  dbgReturn,
  dbgYield,
  dbgResume
} from '@jdeighan/base-utils/debug';

import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  notdefined,
  escapeStr,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  arrayToBlock,
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  Node
} from '@jdeighan/mapper/node';

import {
  Fetcher
} from '@jdeighan/mapper/fetcher';

// ---------------------------------------------------------------------------
//   class Getter
//      - get(), peek(), eof(), skip() for mapped data
export var Getter = class Getter extends Fetcher {
  constructor(source = undef, collection = undef) {
    super(source, collection);
    this.hConsts = {}; // support variable replacement
  }

  
    // ..........................................................
  setConst(name, value) {
    assert((name === 'LINE') || (this.hConsts[name] === undef), `cannot set constant ${name} twice`);
    this.hConsts[name] = value;
  }

  // ..........................................................
  getConst(name) {
    return this.hConsts[name];
  }

  // ..........................................................
  //        Mapped Data
  // ..........................................................
  get() {
    var extStr, hExt, hNode, level, str;
    dbgEnter("Getter.get");
    while (defined(hNode = this.fetch())) {
      dbg("GOT", hNode);
      assert(hNode instanceof Node, `hNode is ${OL(hNode)}`);
      level = hNode.level;
      // --- check for extension lines (only if str non-empty)
      str = hNode.str;
      if (nonEmpty(str)) {
        while (defined(hExt = this.fetch()) && assert(hExt instanceof Node, `hExt = ${OL(hExt)}`) && (hExt.level >= level + 2)) {
          extStr = hExt.str;
          str += this.extSep(str, extStr) + extStr;
        }
        if (defined(hExt)) {
          this.unfetch(hExt);
        }
        hNode.str = str;
      }
      if (hNode.notMapped()) {
        hNode.uobj = this.mapAnyNode(hNode);
      }
      if (defined(hNode.uobj)) {
        dbg("newly mapped");
        dbgReturn("Getter.get", hNode);
        return hNode;
      }
    }
    dbg("EOF");
    dbgReturn("Getter.get", undef);
    return undef;
  }

  // ..........................................................
  extSep(str, nextStr) {
    return ' ';
  }

  // ..........................................................
  skip() {
    dbgEnter('Getter.skip');
    this.get();
    dbgReturn('Getter.skip');
  }

  // ..........................................................
  peek() {
    var hNode;
    dbgEnter('Getter.peek');
    hNode = this.get();
    if (hNode === undef) {
      dbgReturn("Getter.peek", undef);
      return undef;
    } else {
      this.unfetch(hNode);
      dbgReturn("Getter.peek", hNode);
      return hNode;
    }
  }

  // ..........................................................
  eof() {
    var result;
    dbgEnter("Getter.eof");
    result = this.peek() === undef;
    dbgReturn("Getter.eof", result);
    return result;
  }

  // ..........................................................
  // --- return of undef doesn't mean EOF, it means skip this item
  //     sets key 'uobj' to a defined value if not returning undef
  //     sets key 'type' if a special type
  mapAnyNode(hNode) {
    var level, newstr, str, type, uobj;
    dbgEnter("Getter.mapAnyNode", hNode);
    assert(defined(hNode), "hNode is undef");
    type = this.getItemType(hNode);
    if (defined(type)) {
      dbg(`item type is ${OL(type)}`);
      assert(isString(type) && nonEmpty(type), `bad type: ${OL(type)}`);
      hNode.type = type;
      uobj = this.mapSpecial(type, hNode);
      dbg(`mapped ${type}`, uobj);
    } else {
      dbg("no special type");
      ({str, level} = hNode);
      assert(defined(str), "str is undef");
      assert(str !== '__END__', "__END__ encountered");
      newstr = this.replaceConsts(str, this.hConsts);
      if (newstr !== str) {
        dbg(`${OL(str)} => ${OL(newstr)}`);
        hNode.str = newstr;
      }
      uobj = this.mapNonSpecial(hNode);
      dbg("mapped non-special", uobj);
    }
    dbgReturn("Getter.mapAnyNode", uobj);
    return uobj;
  }

  // ..........................................................
  mapSpecial(type, hNode) {
    // --- default - ignore any special item types
    //     - but by default, there aren't any!
    return undef;
  }

  // ..........................................................
  mapNonSpecial(hNode) {
    // --- TreeMapper overrides this
    return this.mapNode(hNode);
  }

  // ..........................................................
  // --- designed to override
  //     only non-special nodes
  mapNode(hNode) {
    var level, str;
    // --- by default, just returns str key indented
    ({str, level} = hNode);
    return indented(str, level, this.oneIndent);
  }

  // ..........................................................
  replaceConsts(str, hVars = {}) {
    var replacerFunc;
    assert(isHash(hVars), "hVars is not a hash");
    replacerFunc = (match, prefix, name) => {
      var value;
      if (prefix) {
        return process.env[name];
      } else {
        value = hVars[name];
        if (defined(value)) {
          if (isString(value)) {
            return value;
          } else {
            return JSON.stringify(value);
          }
        } else {
          return `__${name}__`;
        }
      }
    };
    return str.replace(/__(env\.)?([A-Za-z_][A-Za-z0-9_]*)__/g, replacerFunc);
  }

  // ..........................................................
  getItemType(hNode) {
    // --- returns name of item type
    dbg("in Getter.getItemType()");
    return undef; // default: no special item types
  }

  
    // ..........................................................
  // --- GENERATOR
  * allMapped() {
    var hNode;
    dbgEnter("Getter.allMapped");
    // --- NOTE: @get will skip items that are mapped to undef
    //           and only returns undef when the input is exhausted
    while (defined(hNode = this.get())) {
      dbg("GOT", hNode);
      dbgYield('Getter.allMapped', hNode);
      yield hNode;
      dbgResume('Getter.allMapped');
    }
    dbgReturn("Getter.allMapped");
  }

  // ..........................................................
  // --- GENERATOR
  * allMappedUntil(func, endLineOption) {
    var hNode;
    dbgEnter("Getter.allMappedUntil");
    assert(isFunction(func), "Arg 1 not a function");
    assert((endLineOption === 'keepEndLine') || (endLineOption === 'discardEndLine'), `bad end line option: ${OL(endLineOption)}`);
    // --- NOTE: @get will skip items that are mapped to undef
    //           and only returns undef when the input is exhausted
    while (defined(hNode = this.get()) && !func(hNode)) {
      dbg("GOT", hNode);
      dbgYield("Getter.allMappedUntil", hNode);
      yield hNode;
      dbgResume("Getter.allMappedUntil");
    }
    if (defined(hNode) && (endLineOption === 'keepEndLine')) {
      this.unfetch(hNode);
    }
    dbgReturn("Getter.allMappedUntil");
  }

  // ..........................................................
  getAll() {
    var lNodes;
    dbgEnter("Getter.getAll");
    lNodes = Array.from(this.allMapped());
    dbgReturn("Getter.getAll", lNodes);
    return lNodes;
  }

  // ..........................................................
  getUntil(func, endLineOption) {
    var lNodes;
    dbgEnter("Getter.getUntil");
    assert(isFunction(func), "not a function");
    assert((endLineOption === 'keepEndLine') || (endLineOption === 'discardEndLine'), `bad end line option: ${OL(endLineOption)}`);
    lNodes = Array.from(this.allMappedUntil(func, endLineOption));
    dbgReturn("Getter.getUntil", lNodes);
    return lNodes;
  }

  // ..........................................................
  // --- Rarely used - requires that uobj's are strings
  //     TreeMapper overrides this, and is more commonly used
  getBlock(hOptions = {}) {
    var block, endStr, hNode, i, lStrings, ref, result;
    // --- Valid options: logNodes
    dbgEnter("Getter.getBlock");
    lStrings = [];
    i = 0;
    ref = this.allMapped();
    for (hNode of ref) {
      if (hOptions.logNodes) {
        LOG(`hNode[${i}]`, hNode);
      } else {
        dbg(`hNode[${i}]`, hNode);
      }
      i += 1;
      // --- default visit() & visitSpecial() return uobj
      if (hNode.type === undef) {
        result = this.visit(hNode);
      } else {
        result = this.visitSpecial(hNode.type, hNode);
      }
      if (defined(result)) {
        assert(isString(result), "not a string");
        lStrings.push(result);
      }
    }
    dbg('lStrings', lStrings);
    if (defined(endStr = this.endBlock())) {
      dbg('endStr', endStr);
      lStrings.push(endStr);
    }
    if (hOptions.logNodes) {
      LOG('logNodes', lStrings);
    }
    block = this.finalizeBlock(arrayToBlock(lStrings));
    dbgReturn("Getter.getBlock", block);
    return block;
  }

  // ..........................................................
  visit(hNode) {
    var uobj;
    dbgEnter("Getter.visit", hNode);
    ({uobj} = hNode);
    if (isString(uobj)) {
      dbgReturn("Getter.visit", uobj);
      return uobj;
    } else if (defined(uobj)) {
      return croak(`uobj ${OL(uobj)} should be a string`);
    } else {
      dbgReturn("Getter.visit", undef);
      return undef;
    }
  }

  // ..........................................................
  visitSpecial(type, hNode) {
    var uobj;
    dbgEnter("Getter.visitSpecial", type, hNode);
    ({uobj} = hNode);
    if (isString(uobj)) {
      dbgReturn("Getter.visitSpecial", uobj);
      return uobj;
    } else if (defined(uobj)) {
      return croak(`uobj ${OL(uobj)} should be a string`);
    } else {
      dbgReturn("Getter.visitSpecial", undef);
      return undef;
    }
  }

  // ..........................................................
  endBlock() {
    // --- currently, only used in markdown processing
    return undef;
  }

  // ..........................................................
  finalizeBlock(block) {
    return block;
  }

};
