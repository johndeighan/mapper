// Generated by CoffeeScript 2.7.0
  // Getter.coffee
import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  notdefined,
  escapeStr,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock,
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Fetcher
} from '@jdeighan/mapper/fetcher';

// ---------------------------------------------------------------------------
//   class Getter
//      - get(), peek(), eof(), skip() for mapped data
export var Getter = class Getter extends Fetcher {
  constructor(source = undef, collection = undef, hOptions = {}) {
    super(source, collection, hOptions);
    this.hConsts = {}; // support variable replacement
    
    // --- support peek(), etc.
    this.lCache = [];
  }

  // ..........................................................
  setConst(name, value) {
    assert((name === 'LINE') || (this.hConsts[name] === undef), `cannot set constant ${name} twice`);
    this.hConsts[name] = value;
  }

  // ..........................................................
  getConst(name) {
    return this.hConsts[name];
  }

  // ..........................................................
  //    Cache Management
  // ..........................................................
  fetchFromCache() {
    var hLine;
    assert(nonEmpty(this.lCache), "empty cache");
    hLine = this.lCache.shift();
    assert(defined(hLine), "undef item found in lCache");
    return hLine;
  }

  // ..........................................................
  getFromCache() {
    var hLine, uobj;
    while (nonEmpty(this.lCache)) {
      hLine = this.fetchFromCache();
      if (defined(hLine.uobj)) {
        return hLine;
      } else {
        uobj = hLine.uobj = this.mapItem(hLine);
        if (defined(uobj)) {
          return hLine;
        }
      }
    }
    return undef;
  }

  // ..........................................................
  //        We override fetch(), unfetch()
  // ..........................................................
  fetch() {
    if (nonEmpty(this.lCache)) {
      return this.fetchFromCache();
    }
    return super.fetch();
  }

  // ..........................................................
  unfetch(hLine) {
    // --- I think these are wrong, so I'm commenting them out for now
    //		if isEmpty(@lCache)
    //			return super(hLine)
    assert(defined(hLine), "attempt to put undef in lCache");
    this.lCache.unshift(hLine);
  }

  // ..........................................................
  //        Mapped Data
  // --- add keys:
  //        type   - if a special type
  //        uobj
  // ..........................................................
  get() {
    var hLine, uobj;
    debug("enter Getter.get()");
    // --- return anything in @lCache
    //     NOTE: getFromCache() may return undef if all items
    //           in cache have not been mapped, and all of them
    //           map to undef
    debug('lCache', this.lCache);
    if (defined(hLine = this.getFromCache())) {
      // --- NOTE: return value from getFromCache()
      //           should always have a uobj key
      assert(defined(hLine.uobj), "getFromCache() but no uobj");
      debug("return from Getter.get() - cached hLine", hLine);
      return hLine;
    }
    debug("no cached hLine");
    hLine = this.fetch();
    debug("fetch() returned", hLine);
    if (hLine === undef) {
      debug("return from Getter.get() - at EOF", undef);
      return undef;
    }
    uobj = hLine.uobj = this.mapItem(hLine);
    if (uobj === undef) {
      hLine = this.get(); // recursive call
    }
    debug("return from Getter.get()", hLine);
    return hLine;
  }

  // ..........................................................
  skip() {
    debug('enter Getter.skip():');
    this.get();
    debug('return from Getter.skip()');
  }

  // ..........................................................
  eof() {
    var hLine;
    debug("enter Getter.eof()");
    if (nonEmpty(this.lCache)) {
      debug("return from Getter.eof() - cache not empty", false);
      return false;
    }
    hLine = this.fetch();
    if (hLine === undef) {
      debug("return from Getter.eof()", true);
      return true;
    } else {
      this.unfetch(hLine);
      debug("return from Getter.eof()", false);
      return false;
    }
  }

  // ..........................................................
  peek() {
    var hLine, uobj;
    debug('enter Getter.peek()');
    // --- Any item in lCache that has uobj == undef has not
    //     been mapped. lCache may contain such items, but if
    //     they map to undef, they should be skipped
    while (nonEmpty(this.lCache)) {
      hLine = this.lCache[0];
      assert(defined(hLine), "hLine (from cache) is undef");
      if (defined(hLine.uobj)) {
        debug("return cached item from Getter.peek()", hLine);
        return hLine;
      } else {
        uobj = hLine.uobj = this.mapItem(hLine);
        if (defined(uobj)) {
          debug("return cached item from Getter.peek()", hLine);
          return hLine;
        } else {
          this.lCache.shift(); // and continue loop
        }
      }
    }
    debug("no lookahead");
    hLine = this.fetch();
    if (hLine === undef) {
      debug("return undef from Getter.peek() - at EOF");
      return undef;
    }
    debug("fetch() returned", hLine);
    // --- @lCache is currently empty
    uobj = hLine.uobj = this.mapItem(hLine);
    // --- @lCache might be non-empty now!!!

    // --- if mapItem() returns undef, skip that item
    if (uobj === undef) {
      debug("mapItem() returned undef - recursive call");
      hLine = this.peek(); // recursive call
      debug("return from Getter.peek()", hLine);
      return hLine;
    }
    debug("add to cache", hLine);
    this.lCache.unshift(hLine);
    debug("return from Getter.peek()", hLine);
    return hLine;
  }

  // ..........................................................
  // --- return of undef doesn't mean EOF, it means skip this item
  //     sets key 'uobj' to a defined value if not returning undef
  //     sets key 'type' if a special type
  mapItem(hLine) {
    var line, newline, newstr, prefix, str, type, uobj;
    debug("enter Getter.mapItem()", hLine);
    assert(defined(hLine), "hLine is undef");
    if (defined(type = this.getItemType(hLine))) {
      debug(`item type is ${type}`);
      assert(isString(type) && nonEmpty(type), `bad type: ${OL(type)}`);
      hLine.type = type;
      debug("call handleItemType()");
      uobj = this.handleItemType(type, hLine);
      debug("from handleItemType()", uobj);
    } else {
      debug("no special type");
      ({line, str, prefix} = hLine);
      if (isString(line)) {
        assert(isString(str), `missing 'str' key in ${OL(line)}`);
        assert(nonEmpty(str), "str is empty");
        assert(line !== '__END__', "__END__ encountered");
        newstr = this.replaceConsts(str, this.hConsts);
        if (newstr !== str) {
          newline = `${prefix}${newstr}`;
          debug(`=> '${newline}'`);
          hLine.str = newstr;
          hLine.line = newline;
        }
      }
      debug("call map()");
      uobj = this.map(hLine);
      debug("from map()", uobj);
    }
    if (uobj === undef) {
      debug("return from Getter.mapItem()", undef);
      return undef;
    }
    debug("return from Getter.mapItem()", uobj);
    return uobj;
  }

  // ..........................................................
  replaceConsts(str, hVars = {}) {
    var replacerFunc;
    assert(isHash(hVars), "hVars is not a hash");
    replacerFunc = (match, prefix, name) => {
      var value;
      if (prefix) {
        return process.env[name];
      } else {
        value = hVars[name];
        if (defined(value)) {
          if (isString(value)) {
            return value;
          } else {
            return JSON.stringify(value);
          }
        } else {
          return `__${name}__`;
        }
      }
    };
    return str.replace(/__(env\.)?([A-Za-z_][A-Za-z0-9_]*)__/g, replacerFunc);
  }

  // ..........................................................
  getItemType(hLine) {
    // --- returns name of item type
    return undef; // default: no special item types
  }

  
    // ..........................................................
  handleItemType(type, hLine) {
    return undef; // default - ignore any special item types
  }

  
    // ..........................................................
  // --- designed to override
  //     override may use fetch(), unfetch(), fetchBlock(), etc.
  //     should return a uobj (undef to ignore line)
  //     technically, hLine.line does not have to be a string,
  //        but it usually is
  map(hLine) {
    // --- returns a uobj or undef
    //     uobj will be passed to visit() and endVisit() in TreeWalker
    debug("enter Getter.map()", hLine);
    assert(defined(hLine), "hLine is undef");
    // --- by default, just returns line key
    debug("return from Getter.map()", hLine.line);
    return hLine.line;
  }

  // ..........................................................
  // --- a generator
  * allMapped() {
    var hLine;
    // --- NOTE: @get will skip items that are mapped to undef
    //           and only returns undef when the input is exhausted
    while (defined(hLine = this.get())) {
      yield hLine;
    }
  }

  // ..........................................................
  getAll() {
    var lLines;
    debug("enter Getter.getAll()");
    lLines = Array.from(this.allMapped());
    debug("return from Getter.getAll()", lLines);
    return lLines;
  }

  // ..........................................................
  getUntil(endLine) {
    var hLine, lLines;
    debug("enter Getter.getUntil()");
    lLines = [];
    while (defined(hLine = this.get()) && (hLine.line !== endLine)) {
      lLines.push(hLine.line);
    }
    debug("return from Getter.getUntil()", lLines);
    return lLines;
  }

  // ..........................................................
  getBlock(hOptions = {}) {
    var block, endStr, hLine, i, lStrings, ref, uobj;
    // --- Valid options: logLines
    debug("enter Getter.getBlock()");
    lStrings = [];
    i = 0;
    ref = this.allMapped();
    for (hLine of ref) {
      if (hOptions.logLines) {
        LOG(`hLine[${i}]`, hLine);
      } else {
        debug("hLine", hLine);
      }
      i += 1;
      uobj = hLine.uobj;
      assert(isString(uobj), "uobj not a string");
      lStrings.push(uobj);
    }
    debug('lStrings', lStrings);
    endStr = this.endBlock();
    if (defined(endStr = this.endBlock())) {
      debug('endStr', endStr);
      lStrings.push(endStr);
    }
    if (hOptions.logLines) {
      LOG('lStrings', lStrings);
    }
    block = this.finalizeBlock(arrayToBlock(lStrings));
    debug("return from Getter.getBlock()", block);
    return block;
  }

  // ..........................................................
  endBlock() {
    // --- currently, only used in markdown processing
    return undef;
  }

  // ..........................................................
  finalizeBlock(block) {
    return block;
  }

};
