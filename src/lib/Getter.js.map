{
  "version": 3,
  "file": "Getter.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\Getter.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "# Getter.coffee\r\n\r\nimport {\r\n\tundef, pass, OL, rtrim, defined, notdefined,\r\n\tescapeStr, isString, isNonEmptyString, isHash, isArray,\r\n\tisFunction, isIterable, isEmpty, nonEmpty, toBlock, toArray,\r\n\t} from '@jdeighan/base-utils'\r\nimport {assert, croak} from '@jdeighan/base-utils/exceptions'\r\nimport {LOG} from '@jdeighan/base-utils/log'\r\nimport {\r\n\tdbg, dbgEnter, dbgReturn,\r\n\tdbgYield, dbgResume,\r\n\t} from '@jdeighan/base-utils/debug'\r\n\r\nimport {Node} from '@jdeighan/mapper/node'\r\nimport {FetcherInc} from '@jdeighan/mapper/fetcherinc'\r\n\r\n# ---------------------------------------------------------------------------\r\n# 1. implement setConst() and getConst()\r\n# 2. override get() - only return nodes with defined uobj\r\n# 3. override procNode():\r\n#       - replace constants, including env vars\r\n#       - set type field\r\n#       - set field uobj by calling mapNode()\r\n\r\nexport class Getter extends FetcherInc\r\n\r\n\tconstructor: (hInput, options={}) ->\r\n\r\n\t\tsuper hInput, options\r\n\t\t@hConsts = {}   # support constant replacement\r\n\r\n\t# ..........................................................\r\n\r\n\tsetConst: (name, value) ->\r\n\r\n\t\tassert notdefined(@hConsts[name]), \"const #{name} already set\"\r\n\t\t@hConsts[name] = value\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tgetConst: (name) ->\r\n\r\n\t\treturn @hConsts[name]\r\n\r\n\t# ..........................................................\r\n\t#        Mapped Data\r\n\t# ..........................................................\r\n\r\n\tget: () ->\r\n\t\t# --- Return of undef indicates no more data\r\n\r\n\t\tdbgEnter \"Getter.get\"\r\n\r\n\t\t# --- NOTE: @allNodes() calls procNode() before returning hNode\r\n\t\t#           and we override that below\r\n\r\n\t\tfor hNode from @allNodes()\r\n\t\t\tdbg 'fetched hNode', hNode\r\n\t\t\tif defined(hNode.uobj)\r\n\t\t\t\tdbgReturn 'Getter.get', hNode\r\n\t\t\t\treturn hNode\r\n\r\n\t\tdbg \"EOF\"\r\n\t\tdbgReturn \"Getter.get\", undef\r\n\t\treturn undef\r\n\r\n\t# ..........................................................\r\n\r\n\tprocNode: (hNode) ->\r\n\t\t# --- overrides Fetcher.procNode()\r\n\t\t#     causing @fetch() to return a node\r\n\t\t#        with key 'uobj' set (possibly to undef)\r\n\t\t# --- Return value:\r\n\t\t#        falsy - discard this node\r\n\t\t#        truthy - keep this node\r\n\r\n\t\tdbgEnter 'Getter.procNode', hNode\r\n\t\tsuper hNode   # currently just asserts that hNode is defined\r\n\r\n\t\tif hNode.hasOwnProperty('uobj')\r\n\t\t\t# --- If it has already been mapped, nothing to do\r\n\t\t\t#     This can happen if the node has been peeked and mapped\r\n\t\t\tdbg \"node is already mapped to #{OL(hNode.uobj)}\"\r\n\t\telse\r\n\t\t\t{str} = hNode\r\n\t\t\tassert defined(str), \"str is undef\"\r\n\t\t\tassert isString(str), \"str is not a string\"\r\n\t\t\tassert notdefined(str.match(/^\\s/)), \"str has leading whitespace\"\r\n\t\t\tassert (str != '__END__'), \"__END__ encountered\"\r\n\t\t\tdbg 'str', str\r\n\r\n\t\t\t# --- Replace any constants\r\n\t\t\tnewstr = @replaceConsts(str, hNode)\r\n\t\t\tif (newstr != str)\r\n\t\t\t\tdbg \"#{OL(str)} => #{OL(newstr)}\"\r\n\t\t\t\thNode.str = newstr\r\n\r\n\t\t\ttype = @getItemType(hNode)\r\n\t\t\tif defined(type)\r\n\t\t\t\tassert isNonEmptyString(type), \"bad type: #{OL(type)}\"\r\n\t\t\t\thNode.type = type\r\n\t\t\telse\r\n\t\t\t\tdbg \"no special type\"\r\n\r\n\t\t\thNode.uobj = @mapNode(hNode)\r\n\t\t\tdbg \"mapped to uobj\", hNode.uobj\r\n\r\n\t\tresult = defined(hNode.uobj)\r\n\t\tdbgReturn 'Getter.procNode', result\r\n\t\treturn result\r\n\r\n\t# ..........................................................\r\n\t# --- designed to override\r\n\r\n\tgetItemType: (hNode) ->\r\n\t\t# --- returns name of item type\r\n\r\n\t\treturn undef   # default: no special item types\r\n\r\n\t# ..........................................................\r\n\t# --- designed to override\r\n\r\n\tmapNode: (hNode) ->\r\n\t\t# --- default:\r\n\t\t#        specials return undef\r\n\t\t#        non-specials return hNode.str\r\n\r\n\t\tif hNode.type\r\n\t\t\treturn undef\r\n\t\telse\r\n\t\t\treturn hNode.str\r\n\r\n\t# ..........................................................\r\n\r\n\treplaceConsts: (str, hNode) ->\r\n\r\n\t\treplacerFunc = (match, prefix, name) =>\r\n\t\t\t# --- match is the matched substring (see regexp below)\r\n\t\t\t#     prefix and name are captured groups\r\n\t\t\t#     If prefix is set, it's always 'env.'\r\n\t\t\t#     If name is set, it does NOT include the prefix\r\n\r\n\t\t\tif prefix\r\n\t\t\t\treturn process.env[name]\r\n\t\t\telse if (name == 'LINE')\r\n\t\t\t\t{source} = hNode\r\n\t\t\t\tif notdefined(source)\r\n\t\t\t\t\treturn \"<NOT DEFINED: source>\"\r\n\t\t\t\tlMatches = source.match(/\\d+$/)\r\n\t\t\t\tif notdefined(lMatches)\r\n\t\t\t\t\treturn \"<BAD SOURCE #{OL(source)}>\"\r\n\t\t\t\treturn lMatches[0]\r\n\t\t\telse\r\n\t\t\t\tvalue = @hConsts[name]\r\n\t\t\t\tif defined(value)\r\n\t\t\t\t\tif isString(value)\r\n\t\t\t\t\t\treturn value\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn JSON.stringify(value)\r\n\t\t\t\telse\r\n\t\t\t\t\treturn \"__#{name}__\"\r\n\r\n\t\treturn str.replace(///\r\n\t\t\t\t__\r\n\t\t\t\t(env\\.)?\r\n\t\t\t\t([A-Za-z_][A-Za-z0-9_]*)\r\n\t\t\t\t__\r\n\t\t\t\t///g, replacerFunc)\r\n"
  ]
}