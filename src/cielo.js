// Generated by CoffeeScript 2.7.0
  // cielo.coffee
import {
  undef,
  assert,
  croak,
  isString,
  isHash,
  uniq
} from '@jdeighan/coffee-utils';

import {
  log,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  withExt,
  slurp,
  barf,
  newerDestFileExists,
  shortenPath
} from '@jdeighan/coffee-utils/fs';

import {
  doMap,
  Mapper,
  CieloMapper
} from '@jdeighan/mapper';

import {
  addHereDocType
} from '@jdeighan/mapper/heredoc';

import {
  getNeededSymbols,
  buildImportList
} from '@jdeighan/mapper/symbols';

import {
  coffeeCodeToJS
} from '@jdeighan/mapper/coffee';

import {
  FuncHereDoc
} from '@jdeighan/mapper/func';

import {
  TAMLHereDoc
} from '@jdeighan/mapper/taml';

addHereDocType(new FuncHereDoc());

addHereDocType(new TAMLHereDoc());

export var convertingCielo = true;

// ---------------------------------------------------------------------------
export var convertCielo = function(flag) {
  convertingCielo = flag;
};

// ---------------------------------------------------------------------------
export var cieloCodeToJS = function(cieloCode, hOptions) {
  var coffeeCode, err, imports, jsCode, jsPreCode, lNeededSymbols, postmapper, premapper, source;
  // --- cielo => js
  //     Valid Options:
  //        premapper:  CieloMapper or subclass
  //        postmapper: CieloMapper or subclass
  //        source: name of source file
  //        hCoffeeOptions  - passed to CoffeeScript.parse()
  //           default:
  //              bare: true
  //              header: false
  debug('hOptions', hOptions);
  debug("enter cieloCodeToJS()");
  debug("cieloCode", cieloCode);
  assert(indentLevel(cieloCode) === 0, "cieloCodeToJS(): has indentation");
  if (isString(hOptions)) {
    source = hOptions;
    premapper = CieloMapper;
    postmapper = undef;
  } else if (isHash(hOptions)) {
    premapper = hOptions.premapper || CieloMapper;
    postmapper = hOptions.postmapper; // may be undef
    source = hOptions.source;
  } else {
    croak(`cieloCodeToJS(): Invalid 2nd parm: ${typeof hOptions}`);
  }
  assert(source != null, "cieloCodeToJS(): Missing source");
  // --- Even if no premapper is defined, this will handle
  //     continuation lines, HEREDOCs, etc.
  coffeeCode = doMap(premapper, cieloCode, source);
  if (coffeeCode !== cieloCode) {
    debug("coffeeCode", coffeeCode);
  }
  // --- symbols will always be unique
  lNeededSymbols = getNeededSymbols(coffeeCode);
  debug(`${lNeededSymbols.length} needed symbols: ${lNeededSymbols}`);
  try {
    if (convertingCielo) {
      jsPreCode = coffeeCodeToJS(coffeeCode, hOptions.hCoffeeOptions);
      debug("jsPreCode", jsPreCode);
    } else {
      jsPreCode = cieloCode;
    }
    if (postmapper) {
      jsCode = doMap(postmapper, jsPreCode, source);
      if (jsCode !== jsPreCode) {
        debug("post mapped", jsCode);
      }
    } else {
      jsCode = jsPreCode;
    }
  } catch (error) {
    err = error;
    croak(err, "Original Code", cieloCode);
  }
  imports = buildImportList(lNeededSymbols, source).join("\n");
  debug("imports", imports);
  debug("return from cieloCodeToJS()", jsCode);
  return {jsCode, imports};
};

// ---------------------------------------------------------------------------
export var cieloFileToJS = function(srcPath, destPath = undef, hOptions = {}) {
  var cieloCode, dumpfile, i, imports, jsCode, lNeeded, len, n, sym, word;
  if (destPath == null) {
    destPath = withExt(srcPath, '.js', {
      removeLeadingUnderScore: true
    });
  }
  if (hOptions.force || !newerDestFileExists(srcPath, destPath)) {
    cieloCode = slurp(srcPath);
    if (hOptions.saveAST) {
      dumpfile = withExt(srcPath, '.ast');
      lNeeded = getNeededSymbols(cieloCode, {dumpfile});
      if ((lNeeded === undef) || (lNeeded.length === 0)) {
        debug(`NO NEEDED SYMBOLS in ${shortenPath(destPath)}:`);
      } else {
        n = lNeeded.length;
        word = n === 1 ? 'SYMBOL' : 'SYMBOLS';
        debug(`${n} NEEDED ${word} in ${shortenPath(destPath)}:`);
        for (i = 0, len = lNeeded.length; i < len; i++) {
          sym = lNeeded[i];
          debug(`   - ${sym}`);
        }
      }
    }
    ({imports, jsCode} = cieloCodeToJS(cieloCode, hOptions));
    barf(destPath, [imports, jsCode]);
  }
};
