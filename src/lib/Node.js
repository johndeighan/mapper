// Generated by CoffeeScript 2.7.0
  // Node.coffee
import {
  undef,
  pass,
  defined,
  notdefined,
  OL,
  isEmpty,
  nonEmpty,
  isString,
  isBoolean,
  isInteger,
  getOptions
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/base-utils/log';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  indented,
  indentLevel,
  splitPrefix
} from '@jdeighan/coffee-utils/indent';

// ---------------------------------------------------------------------------
export var Node = class Node {
  constructor(hNodeDesc) {
    // --- Keys 'str' and 'level' are required
    //     Keys 'source' and 'lineNum' are optional
    Object.assign(this, hNodeDesc);
    assert(isString(this.str), `str ${OL(this.str)} not a string`);
    assert(isInteger(this.level, {
      min: 0
    }), `level ${OL(this.level)} not an integer`);
    if (defined(this.source)) {
      assert(isString(this.source), "source not a string");
    }
    // --- level may later be adjusted, but srcLevel should be const
    this.srcLevel = this.level;
  }

  // ..........................................................
  desc() {
    var str;
    str = `[${this.level}] ${OL(this.str)}`;
    if (defined(this.uobj) && (this.uobj !== this.str)) {
      str += ` ${OL(this.uobj)}`;
    }
    return str;
  }

  // ..........................................................
  isEmptyLine() {
    var str;
    str = this.uobj || this.str;
    if (!isString(str) || nonEmpty(str)) {
      return false;
    }
    assert(str === '', "empty node is not empty string");
    assert(this.level === 0, "empty node not at level 0");
    return true;
  }

  // ..........................................................
  // --- used when '#include <file>' has indentation
  incLevel(n = 1) {
    this.level += n;
  }

  // ..........................................................
  // --- getLine() should only be called when text is desired,
  //        e.g. in getBlock()
  getLine(hOptions = {}) {
    var oneIndent, result, str, undent;
    dbgEnter('Node.getLine', hOptions);
    // --- empty lines never get undented
    if (this.isEmptyLine()) {
      dbgReturn('Node.getLine', '');
      return '';
    }
    ({oneIndent, undent} = getOptions(hOptions, {
      oneIndent: "\t",
      undent: 0
    }));
    if (oneIndent !== "\t") {
      dbg(`oneIndent = ${OL(oneIndent)}`);
    }
    if (undent === true) {
      croak("undent set to true");
    } else if (undent === false) {
      undent = 0;
    }
    assert(isInteger(undent), "undent not an integer");
    if (undent > 0) {
      dbg(`undent ${OL(undent)} levels`);
    }
    // --- If Node has key 'uobj', use that to build the line
    //     else use key 'str'
    str = this.uobj || this.str;
    assert(isString(str), `not a string: ${OL(str)}`);
    assert(this.level >= undent, `undent = ${undent}, level = ${this.level}`);
    result = indented(str, this.level - undent, oneIndent);
    dbgReturn('Node.getLine', result);
    return result;
  }

};
