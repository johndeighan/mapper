// Generated by CoffeeScript 2.5.1
  // CodeWalker.coffee
import {
  strict as assert
} from 'assert';

import CoffeeScript from 'coffeescript';

import {
  undef,
  say
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  TreeWalker
} from '@jdeighan/string-input/tree';

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var CodeWalker = class CodeWalker extends TreeWalker {
  constructor(text) {
    var ast;
    ast = CoffeeScript.compile(text, {
      ast: true
    });
    super(ast.program);
    this.ast = ast.program;
    this.hImports = {};
    this.hSymbols = {};
    // --- subarrays are sets of formal parameters
    //     which are never missing symbols
    this.lFormalParams = [];
    // --- contains names of variables assigned to
    //     For now, we don't take scope into account
    //     The name of any variable assigned to will
    //        never be considered a missing symbol
    //        (unless it's used before being assigned)
    this.lVarNames = [];
  }

  // ..........................................................
  isFormalParam(name) {
    var i, len, ref, subarray;
    ref = this.lFormalParams;
    for (i = 0, len = ref.length; i < len; i++) {
      subarray = ref[i];
      if (subarray.includes(name)) {
        return true;
      }
    }
    return false;
  }

  // ..........................................................
  isVariableName(name) {
    return this.lVarNames.includes(name);
  }

  // ..........................................................
  addImport(name, value = {}) {
    assert(name, "addImport: empty name");
    this.hImports[name] = value;
  }

  // ..........................................................
  addSymbol(name, value = {}) {
    assert(name, "addSymbol: empty name");
    if (!this.isFormalParam(name) && !this.isVariableName(name)) {
      this.hSymbols[name] = value;
    }
  }

  // ..........................................................
  visit(node, level) {
    var hItem, i, lParams, left, len, ref, right;
    debug("tree", node.type);
    switch (node.type) {
      case 'ImportDefaultSpecifier':
        this.addSymbol(node.local.name);
        break;
      case 'ImportSpecifier':
        this.addSymbol(node.imported.name);
        break;
      case 'CallExpression':
        this.addSymbol(node.callee.name);
        break;
      case 'ClassDeclaration':
        if ((node.superClass != null) && node.superClass.type === 'Identifier') {
          this.addSymbol(node.superClass.name);
        }
        break;
      case 'ReturnStatement':
        if ((node.argument != null) && (node.argument.type === 'Identifier')) {
          this.addSymbol(node.argument.name);
        }
        break;
      case 'SwitchStatement':
        if ((node.discriminant != null) && (node.discriminant.type === 'Identifier')) {
          this.addSymbol(node.discriminant.name);
        }
        break;
      case 'SwitchCase':
        if ((node.test != null) && (node.test.type === 'Identifier')) {
          this.addSymbol(node.test.name);
        }
        break;
      case 'FunctionExpression':
        // --- We need to add to @lFormalParams
        lParams = [];
        ref = node.params;
        for (i = 0, len = ref.length; i < len; i++) {
          hItem = ref[i];
          if (hItem.type === 'AssignmentPattern') {
            ({left, right} = hItem);
            if (left.type === 'Identifier') {
              lParams.push(left.name);
            }
            if (right.type === 'Identifier') {
              this.addSymbol(right.name);
            }
          }
        }
        this.lFormalParams.push(lParams);
        break;
      case 'AssignmentExpression':
        assert(node.left != null, "assignment expr without left");
        assert(node.right != null, "assignment expr without right");
        if (node.left.type === 'Identifier') {
          this.lVarNames.push(node.left.name);
        }
    }
  }

  // ..........................................................
  endVisit(node, level) {
    // --- Called after the node's entire subtree has been walked
    if (node.type === 'FunctionExpression') {
      this.lFormalParams.pop();
    }
    debug("untree");
  }

  // ..........................................................
  getSubTrees(node) {
    var add, lSubTrees;
    lSubTrees = [];
    add = function(...subtrees) {
      return lSubTrees.push(...subtrees);
    };
    switch (node.type) {
      case 'Program':
      case 'BlockStatement':
      case 'ClassDeclaration':
      case 'ClassBody':
      case 'ClassMethod':
        add(node.body);
        break;
      case 'ExpressionStatement':
        add(node.expression);
        break;
      case 'IfStatement':
        add(node.test, node.consequent);
        break;
      case 'BinaryExpression':
      case 'AssignmentExpression':
        add(node.left, node.right);
        break;
      case 'ExpressionStatement':
        add(node.expression);
        break;
      case 'For':
        add(node.body, node.source);
        break;
      case 'SwitchStatement':
        add(node.cases);
        break;
      case 'SwitchCase':
        add(node.test, node.consequent);
        break;
      case 'FunctionExpression':
        add(node.params, node.body);
    }
    return lSubTrees;
  }

  // ..........................................................
  getMissingSymbols() {
    var i, key, len, ref;
    this.hImports = {};
    this.hSymbols = {};
    this.walk();
    ref = Object.keys(this.hImports);
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (this.hSymbols[key] != null) {
        delete this.hSymbols[key];
      }
    }
    return this.hSymbols;
  }

};
