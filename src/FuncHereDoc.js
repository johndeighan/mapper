// Generated by CoffeeScript 2.7.0
// FuncHereDoc.coffee
var isFunctionDef;

import {
  undef,
  isArray
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  indented,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  coffeeCodeToJS
} from '@jdeighan/mapper/coffee';

// ---------------------------------------------------------------------------
// --- This class, or a subclass, can be used
//     with addHereDocType
export var FuncHereDoc = class FuncHereDoc {
  myName() {
    return 'function';
  }

  isMyHereDoc(block) {
    return isFunctionDef(block);
  }

  // --- treat strBody as CoffeeScript
  //     These 2 methods should return JavaScript code
  codeToFuncStr(lParms, strBody) {
    var coffeeCode;
    coffeeCode = buildCoffeeCode(lParms, strBody);
    return coffeeCodeToJS(coffeeCode).replace(/\s+/g, ' ');
  }

  codeToFunc(lParms, strBody) {
    strBody = coffeeCodeToJS(strBody);
    return new Function(...lParms, strBody);
  }

  map(block, lParts = undef) {
    var hResult, lParms, strBody;
    debug("enter FuncHereDoc.map()");
    // --- lParts should be return value from isMyHereDoc()
    //     if empty, we'll just call it again
    if (lParts) {
      [lParms, strBody] = lParts;
    } else {
      [lParms, strBody] = this.isMyHereDoc(block);
    }
    hResult = {
      str: this.codeToFuncStr(lParms, strBody),
      obj: this.codeToFunc(lParms, strBody)
    };
    debug("return from FuncHereDoc.map()", hResult);
    return hResult;
  }

};

// ---------------------------------------------------------------------------
isFunctionDef = function(block) {
  var _, lMatches, lParms, lParts, strBody, strParms;
  debug("enter isFunctionDef()", block);
  lMatches = block.match(/^\(\s*([A-Za-z_][A-Za-z0-9_]*(?:,\s*[A-Za-z_][A-Za-z0-9_]*)*)?\s*\)\s*->[ \t]*\n?(.*)$/s); // optional parameters
  if (!lMatches) {
    debug("return from isFunctionDef - no match");
    return undef;
  }
  [_, strParms, strBody] = lMatches;
  if (strBody != null) {
    strBody = undented(strBody);
  } else {
    strBody = '';
  }
  // --- Remove whitespace, then split on commas
  if (strParms != null) {
    lParms = strParms.replace(/\s+/g, '').split(',');
  } else {
    lParms = [];
  }
  lParts = [lParms, strBody];
  debug("return from isFunctionDef()", lParts);
  return lParts;
};

// ---------------------------------------------------------------------------
export var buildCoffeeCode = function(lParms, strBody) {
  var coffeeCode;
  if (lParms && isArray(lParms) && (lParms.length > 0)) {
    coffeeCode = `(${lParms.join(',')}) ->`;
  } else {
    coffeeCode = "() ->";
  }
  if (strBody) {
    coffeeCode = coffeeCode + "\n" + indented(strBody, 1);
  }
  return coffeeCode;
};

// ---------------------------------------------------------------------------
export var buildJSCode = function(lParms, strBody) {
  var jsCode;
  if (lParms && isArray(lParms) && (lParms.length > 0)) {
    jsCode = `(${lParms.join(',')}) ->`;
  } else {
    jsCode = "() =>";
  }
  if (strBody) {
    jsCode = jsCode + "\n" + indented(strBody, 1);
  }
  return jsCode;
};
