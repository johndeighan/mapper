// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  LOG,
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  fromTAML
} from '@jdeighan/base-utils/taml';

import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isObject,
  isEmpty,
  nonEmpty,
  isSubclassOf,
  isConstructor
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  parseSource,
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
// class Mapper - adds:
//    1. registering special types of nodes, by default:
//          - empty lines
//          - comments
//          - commands
//    2. defines constants FILE, DIR, SRC and LINE
//    3. maintain the LINE variable
//    3. implements command #define
export var Mapper = class Mapper extends Getter {
  constructor(hInput, options = {}) {
    dbgEnter("Mapper", hInput, options);
    super(hInput, options);
    // --- These never change
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    this.setConst('SRC', this.sourceInfoStr());
    // --- This needs to be kept updated
    this.setConst('LINE', this.lineNum);
    this.hSpecials = {};
    this.lSpecials = []; // checked in this order
    
    // --- These must be bound to a specific object when called
    this.registerSpecialType('empty', this.isEmptyLine, this.mapEmptyLine);
    this.registerSpecialType('comment', this.isComment, this.mapComment);
    this.registerSpecialType('cmd', this.isCmd, this.mapCmd);
    dbgReturn("Mapper");
  }

  // ..........................................................
  registerSpecialType(type, recognizer, mapper) {
    if (!this.lSpecials.includes(type)) {
      this.lSpecials.push(type);
    }
    this.hSpecials[type] = {recognizer, mapper};
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    dbgEnter("Mapper.incLineNum", inc);
    super.incLineNum(inc);
    this.setConst('LINE', this.lineNum);
    dbgReturn("Mapper.incLineNum");
  }

  // ..........................................................
  getItemType(hNode) {
    var i, len, recognizer, ref, str, type;
    dbgEnter("Mapper.getItemType", hNode);
    ({str} = hNode);
    assert(isString(str), `str is ${OL(str)}`);
    ref = this.lSpecials;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      recognizer = this.hSpecials[type].recognizer;
      if (recognizer.bind(this)(hNode)) {
        dbgReturn("Mapper.getItemType", type);
        return type;
      }
    }
    dbgReturn("Mapper.getItemType", undef);
    return undef;
  }

  // ..........................................................
  mapSpecial(type, hNode) {
    var h, mapper, uobj;
    dbgEnter("Mapper.mapSpecial", type, hNode);
    assert(hNode instanceof Node, `hNode is ${OL(hNode)}`);
    assert(hNode.type === type, `hNode is ${OL(hNode)}`);
    h = this.hSpecials[type];
    assert(isHash(h), `Unknown type ${OL(type)}`);
    mapper = h.mapper.bind(this);
    assert(isFunction(mapper), `Bad mapper for ${OL(type)}`);
    uobj = mapper(hNode);
    dbgReturn("Mapper.mapSpecial", uobj);
    return uobj;
  }

  // ..........................................................
  isEmptyLine(hNode) {
    return hNode.str === '';
  }

  // ..........................................................
  mapEmptyLine(hNode) {
    // --- default: remove empty lines
    //     return '' to keep empty lines
    return undef;
  }

  // ..........................................................
  isComment(hNode) {
    if (hNode.str.indexOf('# ') === 0) {
      hNode.uobj = {
        comment: hNode.str.substring(2).trim()
      };
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  mapComment(hNode) {
    // --- default: remove comments
    // --- To keep comments, simply return hNode.uobj
    return undef;
  }

  // ..........................................................
  isCmd(hNode) {
    var lMatches;
    dbgEnter("Mapper.isCmd");
    if (lMatches = hNode.str.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      hNode.uobj = {
        cmd: lMatches[1],
        argstr: lMatches[2]
      };
      dbgReturn("Mapper.isCmd", true);
      return true;
    } else {
      dbgReturn("Mapper.isCmd", false);
      return false;
    }
  }

  // ..........................................................
  // --- mapCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class mapCmd
  mapCmd(hNode) {
    var _, argstr, cmd, isEnv, lMatches, name, tail;
    dbgEnter("Mapper.mapCmd", hNode);
    // --- isCmd() put these keys here
    ({cmd, argstr} = hNode.uobj);
    assert(nonEmpty(cmd), "mapCmd() with empty cmd");
    switch (cmd) {
      case 'define':
        lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/); // name of the variable
        assert(defined(lMatches), `Bad #define cmd: ${cmd} ${argstr}`);
        [_, isEnv, name, tail] = lMatches;
        if (tail) {
          tail = tail.trim();
        }
        if (isEnv) {
          dbg(`set env var ${name} to '${tail}'`);
          process.env[name] = tail;
        } else {
          dbg(`set var ${name} to '${tail}'`);
          this.setConst(name, tail);
        }
        dbgReturn("Mapper.mapCmd", undef);
        return undef;
      default:
        return croak(`Unknown command: ${OL(cmd)}`);
    }
  }

};

// --- don't throw exception
//     check for unknown commands in visitCmd()
//				dbgReturn "Mapper.mapCmd", hNode.uobj
//				return hNode.uobj

// ===========================================================================
// --- mapper must be a subclass of Mapper or an array
//     of subclasses of Mapper.
export var map = function(hInput, mapperClass, hOptions = {}) {
  var content, i, item, len, mapper, result, source;
  // --- Valid options:
  //        logNodes
  dbgEnter("map", hInput, mapperClass, hOptions);
  if (isString(hInput)) {
    dbg("hInput is a string, constructing new hInput");
    hInput = {
      content: hInput
    };
  }
  // --- An array can be provided - the input is processed
  //     by each array element sequentially
  if (isArray(mapperClass)) {
    dbg("mapperClass is an array - using each array element");
    for (i = 0, len = mapperClass.length; i < len; i++) {
      item = mapperClass[i];
      if (defined(item)) {
        hInput.content = map(hInput, item, hOptions);
      }
    }
    dbgReturn("map", hInput.content);
    return hInput.content;
  }
  assert(isHash(hInput), `hInput not a hash: ${OL(hInput)}`);
  ({source, content} = hInput);
  dbg("unpacked:");
  dbg('   source =', source);
  dbg('   content =', content);
  assert(isConstructor(mapperClass), "mapper not a constructor");
  mapper = new mapperClass({source, content});
  assert(mapper instanceof Mapper, "not a Mapper class");
  result = mapper.getBlock(hOptions);
  dbgReturn("map", result);
  return result;
};
