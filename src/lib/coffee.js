// Generated by CoffeeScript 2.7.0
// coffee.coffee
var expand;

import CoffeeScript from 'coffeescript';

import {
  CWS,
  undef,
  defined,
  OL,
  getOptions
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG,
  LOGVALUE,
  sep_dash
} from '@jdeighan/base-utils/log';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  mkpath,
  slurp,
  barf
} from '@jdeighan/base-utils/fs';

import {
  indentLevel,
  isUndented,
  indented
} from '@jdeighan/base-utils/indent';

import {
  Mapper,
  map
} from '@jdeighan/mapper';

import {
  TreeMapper
} from '@jdeighan/mapper/tree';

// ---------------------------------------------------------------------------
export var brew = function(code) {
  var hCoffeeOptions, mapped, result;
  hCoffeeOptions = {
    bare: true,
    header: false
  };
  mapped = map(code, CoffeePreProcessor);
  result = CoffeeScript.compile(mapped, hCoffeeOptions);
  // --- Result is JS code
  return result.trim();
};

// ---------------------------------------------------------------------------
export var coffeeCodeToJS = function(coffeeCode) {
  var err, jsCode;
  assert(isUndented(coffeeCode), "has indentation");
  dbgEnter("coffeeCodeToJS", coffeeCode);
  try {
    jsCode = brew(coffeeCode);
    // --- cleanJS() does:
    //        1. remove blank lines
    //        2. remove trailing newline
    jsCode = cleanJS(jsCode);
  } catch (error) {
    err = error;
    croak(err, "Original Code", coffeeCode);
  }
  dbgReturn("coffeeCodeToJS", jsCode);
  return jsCode;
};

// ---------------------------------------------------------------------------
export var coffeeExprToJS = function(coffeeExpr) {
  var err, jsExpr, pos;
  assert(isUndented(coffeeExpr), "has indentation");
  dbgEnter("coffeeExprToJS");
  try {
    jsExpr = brew(coffeeExpr);
    // --- Remove any trailing semicolon
    pos = jsExpr.length - 1;
    if (jsExpr.substr(pos, 1) === ';') {
      jsExpr = jsExpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, "coffeeExprToJS", coffeeExpr);
  }
  dbgReturn("coffeeExprToJS", jsExpr);
  return jsExpr;
};

// ---------------------------------------------------------------------------
export var coffeeFileToJS = function(srcPath, destPath = undef, hOptions = {}) {
  var coffeeCode, dumpfile, force, i, jsCode, lNeeded, len, n, saveAST, sym, word;
  // --- coffee => js
  //     Valid Options:
  //        saveAST
  //        force
  //        premapper
  //        postmapper
  if (notdefined(destPath)) {
    destPath = withExt(srcPath, '.js');
  }
  ({force, saveAST} = getOptions(hOptions));
  if (force || !newerDestFileExists(srcPath, destPath)) {
    coffeeCode = slurp(srcPath);
    if (saveAST) {
      dumpfile = withExt(srcPath, '.ast');
      lNeeded = getNeededSymbols(coffeeCode, {dumpfile});
      if ((lNeeded === undef) || (lNeeded.length === 0)) {
        dbg(`NO NEEDED SYMBOLS in ${shortenPath(destPath)}:`);
      } else {
        n = lNeeded.length;
        word = n === 1 ? 'SYMBOL' : 'SYMBOLS';
        dbg(`${n} NEEDED ${word} in ${shortenPath(destPath)}:`);
        for (i = 0, len = lNeeded.length; i < len; i++) {
          sym = lNeeded[i];
          dbg(`   - ${sym}`);
        }
      }
    }
    jsCode = coffeeCodeToJS(coffeeCode);
    barf(jsCode, destPath);
  }
};

// ---------------------------------------------------------------------------
export var coffeeCodeToAST = function(coffeeCode) {
  var ast, err, mapped;
  assert(isUndented(coffeeCode), "has indentation");
  dbgEnter("coffeeCodeToAST", coffeeCode);
  try {
    mapped = map(coffeeCode, CoffeePreProcessor);
    assert(defined(mapped), "mapped is undef");
  } catch (error) {
    err = error;
    croak(`ERROR in CoffeePreProcessor: ${err.message}`);
  }
  try {
    ast = CoffeeScript.compile(mapped, {
      ast: true
    });
    assert(defined(ast), "ast is empty");
  } catch (error) {
    err = error;
    LOG(`ERROR in CoffeeScript: ${err.message}`);
    LOG(sep_dash);
    LOG(`${OL(coffeeCode)}`);
    LOG(sep_dash);
    croak(`ERROR in CoffeeScript: ${err.message}`);
  }
  dbgReturn("coffeeCodeToAST", ast);
  return ast;
};

// ---------------------------------------------------------------------------
export var cleanJS = function(jsCode) {
  jsCode = jsCode.replace(/\n\n+/gs, "\n"); // multiple NL to single NL
  jsCode = jsCode.replace(/\n$/s, ''); // strip trailing whitespace
  return jsCode;
};

// ---------------------------------------------------------------------------
export var minifyJS = function(jsCode, lParms) {
  jsCode = CWS(jsCode);
  jsCode = jsCode.replace(/,\s+/, ',');
  return jsCode;
};

// ---------------------------------------------------------------------------
expand = function(qstr) {
  var lMatches, result;
  lMatches = qstr.match(/^\"(.*)\"$/);
  assert(defined(lMatches), `Bad arg: ${OL(qstr)}`);
  assert(lMatches[1].indexOf('"') === -1, `Bad arg: ${OL(qstr)}`);
  return result = qstr.replace(/\$([A-Za-z_][A-Za-z0-9_]*)/g, function(_, ident) {
    return `\#{OL(${ident})}`;
  });
};

// ---------------------------------------------------------------------------
export var CoffeePreProcessor = class CoffeePreProcessor extends TreeMapper {
  mapComment(hNode) {
    var level, result, str;
    // --- Retain comments
    dbgEnter("CoffeePreProcessor.mapComment");
    ({str, level} = hNode);
    result = indented(str, level, this.oneIndent);
    dbgReturn("CoffeePreProcessor.mapComment", result);
    return result;
  }

  // ..........................................................
  getUserObj(hNode) {
    var level, result, str;
    // --- only non-special nodes
    dbgEnter("CoffeePreProcessor.getUserObj", hNode);
    ({str, level} = hNode);
    result = str.replace(/\"[^"]*\"/g, function(qstr) { // sequence of non-quote characters
      return expand(qstr);
    });
    result = indented(result, level, this.oneIndent);
    dbgReturn("CoffeePreProcessor.getUserObj", result);
    return result;
  }

};

//# sourceMappingURL=coffee.js.map
