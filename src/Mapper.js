// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
//   class Mapper
//       handles:
//          #define
//          variable substitution
//          getLineType(), handleLineType()
export var Mapper = class Mapper extends Getter {
  constructor(source = undef, collection = undef, hOptions = {}) {
    debug("enter Mapper()");
    super(source, collection, hOptions);
    this.setVar('FILE', this.filename);
    this.setVar('DIR', this.hSourceInfo.dir);
    this.setVar('LINE', this.lineNum);
    debug("return from Mapper()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    debug(`enter incLineNum(${inc})`);
    super.incLineNum(inc);
    this.setVar('LINE', this.lineNum);
    debug("return from incLineNum()");
  }

  // ..........................................................
  // --- override
  getItemType(item) {
    var h, result;
    debug("enter Mapper.getItemType()", item);
    // --- only strings may have an item type
    if (isString(item)) {
      // --- check for empty item
      if (this.isEmptyLine(item)) {
        result = ['empty', undef];
      }
      // --- check for comment
      if (this.isComment(item)) {
        result = ['comment', undef];
      }
      // --- check for cmd
      if (defined(h = this.isCmd(item))) {
        assert(isHash(h, ['cmd', 'argstr', 'prefix']), `isCmd() returned non-hash ${OL(h)}`);
        result = ['cmd', h];
      }
    }
    debug("return from Mapper.getItemType()", result);
    return result;
  }

  // ..........................................................
  // --- override
  handleItemType(type, item, h) {
    var result;
    debug(`enter Mapper.handleItemType(${OL(type)})`, item);
    switch (type) {
      case 'empty':
        result = this.handleEmptyLine();
        break;
      case 'comment':
        result = this.handleComment(item);
        break;
      case 'cmd':
        result = this.handleCmd(h);
        break;
      default:
        croak(`Unknown item type: ${OL(type)}`);
    }
    debug("return from Mapper.handleItemType()", result);
    return result;
  }

  // ..........................................................
  isEmptyLine(line) {
    return isEmpty(line);
  }

  // ..........................................................
  handleEmptyLine(line) {
    // --- can override
    //     line may contain whitespace

    // --- return undef to remove empty lines
    return '';
  }

  // ..........................................................
  isComment(line) {
    var ch, lMatches;
    if ((lMatches = line.match(/^\s*\#(.|$)/))) { // a # character
      // following character, if any
      ch = lMatches[1];
      return (ch === undef) || (ch === ' ' || ch === '\t' || ch === '');
    } else {
      return false;
    }
  }

  // ..........................................................
  handleComment(line) {
    debug("in Mapper.handleComment()");
    // --- return undef to remove empty lines
    return line;
  }

  // ..........................................................
  isCmd(line) {
    var _, argstr, cmd, hResult, lMatches, prefix;
    // --- Must return either undef or {prefix, cmd, argstr}
    debug("enter Mapper.isCmd()");
    if (lMatches = line.match(/^(\s*)\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, prefix, cmd, argstr] = lMatches;
      hResult = {
        prefix: prefix || '',
        cmd,
        argstr: argstr ? argstr.trim() : ''
      };
      debug("return from Mapper.isCmd()", hResult);
      return hResult;
    }
    // --- not a command
    debug("return undef from Mapper.isCmd()");
    return undef;
  }

  // ..........................................................
  // --- handleCmd must return a pair:
  //        [handled:boolean, result:any]
  // Override must 1st handle it's own commands, then call this
  handleCmd(h) {
    var _, argstr, cmd, isEnv, lMatches, name, prefix, tail;
    ({cmd, argstr, prefix} = h);
    debug(`enter Mapper.handleCmd #${cmd} '${argstr}'`);
    if (prefix.length > 0) {
      debug(`   prefix = '${escapeStr(prefix)}'`);
    }
    // --- Each case should return
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, isEnv, name, tail] = lMatches;
          if (tail) {
            tail = tail.trim();
          }
          if (isEnv) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setVar(name, tail);
          }
        }
        debug("return undef from Mapper.handleCmd()");
        return undef;
      default:
        croak(`Unknown command: #${cmd}`);
    }
    return croak("Not all cases return");
  }

};

// ===========================================================================
export var doMap = function(inputClass, source, content = undef) {
  var name, oInput, result;
  assert(inputClass != null, "Missing input class");
  name = className(inputClass);
  debug(`enter doMap(${name}) source='${source}'`, content);
  oInput = new inputClass(source, content);
  assert(oInput instanceof Mapper, "doMap() requires a Mapper or subclass");
  result = oInput.getBlock();
  debug("return from doMap()", result);
  return result;
};
