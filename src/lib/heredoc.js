// Generated by CoffeeScript 2.7.0
// heredoc.coffee
var hHereDocs, lHereDocs;

import {
  undef,
  defined,
  notdefined,
  pass,
  escapeStr,
  OL,
  CWS,
  className,
  isString,
  isNonEmptyString,
  isHash,
  isEmpty,
  nonEmpty,
  isObject,
  toBlock
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG
} from '@jdeighan/base-utils/log';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  isTAML,
  fromTAML
} from '@jdeighan/base-utils/taml';

import {
  firstLine,
  remainingLines,
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  indented,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  Fetcher
} from '@jdeighan/mapper/fetcher';

lHereDocs = []; // checked in this order - list of type names

hHereDocs = {}; // {type: obj}


// ---------------------------------------------------------------------------
export var replaceHereDocs = (line, fetcher) => {
  var block, hNode, i, lLines, lNewParts, lParts, len, part, result, str;
  dbgEnter("replaceHereDocs", line);
  assert(isString(line), "not a string");
  assert(fetcher instanceof Fetcher, "not a Fetcher");
  lParts = lineToParts(line);
  dbg('lParts', lParts);
  lNewParts = []; // to be joined to form new line
  for (i = 0, len = lParts.length; i < len; i++) {
    part = lParts[i];
    if (part === '<<<') {
      dbg("get HEREDOC lines until blank line");
      lLines = [];
      while (defined(hNode = fetcher.fetch()) && !hNode.isEmptyLine()) {
        lLines.push(indented(hNode.str, hNode.level));
      }
      block = undented(toBlock(lLines));
      dbg('block', block);
      str = mapHereDoc(block);
      assert(isString(str), `str is ${OL(str)}`);
      dbg('mapped block', str);
      lNewParts.push(str);
    } else {
      lNewParts.push(part); // keep as is
    }
  }
  result = lNewParts.join('');
  dbgReturn("replaceHereDocs", result);
  return result;
};

// ---------------------------------------------------------------------------
export var lineToParts = function(line) {
  var lParts, pos, start;
  // --- Always returns an odd number of parts
  //     Odd numbered parts are '<<<', Even numbered parts are not '<<<'
  lParts = [];
  pos = 0;
  while ((start = line.indexOf('<<<', pos)) !== -1) {
    lParts.push(line.substring(pos, start));
    lParts.push('<<<');
    pos = start + 3;
  }
  lParts.push(line.substring(pos));
  return lParts;
};

// ---------------------------------------------------------------------------
// Returns a CieloScript expression or undef
export var mapHereDoc = function(block) {
  var heredocObj, i, len, result, type;
  dbgEnter("mapHereDoc", block);
  assert(isString(block), "not a string");
  for (i = 0, len = lHereDocs.length; i < len; i++) {
    type = lHereDocs[i];
    dbg(`TRY ${type} HEREDOC`);
    heredocObj = hHereDocs[type];
    result = heredocObj.mapToCielo(block);
    if (defined(result)) {
      assert(isString(result), "result not a string");
      dbg(`   - FOUND ${type} HEREDOC`);
      dbgReturn("mapHereDoc", result);
      return result;
    } else {
      dbg(`   - NOT A ${type} HEREDOC`);
    }
  }
  dbg("HEREDOC type 'default'");
  result = JSON.stringify(block); // can directly replace <<<
  dbgReturn("mapHereDoc", result);
  return result;
};

// ---------------------------------------------------------------------------
export var addHereDocType = function(type, obj) {
  var subtype;
  dbgEnter("addHereDocType", type, obj);
  assert(isNonEmptyString(type), `type is ${OL(type)}`);
  if (!isObject(obj, 'mapToCielo')) {
    [type, subtype] = jsType(obj);
    console.log(`type = ${OL(type)}`);
    console.log(`subtype = ${OL(subtype)}`);
  }
  assert(isObject(obj, 'mapToCielo'), `Bad input object: ${OL(obj)}`);
  assert(obj instanceof BaseHereDoc, "not a BaseHereDoc");
  assert(notdefined(hHereDocs[type]), `Heredoc type ${type} already installed`);
  lHereDocs.push(type);
  hHereDocs[type] = obj;
  dbgReturn("addHereDocType");
};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// --- To extend,
//        define mapToCielo(block) that:
//           returns undef if it's not your HEREDOC type
//           else returns a CieloScript expression
export var BaseHereDoc = class BaseHereDoc {
  mapToCielo(block) {
    return undef;
  }

};

// ---------------------------------------------------------------------------
export var ExplicitBlockHereDoc = class ExplicitBlockHereDoc extends BaseHereDoc {
  // --- First line must be '==='
  //     Return value is quoted string of remaining lines
  mapToCielo(block) {
    if (firstLine(block) !== '===') {
      return undef;
    }
    return JSON.stringify(remainingLines(block));
  }

};

// ---------------------------------------------------------------------------
export var OneLineHereDoc = class OneLineHereDoc extends BaseHereDoc {
  // --- First line must begin with '...'
  //     Return value is single line string after '...' with
  //        runs of whitespace replaced with a single space char
  mapToCielo(block) {
    if (block.indexOf('...') !== 0) {
      return undef;
    }
    return JSON.stringify(block.substring(3).trim().replace(/\s+/gs, ' '));
  }

};

// ---------------------------------------------------------------------------
export var TAMLHereDoc = class TAMLHereDoc extends BaseHereDoc {
  // --- First line must be '---'
  mapToCielo(block) {
    var result;
    dbgEnter('TAMLHereDoc.mapToCielo', block);
    if (firstLine(block) !== '---') {
      dbgReturn('TAMLHereDoc.mapToCielo', undef);
      return undef;
    }
    result = JSON.stringify(fromTAML(block));
    dbgReturn('TAMLHereDoc.mapToCielo', result);
    return result;
  }

};

// ---------------------------------------------------------------------------

// --- Add the standard HEREDOC types
addHereDocType('one line', new OneLineHereDoc());

addHereDocType('block', new ExplicitBlockHereDoc());

addHereDocType('taml', new TAMLHereDoc());
