// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  notdefined,
  escapeStr,
  isHashComment,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isObject,
  isEmpty,
  nonEmpty,
  isClass,
  className
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG
} from '@jdeighan/base-utils/log';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  fromTAML
} from '@jdeighan/base-utils/taml';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  parseSource,
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
// class Mapper - adds:
//    1. registering special types of nodes, by default:
//          - empty lines
//          - comments
//          - commands
//    2. defines constants FILE, DIR and SRC
//    3. implements command #define
export var Mapper = class Mapper extends Getter {
  constructor(hInput, options = {}) {
    dbgEnter("Mapper", hInput, options);
    super(hInput, options);
    // --- These never change
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    this.setConst('SRC', this.sourceInfoStr());
    this.hSpecials = {};
    this.lSpecials = []; // checked in this order
    
    // --- These must be bound to a specific object when called
    this.registerType('empty', this.isEmptyLine, this.mapEmptyLine);
    this.registerType('comment', this.isComment, this.mapComment);
    this.registerType('cmd', this.isCmd, this.mapCmd);
    dbgReturn("Mapper");
  }

  // ..........................................................
  isValidType(type) {
    return defined(this.hSpecials[type]);
  }

  // ..........................................................
  registerType(type, recognizer, mapper) {
    if (!this.lSpecials.includes(type)) {
      this.lSpecials.push(type);
    }
    this.hSpecials[type] = {recognizer, mapper};
  }

  // ..........................................................
  getItemType(hNode) {
    var i, len, recognizer, ref, str, type;
    dbgEnter("Mapper.getItemType", hNode);
    ({str} = hNode);
    assert(isString(str), `str is ${OL(str)}`);
    ref = this.lSpecials;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      recognizer = this.hSpecials[type].recognizer;
      if (recognizer.bind(this)(hNode)) {
        dbgReturn("Mapper.getItemType", type);
        return type;
      }
    }
    dbgReturn("Mapper.getItemType", undef);
    return undef;
  }

  // ..........................................................
  mapNode(hNode) {
    var h, mapper, type, uobj;
    dbgEnter("Mapper.mapNode", hNode);
    assert(hNode instanceof Node, `hNode is ${OL(hNode)}`);
    ({type} = hNode);
    if (type) {
      h = this.hSpecials[type];
      assert(isHash(h), `Unknown type ${OL(type)}`);
      mapper = h.mapper.bind(this);
      assert(isFunction(mapper), `Bad mapper for ${OL(type)}`);
      uobj = mapper(hNode);
    } else {
      uobj = this.mapToUserObj(hNode);
    }
    dbgReturn("Mapper.mapNode", uobj);
    return uobj;
  }

  // ..........................................................
  // designed to override
  // only receives nodes without a type
  mapToUserObj(hNode) {
    var str, type;
    ({type, str} = hNode);
    assert(notdefined(type), `mapToUserObj(): type = ${type}`);
    return str;
  }

  // ==========================================================
  isEmptyLine(hNode) {
    return hNode.str === '';
  }

  // ..........................................................
  mapEmptyLine(hNode) {
    // --- default: remove empty lines
    //     return '' to keep empty lines
    return undef;
  }

  // ==========================================================
  isComment(hNode) {
    var hInfo;
    hInfo = isHashComment(hNode.str);
    if (defined(hInfo)) {
      hNode._commentText = hInfo.text;
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  mapComment(hNode) {
    // --- default: remove comments
    // --- To keep comments, return "# #{hNode._commentText}"
    return undef;
  }

  // ==========================================================
  isCmd(hNode) {
    var _, argstr, cmd, lMatches, result;
    dbgEnter("Mapper.isCmd");
    if (defined(lMatches = hNode.str.match(/^\#([A-Za-z_]\w*)\s*(.*)$/))) { // name of the command
      // argstr for command
      [_, cmd, argstr] = lMatches;
      assert(cmd !== 'include', "#include found!");
      hNode.uobj = {cmd, argstr};
      result = true;
    } else {
      result = false;
    }
    dbgReturn("Mapper.isCmd", result);
    return result;
  }

  // ..........................................................
  // --- mapCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class mapCmd
  mapCmd(hNode) {
    var _, argstr, cmd, isEnv, lMatches, name, tail;
    dbgEnter("Mapper.mapCmd", hNode);
    // --- isCmd() put these keys here
    ({cmd, argstr} = hNode.uobj);
    assert(nonEmpty(cmd), "mapCmd() with empty cmd");
    switch (cmd) {
      case 'define':
        lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/); // name of the variable
        assert(defined(lMatches), `Bad #define cmd: ${cmd} ${argstr}`);
        [_, isEnv, name, tail] = lMatches;
        if (tail) {
          tail = tail.trim();
        }
        if (isEnv) {
          dbg(`set env var ${name} to '${tail}'`);
          process.env[name] = tail;
        } else {
          dbg(`set var ${name} to '${tail}'`);
          this.setConst(name, tail);
        }
        dbgReturn("Mapper.mapCmd", undef);
        return undef;
      default:
        return croak(`Unknown command: ${OL(cmd)}`);
    }
  }

};

// --- don't throw exception
//     check for unknown commands in visitCmd()
//				dbgReturn "Mapper.mapCmd", hNode.uobj
//				return hNode.uobj

// ===========================================================================
// --- mapper must be a subclass of Mapper or an array
//     of subclasses of Mapper.
export var map = function(input, mapperClass, options = undef) {
  var content, i, item, len, mapper, result;
  dbgEnter("map", input, mapperClass, options);
  // --- mapperClass can be an array - the input is processed
  //     by each array element sequentially
  if (isArray(mapperClass)) {
    dbg("mapperClass is an array - using each array element");
    content = input;
    dbg('original content', content);
    for (i = 0, len = mapperClass.length; i < len; i++) {
      item = mapperClass[i];
      if (defined(item)) {
        content = map(content, item, options);
        dbg('new content', content);
      }
    }
    dbgReturn("map", content);
    return content;
  }
  assert(isClass(mapperClass), "mapper not a constructor");
  mapper = new mapperClass(input);
  assert(mapper instanceof Mapper, "not a Mapper instance");
  result = mapper.getBlock(options);
  dbgReturn("map", result);
  return result;
};
