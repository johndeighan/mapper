// Generated by CoffeeScript 2.7.0
// Fetcher.coffee
import fs from 'fs';

import {
  LOG,
  LOGVALUE,
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  dbg,
  dbgEnter,
  dbgReturn,
  dbgYield,
  dbgResume
} from '@jdeighan/base-utils/debug';

import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  notdefined,
  escapeStr,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  indentLevel,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  arrayToBlock,
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  parseSource,
  slurp,
  isSimpleFileName,
  isDir,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

// ---------------------------------------------------------------------------
//   class Fetcher
//      - sets @hSourceInfo
//      - fetch(), unfetch()
//      - removes trailing WS from strings
//      - stops at __END__
//      - all() - generator
//      - fetchAll(), fetchBlock(), fetchUntil()
export var Fetcher = class Fetcher {
  constructor(source = undef, collection = undef, addLevel = 0) {
    var content;
    this.source = source;
    this.addLevel = addLevel;
    dbgEnter("Fetcher", this.source, collection, this.addLevel);
    assert(defined(this.source) || defined(collection), "NO SOURCE OR COLLECTION");
    if (this.source) {
      this.hSourceInfo = parseSource(this.source);
      dbg('hSourceInfo', this.hSourceInfo);
      assert(this.hSourceInfo.filename, "parseSource returned no filename");
    } else {
      dbg("No source, so filename is <unknown>");
      this.hSourceInfo = {
        filename: '<unknown>'
      };
    }
    this.altInput = undef;
    this.lineNum = 0;
    this.oneIndent = undef; // set from 1st line with indentation
    if (collection === undef) {
      dbg("No collection - check for fullpath");
      if (this.hSourceInfo.fullpath) {
        dbg(`slurping ${this.hSourceInfo.fullpath}`);
        content = slurp(this.hSourceInfo.fullpath);
        dbg('content', content);
        collection = blockToArray(content);
      } else {
        dbg("croaking");
        croak("no source or fullpath");
      }
    } else if (isString(collection)) {
      collection = blockToArray(collection);
      dbg("collection becomes", collection);
    }
    // --- collection must be iterable
    assert(isIterable(collection), "collection not iterable");
    this.iterator = collection[Symbol.iterator]();
    this.lLookAhead = []; // --- support unfetch()
    this.forcedEOF = false;
    this.init();
    dbgReturn("Fetcher");
  }

  // ..........................................................
  init() {}

  // ..........................................................
  sourceInfoStr() {
    var lParts;
    lParts = [];
    lParts.push(this.sourceStr());
    if (defined(this.altInput)) {
      lParts.push(this.altInput.sourceStr());
    }
    return lParts.join(' ');
  }

  // ..........................................................
  sourceStr() {
    return `${this.hSourceInfo.filename}/${this.lineNum}`;
  }

  // ..........................................................
  // --- returns hNode with keys:
  //        source
  //        lineNum
  //        str
  //        srcLevel - level in source code
  //        level    - includes added levels when #include'ing
  fetch() {
    var _, done, fname, hNode, lMatches, level, line, prefix, str;
    dbgEnter("Fetcher.fetch");
    if (defined(this.altInput)) {
      dbg("has altInput");
      hNode = this.altInput.fetch();
      // --- NOTE: hNode.str will never be #include
      //           because altInput's fetch would handle it
      if (defined(hNode)) {
        // --- NOTE: altInput was created knowing how many levels
        //           to add due to indentation in #include statement
        dbg("from alt");
        dbgReturn("Fetcher.fetch", hNode);
        return hNode;
      }
      // --- alternate input is exhausted
      this.altInput = undef;
      dbg("alt EOF");
    } else {
      dbg("there is no altInput");
    }
    // --- return anything in lLookAhead,
    //     even if @forcedEOF is true
    if (this.lLookAhead.length > 0) {
      hNode = this.lLookAhead.shift();
      assert(defined(hNode), "undef in lLookAhead");
      assert(!hNode.str.match(/^\#include\b/), `got ${OL(hNode)} from lLookAhead`);
      // --- NOTE: hNode.str will never be #include
      //           because anything that came from lLookAhead
      //           was put there by unfetch() which doesn't
      //           allow #include
      this.incLineNum(1);
      dbg("from lookahead");
      dbgReturn("Fetcher.fetch", hNode);
      return hNode;
    }
    dbg("no lookahead");
    if (this.forcedEOF) {
      dbg("forced EOF");
      dbgReturn("Fetcher.fetch", undef);
      return undef;
    }
    dbg("not at forced EOF");
    ({
      value: line,
      done
    } = this.iterator.next());
    dbg("iterator returned", {line, done});
    if (done) {
      dbg("iterator DONE");
      dbgReturn("Fetcher.fetch", undef);
      return undef;
    }
    assert(isString(line), `line is ${OL(line)}`);
    if (lMatches = line.match(/^(\s*)__END__$/)) {
      [_, prefix] = lMatches;
      assert(prefix === '', "__END__ should be at level 0");
      this.forceEOF();
      dbg("__END__");
      dbgReturn("Fetcher.fetch", undef);
      return undef;
    }
    this.incLineNum(1);
    [prefix, str] = splitPrefix(line);
    // --- Ensure that @oneIndent is set, if possible
    //     set level
    if (prefix === '') {
      level = 0;
    } else if (defined(this.oneIndent)) {
      level = indentLevel(prefix, this.oneIndent);
    } else {
      if (lMatches = prefix.match(/^\t+$/)) {
        this.oneIndent = "\t";
        level = prefix.length;
      } else {
        this.oneIndent = prefix;
        level = 1;
      }
    }
    assert(defined(this.oneIndent) || (prefix === ''), `Bad prefix ${OL(prefix)}`);
    // --- check for #include
    if (lMatches = str.match(/^\#include\b\s*(.*)$/)) {
      [_, fname] = lMatches;
      dbg(`#include ${fname}`);
      assert(nonEmpty(fname), "missing file name in #include");
      this.createAltInput(fname, level);
      hNode = this.fetch(); // recursive call
      dbgReturn("Fetcher.fetch", hNode);
      return hNode;
    }
    dbg("oneIndent", this.oneIndent);
    hNode = new Node(str, level + this.addLevel, this.sourceInfoStr(), this.lineNum);
    dbgReturn("Fetcher.fetch", hNode);
    return hNode;
  }

  // ..........................................................
  createAltInput(fname, level) {
    var dir, fullpath;
    dbgEnter("createAltInput", fname, level);
    // --- Make sure we have a simple file name
    assert(isString(fname), `not a string: ${OL(fname)}`);
    assert(isSimpleFileName(fname), `not a simple file name: ${OL(fname)}`);
    // --- Decide which directory to search for file
    dir = this.hSourceInfo.dir;
    if (dir) {
      assert(isDir(dir), `not a directory: ${OL(dir)}`);
    } else {
      dir = process.cwd(); // --- Use current directory
    }
    fullpath = pathTo(fname, dir);
    dbg("fullpath", fullpath);
    if (fullpath === undef) {
      croak(`Can't find include file ${fname} in dir ${dir}`);
    }
    assert(fs.existsSync(fullpath), `${fullpath} does not exist`);
    this.altInput = new Fetcher(fullpath, undef, level);
    dbgReturn("createAltInput");
  }

  // ..........................................................
  unfetch(hNode) {
    var lMatches;
    dbgEnter("Fetcher.unfetch", hNode);
    assert(hNode instanceof Node, `hNode is ${OL(hNode)}`);
    if (defined(this.altInput)) {
      dbg("has alt input");
      this.altInput.unfetch(hNode);
      dbg("alt input");
      dbgReturn("Fetcher.unfetch");
      return;
    }
    assert(defined(hNode), "hNode must be defined");
    lMatches = hNode.str.match(/^\#include\b/);
    assert(isEmpty(lMatches), "unfetch() of a #include");
    this.lLookAhead.unshift(hNode);
    this.incLineNum(-1);
    dbgReturn("Fetcher.unfetch");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    dbgEnter("Fetcher.incLineNum");
    this.lineNum += inc;
    dbgReturn("Fetcher.incLineNum");
  }

  // ..........................................................
  forceEOF() {
    dbgEnter("forceEOF");
    this.forcedEOF = true;
    dbgReturn("forceEOF");
  }

  // ..........................................................
  // --- GENERATOR
  * all() {
    var hNode;
    dbgEnter("Fetcher.all");
    while (defined(hNode = this.fetch())) {
      dbgYield("Fetcher.all", hNode);
      yield hNode;
      dbgResume("Fetcher.all");
    }
    dbgReturn("Fetcher.all");
  }

  // ..........................................................
  // --- GENERATOR
  * allUntil(func, endLineOption) {
    var hNode;
    // --- stop when func(hNode) returns true
    dbgEnter("Fetcher.allUntil", func, endLineOption);
    assert((endLineOption === 'keepEndLine') || (endLineOption === 'discardEndLine'), `bad end line option: ${OL(endLineOption)}`);
    assert(isFunction(func), "Arg 1 not a function");
    while (defined(hNode = this.fetch()) && !func(hNode)) {
      dbgYield("Fetcher.allUntil", hNode);
      yield hNode;
      dbgResume("Fetcher.allUntil");
    }
    if (defined(hNode) && (endLineOption === 'keepEndLine')) {
      this.unfetch(hNode);
    }
    dbgReturn("Fetcher.allUntil");
  }

  // ..........................................................
  // --- fetch a list of Nodes
  fetchAll() {
    var lNodes;
    dbgEnter("Fetcher.fetchAll");
    lNodes = Array.from(this.all());
    dbgReturn("Fetcher.fetchAll", lNodes);
    return lNodes;
  }

  // ..........................................................
  fetchUntil(func, endLineOption) {
    var hNode, lNodes, ref;
    dbgEnter("Fetcher.fetchUntil", func, endLineOption);
    assert((endLineOption === 'keepEndLine') || (endLineOption === 'discardEndLine'), `bad end line option: ${OL(endLineOption)}`);
    lNodes = [];
    ref = this.allUntil(func, endLineOption);
    for (hNode of ref) {
      lNodes.push(hNode);
    }
    dbgReturn("Fetcher.fetchUntil", lNodes);
    return lNodes;
  }

  // ..........................................................
  // --- fetch a block
  fetchBlock() {
    var lNodes, result;
    dbgEnter("Fetcher.fetchBlock");
    lNodes = Array.from(this.all());
    result = this.nodesToBlock(lNodes);
    dbgReturn("Fetcher.fetchBlock", result);
    return result;
  }

  // ..........................................................
  fetchBlockUntil(func, endLineOption) {
    var lNodes, result;
    dbgEnter("Fetcher.fetchBlockUntil");
    assert((endLineOption === 'keepEndLine') || (endLineOption === 'discardEndLine'), `bad end line option: ${OL(endLineOption)}`);
    lNodes = this.fetchUntil(func, endLineOption);
    result = this.nodesToBlock(lNodes);
    dbgReturn("Fetcher.fetchBlockUntil", result);
    return result;
  }

  // ..........................................................
  nodesToBlock(lNodes) {
    var hNode, i, lNewStrings, lStrings, len, line;
    lStrings = [];
    for (i = 0, len = lNodes.length; i < len; i++) {
      hNode = lNodes[i];
      line = hNode.getLine(this.oneIndent);
      assert(isString(line), `getLine() returned ${OL(line)}`);
      lStrings.push(line);
    }
    lNewStrings = undented(lStrings);
    assert(isArray(lNewStrings), `undented returned ${OL(lNewStrings)} when given ${OL(lStrings)}`);
    return arrayToBlock(lNewStrings);
  }

};
