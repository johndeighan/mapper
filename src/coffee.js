// Generated by CoffeeScript 2.7.0
// coffee.coffee
import CoffeeScript from 'coffeescript';

import {
  assert,
  croak,
  CWS,
  undef
} from '@jdeighan/coffee-utils';

import {
  log,
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  indentLevel
} from '@jdeighan/coffee-utils/indent';

export var convertingCoffee = true;

// ---------------------------------------------------------------------------
export var convertCoffee = function(flag) {
  convertingCoffee = flag;
};

// ---------------------------------------------------------------------------
export var coffeeExprToJS = function(coffeeExpr) {
  var err, jsExpr, pos;
  assert(indentLevel(coffeeExpr) === 0, "coffeeExprToJS(): has indentation");
  debug("enter coffeeExprToJS()");
  if (!convertingCoffee) {
    debug("return from coffeeExprToJS() not converting", coffeeExpr);
    return coffeeExpr;
  }
  try {
    jsExpr = CoffeeScript.compile(coffeeExpr, {
      bare: true
    }).trim();
    // --- Remove any trailing semicolon
    pos = jsExpr.length - 1;
    if (jsExpr.substr(pos, 1) === ';') {
      jsExpr = jsExpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, "coffeeExprToJS", coffeeExpr);
  }
  debug("return from coffeeExprToJS()", jsExpr);
  return jsExpr;
};

// ---------------------------------------------------------------------------
// --- Available options in hOptions:
//        bare: boolean   - compile without top-level function wrapper
//        header: boolean - include "Generated by CoffeeScript" comment
//        ast: boolean - include AST in return value
//        transpile - options object to use with Babel
//        sourceMap - generate a source map
//        filename - name of the source map file
//        inlineMap - generate source map inside the JS file
// ---------------------------------------------------------------------------
export var coffeeCodeToJS = function(coffeeCode, hOptions = {}) {
  var err, hCoffeeOptions, jsCode;
  assert(indentLevel(coffeeCode) === 0, "coffeeCodeToJS(): has indentation");
  debug("enter coffeeCodeToJS()", coffeeCode);
  if (!convertingCoffee) {
    debug("return from coffeeCodeToJS() not converting", coffeeCode);
    return coffeeCode;
  }
  hCoffeeOptions = hOptions.hCoffeeOptions;
  if (!hCoffeeOptions) {
    hCoffeeOptions = {
      bare: true,
      header: false
    };
  }
  try {
    // --- cleanJS() does:
    //        1. remove blank lines
    //        2. remove trailing newline
    jsCode = cleanJS(CoffeeScript.compile(coffeeCode, hCoffeeOptions));
  } catch (error) {
    err = error;
    croak(err, "Original Code", coffeeCode);
  }
  debug("return from coffeeCodeToJS()", jsCode);
  return jsCode;
};

// ---------------------------------------------------------------------------
export var coffeeCodeToAST = function(coffeeCode) {
  var ast, err;
  assert(indentLevel(coffeeCode) === 0, "coffeeCodeToAST(): has indentation");
  debug("enter coffeeCodeToAST()", coffeeCode);
  try {
    ast = CoffeeScript.compile(coffeeCode, {
      ast: true
    });
    assert(ast != null, "coffeeCodeToAST(): ast is empty");
  } catch (error) {
    err = error;
    croak(err, "in coffeeCodeToAST", coffeeCode);
  }
  debug("return from coffeeCodeToAST()", ast);
  return ast;
};

// ---------------------------------------------------------------------------
export var cleanJS = function(jsCode) {
  jsCode = jsCode.replace(/\n\n+/gs, "\n");
  jsCode = jsCode.replace(/\n$/s, '');
  return jsCode;
};

// ---------------------------------------------------------------------------
export var minifyJS = function(jsCode, lParms) {
  jsCode = CWS(jsCode);
  jsCode = jsCode.replace(/,\s+/, ',');
  return jsCode;
};
