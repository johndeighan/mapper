// Generated by CoffeeScript 2.7.0
// ASTWalker.coffee
var ASTBase;

import {
  assert,
  undef,
  pass,
  croak,
  isArray,
  isHash,
  isArrayOfHashes
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  isBuiltin
} from '@jdeighan/mapper/builtins';

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
ASTBase = class ASTBase {
  constructor(tree1, hStdKeys = {}) {
    this.tree = tree1;
    debug("enter ASTBase()", hStdKeys);
    // --- tree can be a hash or array of hashes
    if (isHash(this.tree)) {
      debug("tree was hash - constructing list from it");
      this.tree = [this.tree];
    }
    assert(isArrayOfHashes(this.tree), "new ASTBase: Bad tree");
    // --- @hStdKeys allows you to provide an alternate name for 'subtree'
    //     Ditto for 'node', but if the 'node' key exists, but is
    //        set to undef, the tree is assumed to NOT use user nodes
    this.hStdKeys = {};
    if (hStdKeys.subtree != null) {
      assert(hStdKeys.subtree, "empty subtree key");
      this.hStdKeys.subtree = hStdKeys.subtree;
    } else {
      this.hStdKeys.subtree = 'subtree';
    }
    if (hStdKeys.node != null) {
      this.hStdKeys.node = hStdKeys.node;
    } else {
      this.hStdKeys.node = 'node'; // --- if set to undef, leave it alone
    }
    debug("return from ASTBase()", this.hStdKeys);
  }

  // ..........................................................
  // --- Called after walk() completes
  //     Override to have walk() return some result
  getResult() {
    return undef;
  }

  // ..........................................................
  walk() {
    var result;
    debug("enter ASTBase.walk()");
    this.walkNodes(this.tree, 0);
    result = this.getResult();
    debug("return from ASTBase.walk()", result);
    return result;
  }

  // ..........................................................
  walkNodes(lNodes, level) {
    var i, len, node;
    debug("enter walkNodes()", lNodes);
    for (i = 0, len = lNodes.length; i < len; i++) {
      node = lNodes[i];
      this.walkNode(node, level);
    }
    debug("return from walkNodes()");
  }

  // ..........................................................
  walkSubTrees(lSubTrees, level) {
    var i, len, subtree;
    if ((lSubTrees == null) || (lSubTrees.length === 0)) {
      return;
    }
    for (i = 0, len = lSubTrees.length; i < len; i++) {
      subtree = lSubTrees[i];
      if (subtree != null) {
        if (isArray(subtree)) {
          this.walkNodes(subtree, level);
        } else if (isHash(subtree)) {
          this.walkNode(subtree, level);
        } else {
          croak("Invalid subtree", 'SUBTREE', subtree);
        }
      }
    }
  }

  // ..........................................................
  walkNode(superNode, level) {
    var key, lSubTrees, node, subkey;
    debug("enter walkNode()");
    key = this.hStdKeys.node;
    subkey = this.hStdKeys.subtree;
    debug(`KEYS: '${key}', '${subkey}'`);
    node = superNode;
    if (key && (superNode[key] != null)) {
      debug(`found node under key '${key}'`);
      node = superNode[key];
    }
    // --- give visit() method chance to provide list of subtrees
    lSubTrees = this.visit(node, superNode, level);
    if (lSubTrees != null) {
      debug("visit() returned subtrees", lSubTrees);
      this.walkSubTrees(lSubTrees, level + 1);
    } else {
      this.walkSubTrees(superNode[subkey], level + 1);
    }
    this.endVisit(node, superNode, level);
    debug("return from walkNode()");
  }

  // ..........................................................
  // --- return lSubTrees, if any
  visit(node, hInfo, level) {
    debug("enter visit() - std");
    // --- automatically visit subtree if it exists
    debug("return from visit() - std");
    return undef;
  }

  // ..........................................................
  // --- called after all subtrees have been visited
  endVisit(node, hInfo, level) {}

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var ASTWalker = class ASTWalker extends ASTBase {
  constructor(ast) {
    super(ast.program, {
      subtree: 'body',
      node: undef
    });
    this.ast = ast.program;
    this.lImportedSymbols = [];
    this.lUsedSymbols = [];
    // --- subarrays start out as list of formal parameters
    //     to which are added locally assigned variables
    this.lLocalSymbols = [[]];
  }

  // ..........................................................
  isLocalSymbol(name) {
    var i, len, ref, subarray;
    ref = this.lLocalSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      subarray = ref[i];
      if (subarray.includes(name)) {
        return true;
      }
    }
    return false;
  }

  // ..........................................................
  addImport(name, lib) {
    assert(name, "addImport: empty name");
    if (this.lImportedSymbols.includes(name)) {
      croak(`Duplicate import: ${name}`);
    } else {
      this.lImportedSymbols.push(name);
    }
  }

  // ..........................................................
  addUsedSymbol(name, value = {}) {
    assert(name, "addUsedSymbol(): empty name");
    if (!this.isLocalSymbol(name) && !this.lUsedSymbols.includes(name)) {
      this.lUsedSymbols.push(name);
    }
  }

  // ..........................................................
  addLocalSymbol(name) {
    var lSymbols;
    assert(this.lLocalSymbols.length > 0, "no lLocalSymbols");
    lSymbols = this.lLocalSymbols[this.lLocalSymbols.length - 1];
    lSymbols.push(name);
  }

  // ..........................................................
  visit(node, hInfo, level) {
    var add, hSpec, i, importKind, imported, j, lNames, lSubTrees, len, len1, lib, local, name, param, parm, ref, source, specifiers, type;
    // --- add to local vars & formal params, where appropriate
    switch (node.type) {
      case 'Identifier':
        // --- Identifiers that are not local vars or formal params
        //     are symbols that should be imported
        name = node.name;
        if (!this.isLocalSymbol(name)) {
          this.addUsedSymbol(name);
        }
        return;
      case 'ImportDeclaration':
        ({specifiers, source, importKind} = node);
        if ((importKind === 'value') && (source.type === 'StringLiteral')) {
          lib = source.value; // e.g. '@jdeighan/coffee-utils'
          for (i = 0, len = specifiers.length; i < len; i++) {
            hSpec = specifiers[i];
            ({type, imported, local, importKind} = hSpec);
            if ((type === 'ImportSpecifier') && (imported != null) && (imported.type === 'Identifier')) {
              this.addImport(imported.name, lib);
            }
          }
        }
        return;
      case 'CatchClause':
        param = node.param;
        if ((param != null) && param.type === 'Identifier') {
          this.lLocalSymbols.push(param.name);
        }
        break;
      case 'FunctionExpression':
        lNames = [];
        ref = node.params;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          parm = ref[j];
          if (parm.type === 'Identifier') {
            lNames.push(parm.name);
          }
        }
        this.lLocalSymbols.push(lNames);
        break;
      case 'For':
        lNames = [];
        if ((node.name != null) && (node.name.type === 'Identifier')) {
          lNames.push(node.name.name);
        }
        if ((node.index != null) && (node.name.type === 'Identifier')) {
          lNames.push(node.index.name);
        }
        this.lLocalSymbols.push(lNames);
        break;
      case 'AssignmentExpression':
        if (node.left.type === 'Identifier') {
          this.addLocalSymbol(node.left.name);
        }
        break;
      case 'AssignmentPattern':
        if (node.left.type === 'Identifier') {
          this.addLocalSymbol(node.left.name);
        }
    }
    // --- Build and return array of subtrees
    lSubTrees = [];
    add = function(...subtrees) {
      return lSubTrees.push(...subtrees);
    };
    switch (node.type) {
      case 'AssignmentExpression':
        add(node.left, node.right);
        break;
      case 'AssignmentPattern':
        add(node.left, node.right);
        break;
      case 'BinaryExpression':
        add(node.left, node.right);
        break;
      case 'BlockStatement':
        add(node.body);
        break;
      case 'CallExpression':
        add(node.callee, node.arguments);
        break;
      case 'CatchClause':
        add(node.body);
        break;
      case 'ClassDeclaration':
        add(node.body);
        break;
      case 'ClassBody':
        add(node.body);
        break;
      case 'ClassMethod':
        add(node.body);
        break;
      case 'ExpressionStatement':
        add(node.expression);
        break;
      case 'For':
        add(node.body, node.source);
        break;
      case 'FunctionExpression':
        add(node.params, node.body);
        break;
      case 'IfStatement':
        add(node.test, node.consequent);
        break;
      case 'MemberExpression':
        add(node.object);
        break;
      case 'Program':
        add(node.body);
        break;
      case 'SwitchCase':
        add(node.test, node.consequent);
        break;
      case 'SwitchStatement':
        add(node.cases);
        break;
      case 'TryStatement':
        add(node.block, node.handler, node.finalizer);
        break;
      case 'WhileStatement':
        add(node.test, node.body);
    }
    return lSubTrees;
  }

  // ..........................................................
  endVisit(node, level) {
    // --- Called after the node's entire subtree has been walked
    switch (node.type) {
      case 'FunctionExpression':
      case 'For':
      case 'CatchClause':
        this.lLocalSymbols.pop();
    }
  }

  // ..........................................................
  getSymbols() {
    var hResult, i, lNeededSymbols, len, name, ref;
    debug("enter CodeWalker.getSymbols()");
    this.lImportedSymbols = []; // filled in during walking
    this.lUsedSymbols = []; // filled in during walking
    debug("walking");
    this.walk();
    debug("done walking");
    lNeededSymbols = [];
    ref = this.lUsedSymbols;
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      if (!this.lImportedSymbols.includes(name) && !isBuiltin(name)) {
        lNeededSymbols.push(name);
      }
    }
    hResult = {
      lImported: this.lImportedSymbols,
      lUsed: this.lUsedSymbols,
      lNeeded: lNeededSymbols
    };
    debug("return from CodeWalker.getSymbols()", hResult);
    return hResult;
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
export var TreeStringifier = class TreeStringifier extends ASTBase {
  constructor(tree, hStdKeys = {}) {
    debug("enter TreeStringifier()", tree);
    super(tree, hStdKeys); // sets @tree
    this.lLines = [];
    debug("return from TreeStringifier()");
  }

  // ..........................................................
  visit(node, hInfo, level) {
    var str;
    assert(node != null, "TreeStringifier.visit(): empty node");
    debug("enter TreeStringifier.visit()");
    str = indented(this.stringify(node), level);
    debug(`stringified: '${str}'`);
    this.lLines.push(str);
    debug("return from TreeStringifier.visit()");
    return undef;
  }

  // ..........................................................
  get() {
    var result;
    debug("enter TreeStringifier.get()");
    this.walk();
    result = this.lLines.join('\n');
    debug("return from TreeStringifier.get()");
    return result;
  }

  // ..........................................................
  excludeKey(key) {
    return key === this.hStdKeys.subtree;
  }

  // ..........................................................
  // --- override this
  stringify(node) {
    var key, newnode, value;
    assert(isHash(node), `TreeStringifier.stringify(): node '${node}' is not a hash`);
    newnode = {};
    for (key in node) {
      value = node[key];
      if (!this.excludeKey(key)) {
        newnode[key] = node[key];
      }
    }
    return JSON.stringify(newnode);
  }

};
