// Generated by CoffeeScript 2.7.0
// Fetcher.coffee
import fs from 'fs';

import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  escapeStr,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  arrayToBlock,
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  LOG,
  DEBUG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  parseSource,
  slurp,
  isSimpleFileName,
  isDir,
  pathTo
} from '@jdeighan/coffee-utils/fs';

// ---------------------------------------------------------------------------
//   class Fetcher
//      - sets @hSourceInfo
//      - fetch(), unfetch()
//      - removes trailing WS from strings
//      - stops at __END__
//      - valid options:
//           prefix - prepend this prefix when fetching
//      - all() - generator
//      - fetchAll(), fetchBlock(), fetchUntil()
export var Fetcher = class Fetcher {
  constructor(source = undef, collection = undef, hOptions = {}) {
    var content;
    this.source = source;
    debug(`enter Fetcher(${OL(this.source)})`, collection);
    if (this.source) {
      this.hSourceInfo = parseSource(this.source);
      debug('hSourceInfo', this.hSourceInfo);
      assert(this.hSourceInfo.filename, "parseSource returned no filename");
    } else {
      this.hSourceInfo = {
        filename: '<unknown>'
      };
    }
    this.altInput = undef;
    this.lineNum = 0;
    this.oneIndent = undef; // set from 1st line with indentation
    if (hOptions.prefix != null) {
      this.hSourceInfo.prefix = hOptions.prefix;
    }
    if (collection === undef) {
      if (this.hSourceInfo.fullpath) {
        content = slurp(this.hSourceInfo.fullpath);
        debug('content', content);
        collection = blockToArray(content);
      } else {
        croak("no source or fullpath");
      }
    } else if (isString(collection)) {
      collection = blockToArray(collection);
      debug("collection becomes", collection);
    }
    // --- collection must be iterable
    assert(isIterable(collection), "collection not iterable");
    this.iterator = collection[Symbol.iterator]();
    this.lLookAhead = []; // --- support unfetch()
    this.forcedEOF = false;
    if (defined(hOptions.prefix)) {
      this.prefix = hOptions.prefix;
    } else {
      this.prefix = '';
    }
    debug('prefix', this.prefix);
    this.init();
    debug("return from Fetcher()");
  }

  // ..........................................................
  pathTo(fname) {
    // --- fname must be a simple file name
    // --- returns a relative path
    //     searches from @hSourceInfo.dir || process.cwd()
    //     searches downward
    assert(isSimpleFileName(fname), "fname must not be a path");
    return pathTo(fname, this.hSourceInfo.dir, {
      relative: true
    });
  }

  // ..........................................................
  init() {}

  // ..........................................................
  sourceInfoStr() {
    var lParts;
    lParts = [];
    lParts.push(this.sourceStr());
    if (defined(this.altInput)) {
      lParts.push(this.altInput.sourceStr());
    }
    return lParts.join(' ');
  }

  // ..........................................................
  sourceStr() {
    return `${this.hSourceInfo.filename}/${this.lineNum}`;
  }

  // ..........................................................
  // --- returns hLine with keys:
  //        line
  //        source
  //        lineNum
  // --- if line is a string:
  //        prefix
  //        str
  //        srcLevel
  //        level
  fetch() {
    var _, done, fname, hLine, lMatches, level, line, prefix, str, value;
    debug(`enter Fetcher.fetch() from ${this.hSourceInfo.filename}`);
    if (defined(this.altInput)) {
      debug("has altInput");
      hLine = this.altInput.fetch();
      // --- NOTE: hLine.line will never be #include
      //           because altInput's fetch would handle it
      if (defined(hLine)) {
        debug("return from Fetcher.fetch() - alt", hLine);
        return hLine;
      }
      // --- alternate input is exhausted
      this.altInput = undef;
      debug("alt EOF");
    } else {
      debug("there is no altInput");
    }
    // --- return anything in lLookAhead,
    //     even if @forcedEOF is true
    if (this.lLookAhead.length > 0) {
      hLine = this.lLookAhead.shift();
      // --- NOTE: hLine.line will never be #include
      //           because anything that came from lLookAhead
      //           was put there by unfetch() which doesn't
      //           allow #include
      assert(defined(hLine), "undef in lLookAhead");
      this.incLineNum(1);
      debug("return from Fetcher.fetch() - lookahead", hLine);
      return hLine;
    }
    debug("no lookahead");
    if (this.forcedEOF) {
      debug("return from Fetcher.fetch() - forced EOF", undef);
      return undef;
    }
    debug("not at forced EOF");
    ({value, done} = this.iterator.next());
    line = value;
    debug("iterator returned", {line, done});
    if (done) {
      debug("return from Fetcher.fetch() - iterator DONE", undef);
      return undef;
    }
    if (line === '__END__') {
      this.forceEOF();
      debug("return from Fetcher.fetch() - __END__", undef);
      return undef;
    }
    this.incLineNum(1);
    // --- this object is returned at the end
    hLine = {
      line,
      lineNum: this.lineNum,
      source: this.sourceInfoStr()
    };
    if (isString(line)) {
      line = rtrim(line); // remove trailing whitespace
      
      // --- check for #include
      if (lMatches = line.match(/(\s*)\#include\b\s*(.*)$/)) { // prefix
        [_, prefix, fname] = lMatches;
        debug(`#include ${fname} with prefix '${OL(prefix)}'`);
        assert(nonEmpty(fname), "missing file name in #include");
        this.createAltInput(fname, prefix);
        hLine = this.fetch(); // recursive call
        debug("return from Fetcher.fetch()", hLine);
        return hLine;
      }
      // --- Check if we're adding a prefix to each line
      if (this.prefix.length > 0) {
        line = this.prefix + line;
      }
      [prefix, str] = splitPrefix(line);
      if (defined(this.oneIndent)) {
        level = indentLevel(line, this.oneIndent);
      } else if (prefix === '') {
        level = 0;
      } else if (lMatches = prefix.match(/^\t+$/)) {
        this.oneIndent = "\t";
        level = lMatches[0].length;
      } else {
        level = 1;
        this.oneIndent = prefix;
      }
      hLine.line = line; // trimmed version
      hLine.prefix = prefix;
      hLine.str = str;
      hLine.srcLevel = level;
      hLine.level = level;
    }
    debug("return from Fetcher.fetch()", hLine);
    return hLine;
  }

  // ..........................................................
  createAltInput(fname, prefix = '') {
    var dir, fullpath;
    debug(`enter createAltInput('${fname}', '${escapeStr(prefix)}')`);
    // --- Make sure we have a simple file name
    assert(isString(fname), `not a string: ${OL(fname)}`);
    assert(isSimpleFileName(fname), `not a simple file name: ${OL(fname)}`);
    // --- Decide which directory to search for file
    dir = this.hSourceInfo.dir;
    if (dir) {
      assert(isDir(dir), `not a directory: ${OL(dir)}`);
    } else {
      dir = process.cwd(); // --- Use current directory
    }
    fullpath = pathTo(fname, dir);
    debug("fullpath", fullpath);
    if (fullpath === undef) {
      croak(`Can't find include file ${fname} in dir ${dir}`);
    }
    assert(fs.existsSync(fullpath), `${fullpath} does not exist`);
    this.altInput = new Fetcher(fullpath, undef, {prefix});
    debug("return from createAltInput()");
  }

  // ..........................................................
  unfetch(hLine) {
    var lMatches, line;
    debug("enter Fetcher.unfetch()", hLine);
    assert(defined(hLine), "hLine must be defined");
    ({line} = hLine);
    if (isString(line)) {
      lMatches = line.match(/^\s*\#include\b/);
      assert(isEmpty(lMatches), "unfetch() of a #include");
    }
    if (defined(this.altInput)) {
      debug("has alt input");
      this.altInput.unfetch(hLine);
      this.incLineNum(-1);
      debug("return from Fetcher.unfetch() - alt");
      return;
    }
    this.lLookAhead.unshift(hLine);
    this.incLineNum(-1);
    debug("return from Fetcher.unfetch()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    this.lineNum += inc;
  }

  // ..........................................................
  forceEOF() {
    debug("enter forceEOF()");
    this.forcedEOF = true;
    debug("return from forceEOF()");
  }

  // ..........................................................
  // --- a generator
  * all() {
    var hLine;
    debug("enter Fetcher.all()");
    while (defined(hLine = this.fetch())) {
      debug("GOT", hLine);
      yield hLine;
    }
    debug("GOT", hLine);
    debug("return from Fetcher.all()");
  }

  // ..........................................................
  fetchAll() {
    var hLine, lLines, ref;
    debug("enter Fetcher.fetchAll()");
    lLines = [];
    ref = this.all();
    for (hLine of ref) {
      lLines.push(hLine);
    }
    debug("return from Fetcher.fetchAll()", lLines);
    return lLines;
  }

  // ..........................................................
  fetchUntil(end) {
    var hLine, lLines;
    debug("enter Fetcher.fetchUntil()");
    lLines = [];
    while (defined(hLine = this.fetch()) && (hLine.line !== end)) {
      lLines.push(hLine);
    }
    debug("return from Fetcher.fetchUntil()", lLines);
    return lLines;
  }

  // ..........................................................
  fetchBlock() {
    var block, hLine, lStrings, ref;
    debug("enter Fetcher.fetchBlock()");
    lStrings = [];
    ref = this.all();
    for (hLine of ref) {
      assert(isString(hLine.line), `fetchBlock(): non-string ${OL(hLine.line)}`);
      lStrings.push(hLine.line);
    }
    debug('lStrings', lStrings);
    block = arrayToBlock(lStrings);
    debug("return from Fetcher.fetchBlock()", block);
    return block;
  }

};
