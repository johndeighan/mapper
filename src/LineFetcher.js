// Generated by CoffeeScript 2.7.0
// LineFetcher.coffee
import fs from 'fs';

import {
  undef,
  assert,
  croak,
  OL,
  escapeStr,
  isEmpty,
  isFunction,
  isString,
  isArray
} from '@jdeighan/coffee-utils';

import {
  indented,
  undented,
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  DEBUG,
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  blockToArray,
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  slurp,
  parseSource,
  isSimpleFileName,
  isDir,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
//   class LineFetcher - stream in lines from a string
//       handles:
//          __END__
//          #include
export var LineFetcher = class LineFetcher {
  constructor(source, content = undef) {
    this.setContent(source, content);
    // --- for handling #include
    this.altInput = undef;
    this.altLevel = undef; // indentation added to lines from alt
    
    // --- unfetch() puts things in here
    //     fetch() checks first if something is available here
    this.lookahead = new Getter();
  }

  // ..........................................................
  setContent(source, content) {
    // --- source should be a file path or a URL
    //     content should be block or a generator
    //     if content is empty, it will be read in using source
    debug(`enter setContent(source='${source}')`, content);
    // --- @hSourceInfo has keys: dir, filename, stub, ext, fullpath
    //     source may be a URL, e.g. import.meta.url
    this.hSourceInfo = parseSource(source);
    this.filename = this.hSourceInfo.filename;
    assert(this.filename, "LineFetcher: parseSource returned no filename");
    if (content == null) {
      if (this.hSourceInfo.fullpath) {
        content = slurp(this.hSourceInfo.fullpath);
        this.getter = new Getter(blockToArray(content));
      } else {
        croak("LineFetcher(): no source or fullpath");
      }
    } else if (isEmpty(content)) {
      this.getter = new Getter([]);
    } else if (isFunction(content)) {
      this.getter = new Getter(content()); // content is a generator
    } else if (isString(content)) {
      this.getter = new Getter(blockToArray(content));
    } else if (isArray(content)) {
      this.getter = new Getter(content);
    } else {
      croak("LineFetcher(): content must be a string or array", "CONTENT", content);
    }
    this.lineNum = 0;
    debug("return from setContent()");
  }

  // ..........................................................
  getIncludeFileFullPath(fname) {
    var dir, path;
    debug(`enter getIncludeFileFullPath('${fname}')`);
    // --- Make sure we have a simple file name
    assert(isSimpleFileName(fname), "getIncludeFileFullPath(): not a simple file name");
    // --- Decide which directory to search for file
    dir = this.hSourceInfo.dir;
    if (!dir || !isDir(dir)) {
      // --- Use current directory
      dir = process.cwd();
    }
    path = pathTo(fname, dir);
    debug("path", path);
    if (path) {
      assert(fs.existsSync(path), "path does not exist");
      debug("return from getIncludeFileFullPath()");
      return path;
    } else {
      debug("return from getIncludeFileFullPath() - file not found");
      return undef;
    }
  }

  // ..........................................................
  // --- Can override to add additional functionality
  incLineNum(inc) {
    this.lineNum += inc;
  }

  // ..........................................................
  fetch(literal = false) {
    var _, contents, fname, includePath, lMatches, line, prefix, result;
    // --- literal = true means don't handle #include,
    //               just return it as is
    debug(`enter fetch(literal=${literal}) from ${this.filename}`);
    if (!this.lookahead.eof()) {
      result = this.lookahead.get();
      this.incLineNum(1);
      debug(`return ${OL(result)} from fetch() - lookahead`);
      return result;
    }
    if (this.altInput) {
      assert(this.altLevel != null, "fetch(): alt input without alt level");
      line = this.altInput.fetch(literal);
      if (line != null) {
        result = indented(line, this.altLevel);
        this.incLineNum(1);
        debug(`return ${OL(result)} from fetch() - alt`);
        return result;
      } else {
        // --- alternate input is exhausted
        this.altInput = undef;
      }
    }
    if (this.getter.eof()) {
      debug("return undef from fetch() - at EOF");
      return undef;
    }
    // --- Not at EOF
    line = this.getter.get();
    if (line === '__END__') {
      this.getter.forceEOF();
      debug("return from fetch() - __END__ seen");
      return undef;
    }
    this.incLineNum(1);
    if (!literal && (lMatches = line.match(/^(\s*)\#include\s+(\S.*)$/))) {
      [_, prefix, fname] = lMatches;
      fname = fname.trim();
      debug(`#include ${fname} with prefix ${OL(prefix)}`);
      assert(!this.altInput, "fetch(): altInput already set");
      includePath = this.getIncludeFileFullPath(fname);
      if (includePath == null) {
        croak(`Can't find include file ${fname} anywhere`);
      }
      contents = slurp(includePath);
      this.altInput = new LineFetcher(fname, contents);
      this.altLevel = indentLevel(prefix);
      debug(`alt input created with prefix ${OL(prefix)}`);
      line = this.altInput.fetch();
      debug(`first #include line found = '${escapeStr(line)}'`);
      if (line != null) {
        result = indented(line, this.altLevel);
      } else {
        result = this.fetch(); // recursive call
      }
      debug(`return ${OL(result)} from fetch()`);
      return result;
    } else {
      debug(`return ${OL(line)} from fetch()`);
      return line;
    }
  }

  // ..........................................................
  // --- Put a line back, to be fetched later
  unfetch(line) {
    debug(`enter unfetch(${OL(line)})`);
    assert(isString(line), "unfetch(): not a string");
    this.lookahead.unget(line);
    this.incLineNum(-1);
    debug('return from unfetch()');
  }

  // ..........................................................
  getBlock() {
    var block, lLines, line;
    debug("enter LineFetcher.getBlock()");
    lLines = (function() {
      var results;
      results = [];
      while ((line = this.fetch()) != null) {
        assert(isString(line), `getBlock(): got non-string '${OL(line)}'`);
        results.push(line);
      }
      return results;
    }).call(this);
    block = arrayToBlock(lLines);
    debug("return from LineFetcher.getBlock()", block);
    return block;
  }

};
