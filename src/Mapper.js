// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
//   class Mapper
//       handles:
//          #include
//          #define
//          const replacement
export var Mapper = class Mapper extends Getter {
  constructor(source = undef, collection = undef, hOptions = {}) {
    debug("enter Mapper()");
    super(source, collection, hOptions);
    // --- These never change
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    // --- This needs to be kept updated
    this.setConst('LINE', this.lineNum);
    this.hSpecials = {};
    this.lSpecials = []; // checked in this order
    
    // --- These must be bound to a specific object when called
    this.registerSpecialType('empty', this.isEmptyLine, this.mapEmptyLine);
    this.registerSpecialType('comment', this.isComment, this.mapComment);
    this.registerSpecialType('cmd', this.isCmd, this.mapCmd);
    debug("return from Mapper()");
  }

  // ..........................................................
  registerSpecialType(type, recognizer, handler) {
    if (!this.lSpecials.includes(type)) {
      this.lSpecials.push(type);
    }
    this.hSpecials[type] = {recognizer, handler};
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    debug(`enter incLineNum(${inc})`);
    super.incLineNum(inc);
    this.setConst('LINE', this.lineNum);
    debug("return from incLineNum()");
  }

  // ..........................................................
  // --- override
  //     LATER: maintain an ordered hash of types along with
  //            methods to check for those types
  getItemType(hLine) {
    var i, len, line, recognizer, ref, str, type;
    debug("enter Mapper.getItemType()", hLine);
    super.getItemType(hLine); // sets 'prefix' and 'str' for strings
    ({line, str} = hLine);
    if (isString(line)) {
      assert(isString(str), `str is ${OL(str)}`);
      ref = this.lSpecials;
      for (i = 0, len = ref.length; i < len; i++) {
        type = ref[i];
        recognizer = this.hSpecials[type].recognizer;
        if (recognizer.bind(this)(str, hLine)) {
          debug("return from getItemType()", type);
          return type;
        }
      }
    }
    debug("return from getItemType()", undef);
    return undef;
  }

  // ..........................................................
  mapItemType(type, hLine) {
    var h, handler, uobj;
    debug("enter Mapper.mapItemType()", type, hLine);
    assert(isHash(hLine), `hLine is ${OL(hLine)}`);
    assert(hLine.type === type, `hLine is ${OL(hLine)}`);
    h = this.hSpecials[type];
    assert(isHash(h), `Unknown type ${OL(type)}`);
    handler = h.handler.bind(this);
    assert(isFunction(handler), `Bad handler for ${OL(type)}`);
    uobj = handler(hLine);
    debug("return from Mapper.mapItemType()", uobj);
    return uobj;
  }

  // ..........................................................
  isEmptyLine(str, hLine) {
    return str === '';
  }

  // ..........................................................
  isComment(str, hLine) {
    var _, comment, lMatches;
    if (lMatches = str.match(/^\s*\#(?:\s+(.*))?$/)) { // a hash character
      [_, comment] = lMatches;
      hLine.comment = comment;
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  isCmd(str, hLine) {
    var _, argstr, cmd, flag, lMatches;
    debug("enter Mapper.isCmd()");
    if (lMatches = str.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, cmd, argstr] = lMatches;
      hLine.cmd = cmd;
      hLine.argstr = argstr;
      flag = true;
    } else {
      // --- not a command
      flag = false;
    }
    debug("return from Mapper.isCmd()", flag);
    return flag;
  }

  // ..........................................................
  mapEmptyLine(hLine) {
    // --- can override
    //     line may contain whitespace

    // --- return '' to keep empty lines
    return undef;
  }

  // ..........................................................
  mapComment(hLine) {
    debug("in Mapper.mapComment()");
    // --- return undef to remove comments
    return hLine.line;
  }

  // ..........................................................
  // --- mapCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class mapCmd
  mapCmd(hLine) {
    var _, argstr, cmd, isEnv, lMatches, name, tail;
    debug("enter Mapper.mapCmd()", hLine);
    // --- isCmd() put these keys here
    ({cmd, argstr} = hLine);
    // --- Each case should return
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, isEnv, name, tail] = lMatches;
          if (tail) {
            tail = tail.trim();
          }
          if (isEnv) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setConst(name, tail);
          }
        }
        debug("return from Mapper.mapCmd()", undef);
        return undef;
      default:
        croak(`Unknown command: #${cmd}`);
    }
    return croak("Not all cases return");
  }

};

// ===========================================================================
export var doMap = function(inputClass, source, content = undef, hOptions = {}) {
  var oInput, result;
  // --- Valid options:
  //        logLines
  debug("enter doMap()", inputClass, source, content);
  assert(inputClass != null, "Missing input class");
  oInput = new inputClass(source, content);
  assert(oInput instanceof Mapper, "doMap() requires a Mapper or subclass");
  debug("got oInput object");
  result = oInput.getBlock(hOptions);
  debug("return from doMap()", result);
  return result;
};
