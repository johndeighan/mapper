// Generated by CoffeeScript 2.7.0
  // Fetcher.coffee
import {
  assert
} from '@jdeighan/base-utils/exceptions';

import {
  isString,
  isNonEmptyString,
  isInteger,
  isHash,
  isIterable,
  isFunction,
  isEmpty,
  nonEmpty,
  getOptions,
  toArray,
  toBlock,
  undef,
  defined,
  notdefined,
  rtrim,
  OL
} from '@jdeighan/base-utils';

import {
  dbg,
  dbgEnter,
  dbgReturn,
  dbgYield,
  dbgResume
} from '@jdeighan/base-utils/debug';

import {
  slurp
} from '@jdeighan/base-utils/fs';

import {
  indentLevel,
  splitLine,
  splitPrefix,
  getOneIndent,
  undented,
  isUndented
} from '@jdeighan/coffee-utils/indent';

import {
  parseSource
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

// ---------------------------------------------------------------------------
// 1. implement fetch() and peek()
// 2. handle extension lines
// 3. implement fetchLinesAtLevel(level)
// 4. define extSep(str, nextStr) - to override
// 5. implement generator allNodes()
// 6. define procNode() - to override
// 7. implement getBlock(oneIndent)
// 8. define finalizeBlock() - to override
export var Fetcher = class Fetcher {
  constructor(hInput, options = {}) {
    var addLevel, content, fullpath, noLevels, source;
    // --- Valid options:
    //        addLevel - num of levels to add to each line
    //                   unless the line is empty
    //        noLevels - any line with indentation is continuation line
    dbgEnter("Fetcher", hInput, options);
    // --- hInput can be:
    //        1. a plain string
    //        2. a hash with keys 'source' and/or 'content',
    //        3. an iterator

      // --- We need to set:
    //        @hSourceInfo - information about the source of input
    //        @iterator    - must be an iterator

      // --- Handle options
    ({addLevel, noLevels} = getOptions(options));
    this.addLevel = addLevel || 0;
    this.noLevels = !!noLevels;
    if (this.addLevel > 0) {
      dbg(`add ${this.addLevel} levels`);
    }
    if (isString(hInput)) {
      dbg("string passed as hInput");
      this.hSourceInfo = {
        filename: '<unknown>'
      };
      content = toArray(hInput);
      this.iterator = content[Symbol.iterator]();
      dbg(`iterator is an array with ${content.length} items`);
    } else if (isHash(hInput)) {
      dbg("hash passed as hInput");
      ({source, content} = hInput);
      assert(defined(source) || defined(content), "No source or content");
      if (defined(source)) {
        this.hSourceInfo = parseSource(source);
      } else {
        dbg("No source, so filename is <unknown>");
        this.hSourceInfo = {
          filename: '<unknown>'
        };
      }
      if (defined(content)) {
        if (isString(content)) {
          content = toArray(content);
          dbg(`iterator is an array with ${content.length} items`);
        }
        assert(isIterable(content), "content not iterable");
        this.iterator = content[Symbol.iterator]();
      } else {
        dbg("No content - check for fullpath");
        fullpath = this.hSourceInfo.fullpath;
        assert(nonEmpty(fullpath), "No content and no fullpath");
        // --- ultimately, we want to create an iterator here
        //     rather than blindly reading the entire file
        dbg(`slurping ${fullpath}`);
        content = toArray(slurp(fullpath));
        this.iterator = content[Symbol.iterator]();
      }
    } else {
      dbg("iterable passed as hInput");
      this.hSourceInfo = {
        filename: '<unknown>'
      };
      assert(isIterable(hInput), "hInput not iterable");
      this.iterator = hInput[Symbol.iterator]();
    }
    // --- @hSourceInfo must exist and have a filename key
    dbg('hSourceInfo', this.hSourceInfo);
    assert(nonEmpty(this.hSourceInfo.filename), "parseSource returned no filename");
    this.lineNum = 0;
    this.oneIndent = undef; // set from 1st line with indentation
    this.refill(); // sets @nextLevel and @nextStr
    this.nextNode = this.fetchNextNode();
    dbgReturn("Fetcher");
  }

  // ..........................................................
  refill() {
    var done, prefix, value;
    // --- invoke iterator to fill in @nextLevel & @nextStr
    ({value, done} = this.iterator.next());
    if (done) {
      this.nextStr = undef;
    } else if (isString(value)) {
      if (value === '__END__') {
        this.nextStr = undef;
      } else if (this.noLevels) {
        [prefix, this.nextStr] = splitPrefix(value);
        if (prefix.length > 0) {
          this.nextLevel = 2; // continuation line
        } else {
          this.nextLevel = 0;
        }
      } else {
        [this.nextLevel, this.nextStr] = splitLine(value, this.oneIndent);
        // --- Try to set @oneIndent
        if (notdefined(this.oneIndent) && (this.nextLevel > 0)) {
          // --- will return undef if no indentation
          this.oneIndent = getOneIndent(value);
        }
      }
    } else {
      this.nextLevel = 0;
      this.nextStr = value;
    }
  }

  // ..........................................................
  // --- returns hNode with keys:
  //        source
  //        str
  //        srcLevel - level in source code
  //        level    - includes added levels when #include'ing
  // --- OR undef at EOF
  fetch() {
    var save;
    dbgEnter("Fetcher.fetch");
    if (defined(this.nextNode)) {
      save = this.nextNode;
      this.nextNode = this.fetchNextNode();
      dbg("return look ahead node");
      dbgReturn('Fetcher.fetch', save);
      return save;
    }
    dbgReturn("Fetcher.fetch", undef);
    return undef;
  }

  // ..........................................................
  peek() {
    dbgEnter("Fetcher.peek");
    if (defined(this.nextNode)) {
      dbgReturn('Fetcher.peek', this.nextNode);
      return this.nextNode;
    }
    dbgReturn('Fetcher.peek', undef);
    return undef;
  }

  // ..........................................................
  fetchLinesAtLevel(level) {
    var hNode, lLines;
    dbgEnter("TreeMapper.fetchLinesAtLevel", level);
    lLines = [];
    while (defined(hNode = this.peek()) && (hNode.isEmptyLine() || (hNode.level >= level))) {
      this.fetch();
      lLines.push(hNode.str);
    }
    dbgReturn("TreeMapper.fetchLinesAtLevel", lLines);
    return lLines;
  }

  // ..........................................................
  fetchBlockAtLevel(level) {
    var block;
    dbgEnter("TreeMapper.fetchBlockAtLevel", level);
    block = toBlock(undented(this.fetchLinesAtLevel(level)));
    dbgReturn("TreeMapper.fetchBlockAtLevel", block);
    return block;
  }

  // ..........................................................
  // --- Returns the next available Node
  //        - hNode.str includes any extension lines
  fetchNextNode() {
    var hNode, level, orgLineNum, str;
    dbgEnter('Fetcher.fetchNextNode');
    if (notdefined(this.nextStr)) {
      // --- indicates EOF
      dbg('at EOF');
      dbgReturn('Fetcher.fetchNextNode', undef);
      return undef;
    }
    // --- Save current values, then refill
    level = this.nextLevel;
    str = this.nextStr;
    this.refill();
    this.lineNum += 1;
    dbg(`INC lineNum to ${this.lineNum}`);
    // --- save current line number in case there are extension lines
    orgLineNum = this.lineNum;
    dbg('orgLineNum', orgLineNum);
    if (isNonEmptyString(str)) {
      // --- Check for extension lines
      while (this.isExtLine(level, str, this.nextLevel, this.nextStr)) {
        str += this.extSep(str, this.nextStr) + this.nextStr;
        this.refill();
        this.lineNum += 1;
        dbg(`INC lineNum to ${this.lineNum}`);
      }
      if (this.addLevel > 0) {
        dbg(`add additional level ${this.addLevel}`);
        level += this.addLevel;
      }
    }
    dbg("create Node object");
    assert(isUndented(str), "fetchNextNode: str not undented");
    hNode = new Node({
      str,
      level,
      source: this.sourceInfoStr(orgLineNum)
    });
    dbgReturn("Fetcher.fetchNextNode", hNode);
    return hNode;
  }

  // ..........................................................
  isExtLine(curLevel, curStr, nextLevel, nextStr) {
    return isNonEmptyString(nextStr) && (nextLevel >= curLevel + 2);
  }

  // ..........................................................
  extSep(str, nextStr) {
    // --- can be overridden
    return ' ';
  }

  // ..........................................................
  sourceInfoStr(lineNum = undef) {
    var result;
    // --- override in FetcherInc
    dbgEnter('Fetcher.sourceInfoStr', lineNum);
    if (defined(lineNum)) {
      assert(isInteger(lineNum), `Bad lineNum: ${OL(lineNum)}`);
      result = `${this.hSourceInfo.filename}/${lineNum}`;
    } else {
      result = `${this.hSourceInfo.filename}`;
    }
    dbgReturn('Fetcher.sourceInfoStr', result);
    return result;
  }

  // ..........................................................
  // --- GENERATOR
  * allNodes() {
    var hNode;
    dbgEnter("Fetcher.allNodes");
    while (defined(hNode = this.fetch())) {
      dbg('hNode', hNode);
      if (this.procNode(hNode)) {
        dbgYield("Fetcher.allNodes", hNode);
        yield hNode;
        dbgResume("Fetcher.allNodes");
      }
    }
    dbgReturn("Fetcher.allNodes");
  }

  // ..........................................................
  procNode(hNode) {
    // --- does nothing, but can be overridden to
    //     add additional node processing
    // --- return value is true to keep the node, false to discard
    assert(defined(hNode), "hNode not defined");
    return true;
  }

  // ..........................................................
  getBlock(oneIndent = "\t") {
    var hNode, lLines, line, ref, result;
    dbgEnter("Fetcher.getBlock", oneIndent);
    lLines = [];
    ref = this.allNodes();
    for (hNode of ref) {
      dbg('GOT hNode', hNode);
      line = hNode.getLine({oneIndent});
      dbg(`line = ${OL(line)}`);
      lLines.push(line);
    }
    result = this.finalizeBlock(undented(toBlock(lLines)));
    dbgReturn("Fetcher.getBlock", result);
    return result;
  }

  // ..........................................................
  getLines(oneIndent = "\t") {
    var hNode, lLines, line, ref, result;
    dbgEnter("Fetcher.getLines", oneIndent);
    lLines = [];
    ref = this.allNodes();
    for (hNode of ref) {
      dbg('GOT hNode', hNode);
      line = hNode.getLine({oneIndent});
      dbg(`line = ${OL(line)}`);
      lLines.push(line);
    }
    result = this.finalizeBlock(undented(toArray(lLines)));
    dbgReturn("Fetcher.getLines", result);
    return result;
  }

  // ..........................................................
  finalizeBlock(block) {
    // --- block may, in fact, be either a string or an array of strings
    //     override should check
    return block;
  }

};
