// Generated by CoffeeScript 2.7.0
// TreeWalker.test.coffee
var HtmlMapper;

import {
  UnitTester,
  UnitTesterNorm,
  simple
} from '@jdeighan/unit-tester';

import {
  assert,
  error,
  croak
} from '@jdeighan/unit-tester/utils';

import {
  undef,
  pass,
  OL,
  defined,
  isEmpty,
  nonEmpty,
  isString
} from '@jdeighan/coffee-utils';

import {
  indentLevel,
  undented,
  splitLine,
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  mydir,
  mkpath
} from '@jdeighan/coffee-utils/fs';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  taml
} from '@jdeighan/coffee-utils/taml';

import {
  doMap
} from '@jdeighan/mapper';

import {
  TreeWalker
} from '@jdeighan/mapper/tree';

import {
  SimpleMarkDownMapper
} from '@jdeighan/mapper/markdown';

import {
  addStdHereDocTypes
} from '@jdeighan/mapper/heredoc';

addStdHereDocTypes();

/*
	class TreeWalker should handle the following:
		- remove empty lines and comments
		- extension lines
		- can override @map() - used in @getAll()
		- call @walk() to walk the tree
		- can override beginWalk(), visit(), endVisit(), endWalk()
*/
// ---------------------------------------------------------------------------
// --- Test TreeWalker.get() with special lines
(function() {
  var walker;
  walker = new TreeWalker(undef, `line1
# a comment
line2

line3`);
  simple.like(47, walker.get(), {
    str: 'line1',
    level: 0,
    lineNum: 1
  });
  simple.like(52, walker.get(), {
    str: '# a comment',
    level: 0,
    lineNum: 1,
    type: 'comment',
    comment: 'a comment'
  });
  simple.like(59, walker.get(), {
    str: 'line2',
    level: 0,
    lineNum: 3
  });
  simple.like(64, walker.get(), {
    str: '',
    level: 0,
    lineNum: 4,
    type: 'empty'
  });
  simple.like(70, walker.get(), {
    str: 'line3',
    level: 0,
    lineNum: 5
  });
  return simple.equal(75, walker.get(), undef);
})();

// ---------------------------------------------------------------------------
// Test TreeWalker.get()
(function() {
  var walker;
  walker = new TreeWalker(import.meta.url, `# --- a comment

abc
	def
		ghi`);
  simple.like(91, walker.get(), {
    str: 'abc',
    level: 0
  });
  simple.like(95, walker.get(), {
    str: 'def',
    level: 1
  });
  simple.like(99, walker.get(), {
    str: 'ghi',
    level: 2
  });
  return simple.equal(103, walker.get(), undef);
})();

// ---------------------------------------------------------------------------
// Test __END__ and extension lines with TreeWalker.get()
(function() {
  var walker;
  walker = new TreeWalker(import.meta.url, `abc
		def
	ghi
__END__
		ghi`);
  // --- get() should return {uobj, level}
  simple.like(120, walker.get(), {
    str: 'abc def',
    level: 0
  });
  simple.like(124, walker.get(), {
    str: 'ghi',
    level: 1
  });
  return simple.equal(128, walker.get(), undef);
})();

// ---------------------------------------------------------------------------
// __END__ only works with no identation
(function() {
  return simple.fails(135, function() {
    return doMap(TreeWalker, import.meta.url, `abc
		def
	ghi
	__END__
		ghi`);
  });
})();

// ---------------------------------------------------------------------------
(function() {
  var Tester, tester;
  Tester = class Tester extends UnitTester {
    transformValue(block) {
      return doMap(TreeWalker, import.meta.url, block);
    }

  };
  tester = new Tester();
  // ---------------------------------------------------------------------------
  // --- Test basic reading till EOF
  tester.equal(159, `abc
def`, `abc
def`);
  return tester.equal(167, `abc

def`, `abc
def`);
})();

// ---------------------------------------------------------------------------
// Test empty line handling
(function() {
  var MyTester, MyWalker, block, tester;
  MyWalker = class MyWalker extends TreeWalker {
    // --- This removes blank lines
    mapEmptyLine() {
      debug("in MyWalker.mapEmptyLine()");
      return undef;
    }

  };
  // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(MyWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ..........................................................
  block = `abc

def`;
  simple.equal(207, doMap(MyWalker, import.meta.url, block), `abc
def`);
  return tester.equal(212, block, `abc
def`);
})();

// ---------------------------------------------------------------------------
// Test comment handling
(function() {
  var MyTester, MyWalker, block, tester;
  MyWalker = class MyWalker extends TreeWalker {
    isComment(hNode) {
      // --- comments start with //
      return hNode.str.match(/^\/\//);
    }

    mapComment(hNode) {
      // --- remove comments
      return undef;
    }

  };
  // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(MyWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ..........................................................
  block = `// a comment - should be removed
//also a comment
# not a comment
abc
def`;
  simple.equal(255, doMap(MyWalker, import.meta.url, block), `# not a comment
abc
def`);
  return tester.equal(261, block, `# not a comment
abc
def`);
})();

// ---------------------------------------------------------------------------
// Test command handling
(function() {
  var MyTester, MyWalker, block, tester;
  MyWalker = class MyWalker extends TreeWalker {
    isCmd(hNode) {
      var _, cmd, lMatches;
      // --- commands consist of '-' + one whitespace char + word
      if ((lMatches = hNode.str.match(/^-\s(\w+)$/))) {
        [_, cmd] = lMatches;
        hNode.cmd = cmd;
        hNode.argstr = '';
        return true;
      } else {
        return false;
      }
    }

    // .......................................................
    mapCmd(hNode) {
      // --- NOTE: this disables handling all commands,
      //           i.e. #define, etc.
      // --- Returning any non-undef value prevents discarding hNode
      return '';
    }

    // .......................................................
    visitCmd(hNode) {
      var result;
      debug("enter MyWalker.visitCmd()");
      result = `COMMAND: ${hNode.cmd}`;
      debug("return from MyWalker.visitCmd()", result);
      return result;
    }

  };
  // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(MyWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ..........................................................
  block = `# remove this

abc
- command
def`;
  return tester.equal(322, block, `abc
COMMAND: command
def`);
})();

// ---------------------------------------------------------------------------
// try retaining indentation for mapped lines
(function() {
  var MyTester, MyWalker, tester;
  // --- NOTE: map() returns anything,
  //           or undef to ignore the line
  MyWalker = class MyWalker extends TreeWalker {
    // --- This maps all non-empty lines to the string 'x'
    //     and removes all empty lines
    map(hNode) {
      var level, str;
      debug("enter map()", hNode);
      ({str, level} = hNode);
      if (isEmpty(str)) {
        debug("return undef from map() - empty line");
        return undef;
      } else {
        debug("return 'x' from map()");
        return 'x';
      }
    }

  };
  // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(MyWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ..........................................................
  return tester.equal(365, `abc
	def

ghi`, `x
	x
x`);
})();

// ---------------------------------------------------------------------------
// --- Test ability to access 'this' object from a walker
//     Goal: remove not only blank lines, but also the line following
(function() {
  var MyTester, MyWalker, tester;
  MyWalker = class MyWalker extends TreeWalker {
    // --- Remove blank lines PLUS the line following a blank line
    mapEmptyLine(hNode) {
      var follow;
      follow = this.fetch();
      return undef; // remove empty lines
    }

  };
  
    // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(MyWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ..........................................................
  return tester.equal(403, `abc

def
ghi`, `abc
ghi`);
})();

// ---------------------------------------------------------------------------
// --- Test #include
(function() {
  var MyTester, tester;
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(TreeWalker, import.meta.url, block);
    }

  };
  // ..........................................................
  tester = new MyTester();
  return tester.equal(429, `abc
	#include title.md
def`, `abc
	title
	=====
def`);
})();

// ---------------------------------------------------------------------------
// --- Test getAll()
(function() {
  var MyTester, tester;
  // ..........................................................
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      var walker;
      walker = new TreeWalker(import.meta.url, block);
      return walker.getAll();
    }

  };
  tester = new MyTester();
  return tester.like(458, `abc
	def
		ghi
jkl`, taml(`---
-
	level: 0
	str: 'abc'
-
	level: 1
	str: 'def'
-
	level: 2
	str: 'ghi'
-
	level: 0
	str: 'jkl'`));
})();

// ---------------------------------------------------------------------------
(function() {
  var walker;
  walker = new TreeWalker(import.meta.url, `if (x == 2)
	doThis
	doThat
		then this
while (x > 2)
	--x`);
  simple.like(494, walker.peek(), {
    level: 0,
    str: 'if (x == 2)'
  });
  simple.like(495, walker.get(), {
    level: 0,
    str: 'if (x == 2)'
  });
  simple.like(497, walker.peek(), {
    level: 1,
    str: 'doThis'
  });
  simple.like(498, walker.get(), {
    level: 1,
    str: 'doThis'
  });
  simple.like(500, walker.peek(), {
    level: 1,
    str: 'doThat'
  });
  simple.like(501, walker.get(), {
    level: 1,
    str: 'doThat'
  });
  simple.like(503, walker.peek(), {
    level: 2,
    str: 'then this'
  });
  simple.like(504, walker.get(), {
    level: 2,
    str: 'then this'
  });
  simple.like(506, walker.peek(), {
    level: 0,
    str: 'while (x > 2)'
  });
  simple.like(507, walker.get(), {
    level: 0,
    str: 'while (x > 2)'
  });
  simple.like(509, walker.peek(), {
    level: 1,
    str: '--x'
  });
  return simple.like(510, walker.get(), {
    level: 1,
    str: '--x'
  });
})();

// ---------------------------------------------------------------------------
// --- Test fetchBlockAtLevel()
(function() {
  var walker;
  walker = new TreeWalker(import.meta.url, `if (x == 2)
	doThis
	doThat
		then this
while (x > 2)
	--x`);
  simple.like(528, walker.get(), {
    level: 0,
    str: 'if (x == 2)'
  });
  simple.equal(533, walker.fetchBlockAtLevel(1), `doThis
doThat
	then this`);
  simple.like(539, walker.get(), {
    level: 0,
    str: 'while (x > 2)'
  });
  return simple.equal(544, walker.fetchBlockAtLevel(1), "--x");
})();

// ---------------------------------------------------------------------------
// --- Test fetchBlockAtLevel() with mapping
(function() {
  var MyWalker, walker;
  MyWalker = class MyWalker extends TreeWalker {
    map(hNode) {
      var _, cmd, cond, lMatches, level, str;
      ({str, level} = hNode);
      if ((lMatches = str.match(/^(if|while)\s*(.*)$/))) {
        [_, cmd, cond] = lMatches;
        return {cmd, cond};
      } else {
        return str;
      }
    }

  };
  walker = new MyWalker(import.meta.url, `if (x == 2)
	doThis
	doThat
		then this
while (x > 2)
	--x`);
  simple.like(575, walker.get(), {
    level: 0,
    line: {
      cmd: 'if',
      cond: '(x == 2)'
    }
  });
  simple.equal(582, walker.fetchBlockAtLevel(1), `doThis
doThat
	then this`);
  simple.like(587, walker.get(), {
    level: 0,
    line: {
      cmd: 'while',
      cond: '(x > 2)'
    }
  });
  simple.equal(594, walker.fetchBlockAtLevel(1), "--x");
  return simple.equal(595, walker.get(), undef);
})();

// ---------------------------------------------------------------------------
// --- Test HEREDOC
(function() {
  var MyTester, tester;
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(TreeWalker, import.meta.url, block);
    }

  };
  // ..........................................................
  tester = new MyTester();
  tester.equal(613, `abc
if x == <<<
	abc
	def

def`, `abc
if x == "abc\\ndef"
def`);
  tester.equal(626, `abc
if x == <<<
	===
	abc
	def

def`, `abc
if x == "abc\\ndef"
def`);
  return tester.equal(640, `abc
if x == <<<
	...
	abc
	def

def`, `abc
if x == "abc def"
def`);
})();

// ---------------------------------------------------------------------------
// --- A more complex example
HtmlMapper = class HtmlMapper extends TreeWalker {
  map(hNode) {
    var _, body, hResult, lMatches, level, md, str, tag, text;
    debug("enter MyWalker.map()", hNode);
    ({str, level} = hNode);
    lMatches = str.match(/^(\S+)(?:\s+(.*))?$/); // the tag
    // some whitespace
    // everything else
    // optional
    assert(defined(lMatches), "missing HTML tag");
    [_, tag, text] = lMatches;
    hResult = {tag, level: this.level};
    switch (tag) {
      case 'body':
        assert(isEmpty(text), "body tag doesn't allow content");
        break;
      case 'p':
      case 'div':
        if (nonEmpty(text)) {
          hResult.body = text;
        }
        break;
      case 'div:markdown':
        hResult.tag = 'div';
        body = this.fetchBlockAtLevel(level + 1);
        debug("body", body);
        if (nonEmpty(body)) {
          md = doMap(SimpleMarkDownMapper, import.meta.url, body);
          debug("md", md);
          hResult.body = md;
        }
        break;
      default:
        croak(`Unknown tag: ${OL(tag)}`);
    }
    debug("return from MyWalker.map()", hResult);
    return hResult;
  }

  // .......................................................
  visit(hNode, hUser, lStack) {
    var _, lMatches, lParts, level, result, str, type, uobj;
    ({str, uobj, level, type} = hNode);
    switch (type) {
      case 'comment':
        if (lMatches = str.match(/^\#(.*)$/)) {
          [_, str] = lMatches;
          return indented(`<!-- ${str.trim()} -->`, level);
        } else {
          return undef;
        }
    }
    lParts = [indented(`<${uobj.tag}>`, level)];
    if (nonEmpty(uobj.body)) {
      lParts.push(indented(uobj.body, level + 1));
    }
    result = arrayToBlock(lParts);
    debug('result', result);
    return result;
  }

  // .......................................................
  endVisit(hNode, hUser, lStack) {
    var level, type, uobj;
    ({uobj, level, type} = hNode);
    if (type === 'comment') {
      return undef;
    }
    return indented(`</${uobj.tag}>`, level);
  }

};

// ---------------------------------------------------------------------------
(function() {
  var MyTester, tester;
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(HtmlMapper, import.meta.url, block);
    }

  };
  tester = new MyTester();
  // ----------------------------------------------------------
  return tester.equal(741, `body
	# a comment

	div:markdown
		A title
		=======

		some text

	div
		p more text`, `<body>
	<div>
		<h1>A title</h1>
		<p>some text</p>
	</div>
	<div>
		<p>
			more text
		</p>
	</div>
</body>`);
})();

// ---------------------------------------------------------------------------
// --- test #ifdef and #ifndef
(function() {
  var MyTester, tester;
  MyTester = class MyTester extends UnitTester {
    transformValue(block) {
      return doMap(TreeWalker, import.meta.url, block);
    }

  };
  tester = new MyTester();
  return tester.equal(782, `abc
#ifdef something
	def
	ghi
#ifndef something
	xyz`, `abc
xyz`);
})();
