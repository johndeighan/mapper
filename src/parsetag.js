// Generated by CoffeeScript 2.7.0
// parsetag.coffee
var hNoEnd, i, len, ref, tag;

import {
  assert,
  undef,
  pass,
  error,
  croak,
  words,
  nonEmpty
} from '@jdeighan/coffee-utils';

hNoEnd = {};

ref = words('area base br col command embed hr img input' + ' keygen link meta param source track wbr');
for (i = 0, len = ref.length; i < len; i++) {
  tag = ref[i];
  hNoEnd[tag] = true;
}

// ---------------------------------------------------------------------------
export var parsetag = function(line) {
  var _, all, attrName, br_val, className, dq_val, hAttr, hToken, j, lClasses, lMatches, len1, modifiers, prefix, quote, ref1, rest, sq_val, subtype, tagName, uq_val, value, varName;
  if (lMatches = line.match(/^(?:([A-Za-z][A-Za-z0-9_]*)\s*=\s*)?([A-Za-z][A-Za-z0-9_]*)(?:\:([a-z]+))?(\S*)\s*(.*)$/)) { // variable name
    // variable is optional
    // tag name
    // modifiers (class names, etc.)
    // attributes & enclosed text
    [_, varName, tagName, subtype, modifiers, rest] = lMatches;
    if ((tagName === 'svelte') && subtype) {
      tagName = `${tagName}:${subtype}`;
      subtype = undef;
    }
  } else {
    error(`parsetag(): Invalid HTML: '${line}'`);
  }
  switch (subtype) {
    case undef:
    case '':
      pass;
      break;
    case 'startup':
    case 'onmount':
    case 'ondestroy':
      if (tagName !== 'script') {
        error(`parsetag(): subtype '${subtype}' only allowed with script`);
      }
      break;
    case 'markdown':
    case 'sourcecode':
      if (tagName !== 'div') {
        error("parsetag(): subtype 'markdown' only allowed with div");
      }
  }
  // --- Handle classes added via .<class>
  lClasses = [];
  if (subtype === 'markdown') {
    lClasses.push('markdown');
  }
  if (modifiers) {
    // --- currently, these are only class names
    while (lMatches = modifiers.match(/^\.([A-Za-z][A-Za-z0-9_]*)/)) {
      [all, className] = lMatches;
      lClasses.push(className);
      modifiers = modifiers.substring(all.length);
    }
    if (modifiers) {
      error(`parsetag(): Invalid modifiers in '${line}'`);
    }
  }
  // --- Handle attributes
  hAttr = {}; // { name: { value: <value>, quote: <quote> }, ... }
  if (varName) {
    hAttr['bind:this'] = {
      value: varName,
      quote: '{'
    };
  }
  if (rest) {
    while (lMatches = rest.match(/^(?:(?:(bind|on):)?([A-Za-z][A-Za-z0-9_]*))=(?:\{([^}]*)\}|"([^"]*)"|'([^']*)'|([^"'\s]+))\s*/)) { // prefix
      // attribute name
      // attribute value
      [all, prefix, attrName, br_val, dq_val, sq_val, uq_val] = lMatches;
      if (br_val) {
        value = br_val;
        quote = '{';
      } else {
        assert(prefix == null, "prefix requires use of {...}");
        if (dq_val) {
          value = dq_val;
          quote = '"';
        } else if (sq_val) {
          value = sq_val;
          quote = "'";
        } else {
          value = uq_val;
          quote = '';
        }
      }
      if (prefix) {
        attrName = `${prefix}:${attrName}`;
      }
      if (attrName === 'class') {
        ref1 = value.split(/\s+/);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          className = ref1[j];
          lClasses.push(className);
        }
      } else {
        if (hAttr.attrName != null) {
          error(`parsetag(): Multiple attributes named '${attrName}'`);
        }
        hAttr[attrName] = {value, quote};
      }
      rest = rest.substring(all.length);
    }
  }
  // --- The rest is contained text
  rest = rest.trim();
  if (lMatches = rest.match(/^['"](.*)['"]$/)) {
    rest = lMatches[1];
  }
  // --- Add class attribute to hAttr if there are classes
  if (lClasses.length > 0) {
    hAttr.class = {
      value: lClasses.join(' '),
      quote: '"'
    };
  }
  // --- If subtype == 'startup'
  if (subtype === 'startup') {
    if (!hAttr.context) {
      hAttr.context = {
        value: 'module',
        quote: '"'
      };
    }
  }
  // --- Build the return value
  hToken = {
    type: 'tag',
    tag: tagName
  };
  if (subtype) {
    hToken.subtype = subtype;
  }
  if (nonEmpty(hAttr)) {
    hToken.hAttr = hAttr;
  }
  // --- Is there contained text?
  if (rest) {
    hToken.containedText = rest;
  }
  return hToken;
};

// ---------------------------------------------------------------------------
export var isBlockTag = function(hTag) {
  var subtype;
  ({tag, subtype} = hTag);
  return (tag === 'script') || (tag === 'style') || (tag === 'pre') || ((tag === 'div') && (subtype === 'markdown')) || ((tag === 'div') && (subtype === 'sourcecode'));
};

// ---------------------------------------------------------------------------
// --- export only for unit testing
export var attrStr = function(hAttr) {
  var attrName, bquote, equote, j, len1, quote, ref1, str, value;
  if (!hAttr) {
    return '';
  }
  str = '';
  ref1 = Object.getOwnPropertyNames(hAttr);
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    attrName = ref1[j];
    ({value, quote} = hAttr[attrName]);
    if (quote === '{') {
      bquote = '{';
      equote = '}';
    } else {
      bquote = equote = quote;
    }
    str += ` ${attrName}=${bquote}${value}${equote}`;
  }
  return str;
};

// ---------------------------------------------------------------------------
export var tag2str = function(hToken, type = 'begin') {
  var str;
  if (type === 'begin') {
    str = `<${hToken.tag}`;
    if (nonEmpty(hToken.hAttr)) {
      str += attrStr(hToken.hAttr);
    }
    str += '>';
    return str;
  } else if (type === 'end') {
    if (hNoEnd[hToken.tag]) {
      return "";
    } else {
      return `<${hToken.tag}>`;
    }
  } else {
    return croak("type must be 'begin' or 'end'");
  }
};
