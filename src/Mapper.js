// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
//   class Mapper
//       handles:
//          #define
//          const replacement
export var Mapper = class Mapper extends Getter {
  constructor(source = undef, collection = undef, hOptions = {}) {
    debug("enter Mapper()");
    super(source, collection, hOptions);
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    this.setConst('LINE', this.hSourceInfo.lineNum);
    debug("return from Mapper()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    debug(`enter incLineNum(${inc})`);
    super.incLineNum(inc);
    this.setConst('LINE', this.hSourceInfo.lineNum);
    debug("return from incLineNum()");
  }

  // ..........................................................
  // --- override
  getItemType(item) {
    var h, result;
    debug("enter Mapper.getItemType()", item);
    // --- only strings may have an item type
    if (isString(item)) {
      // --- check for empty item
      if (this.isEmptyLine(item)) {
        result = ['empty', undef];
      // --- check for comment
      } else if (this.isComment(item)) {
        result = ['comment', undef];
      // --- check for cmd
      } else if (defined(h = this.isCmd(item))) {
        assert(isHash(h, ['cmd', 'argstr', 'prefix']), `isCmd() returned bad hash ${OL(h)}`);
        result = ['cmd', h];
      }
    }
    if (result === undef) {
      result = [undef, undef];
    }
    debug("return from Mapper.getItemType()", result);
    return result;
  }

  // ..........................................................
  // --- override
  handleItemType(type, item, h) {
    var argstr, cmd, prefix, str, uobj;
    debug("enter Mapper.handleItemType()", type, item);
    [prefix, str] = splitPrefix(item);
    switch (type) {
      case 'empty':
        uobj = this.handleEmptyLine();
        break;
      case 'comment':
        uobj = this.handleComment(item, prefix);
        break;
      case 'cmd':
        ({cmd, argstr} = h);
        assert(isString(cmd), "cmd not a string");
        assert(isString(argstr), "argstr not a string");
        uobj = this.handleCmd(cmd, argstr, prefix, h);
        break;
      default:
        croak(`Unknown item type: ${OL(type)}`);
    }
    debug("return from Mapper.handleItemType()", uobj);
    return uobj;
  }

  // ..........................................................
  isEmptyLine(line) {
    return isEmpty(line);
  }

  // ..........................................................
  handleEmptyLine(line) {
    // --- can override
    //     line may contain whitespace

    // --- return '' to keep empty lines
    return undef;
  }

  // ..........................................................
  isComment(line) {
    var ch, lMatches;
    if ((lMatches = line.match(/^\s*\#(.|$)/))) { // a # character
      // following character, if any
      ch = lMatches[1];
      return (ch === undef) || (ch === ' ' || ch === '\t' || ch === '');
    } else {
      return false;
    }
  }

  // ..........................................................
  handleComment(line, prefix) {
    debug("in Mapper.handleComment()");
    // --- return undef to remove comments
    return line;
  }

  // ..........................................................
  isCmd(line) {
    var _, argstr, cmd, hResult, lMatches, prefix;
    // --- Must return either undef or {prefix, cmd, argstr}
    debug("enter Mapper.isCmd()");
    if (lMatches = line.match(/^(\s*)\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, prefix, cmd, argstr] = lMatches;
      if (!prefix) {
        prefix = '';
      }
      hResult = {
        cmd,
        argstr: argstr ? argstr.trim() : '',
        prefix
      };
      debug("return from Mapper.isCmd()", hResult);
      return hResult;
    }
    // --- not a command
    debug("return undef from Mapper.isCmd()");
    return undef;
  }

  // ..........................................................
  // --- handleCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class handleCmd
  handleCmd(cmd, argstr, prefix, h) {
    var _, isEnv, lMatches, name, tail;
    // --- h has keys 'cmd','argstr' and 'prefix'
    //     but may contain additional keys
    debug(`enter Mapper.handleCmd #${cmd} '${argstr}'`);
    assert(isString(prefix), "prefix not a string");
    if (prefix.length > 0) {
      debug(`   prefix = '${escapeStr(prefix)}'`);
    }
    // --- Each case should return
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, isEnv, name, tail] = lMatches;
          if (tail) {
            tail = tail.trim();
          }
          if (isEnv) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setConst(name, tail);
          }
        }
        debug("return undef from Mapper.handleCmd()");
        return undef;
      default:
        croak(`Unknown command: #${cmd}`);
    }
    return croak("Not all cases return");
  }

};

// ===========================================================================
export var doMap = function(inputClass, source, content = undef) {
  var name, oInput, result;
  assert(inputClass != null, "Missing input class");
  name = className(inputClass);
  debug("enter doMap()", name, source, content);
  oInput = new inputClass(source, content);
  assert(oInput instanceof Mapper, "doMap() requires a Mapper or subclass");
  debug("got oInput object");
  result = oInput.getBlock();
  debug("return from doMap()", result);
  return result;
};
