// Generated by CoffeeScript 2.6.1
// coffee.coffee
var convert;

import CoffeeScript from 'coffeescript';

import {
  assert,
  croak,
  OL,
  isString,
  isEmpty,
  undef
} from '@jdeighan/coffee-utils';

import {
  log
} from '@jdeighan/coffee-utils/log';

import {
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  withExt,
  slurp,
  barf,
  newerDestFileExists,
  shortenPath
} from '@jdeighan/coffee-utils/fs';

import {
  indentLevel,
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  StringInput,
  SmartInput
} from '@jdeighan/string-input';

import {
  getNeededSymbols,
  buildImportBlock,
  addImports
} from '@jdeighan/string-input/symbols';

convert = true;

// ---------------------------------------------------------------------------
export var convertCoffee = function(flag) {
  convert = flag;
};

// ---------------------------------------------------------------------------
export var brewExpr = function(expr, force = false) {
  var err, newexpr, pos;
  assert(indentLevel(expr) === 0, "brewExpr(): has indentation");
  if (!convert && !force) {
    return expr;
  }
  try {
    newexpr = CoffeeScript.compile(expr, {
      bare: true
    }).trim();
    // --- Remove any trailing semicolon
    pos = newexpr.length - 1;
    if (newexpr.substr(pos, 1) === ';') {
      newexpr = newexpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, "brewExpr", expr);
  }
  return newexpr;
};

// ---------------------------------------------------------------------------
export var brewCoffeeStr = function(code, hOptions = {}) {
  var lBlocks, newcode;
  // --- coffee => js
  //     Valid Options:
  //        saveAST
  //        force
  assert(isString(code), "brewCoffeeStr(): code is not a string");
  lBlocks = preBrewCoffee(code);
  newcode = joinBlocks(...lBlocks);
  debug('CODE', code);
  debug('NEW CODE', newcode);
  return newcode;
};

// ---------------------------------------------------------------------------
export var brewCoffeeFile = function(srcPath, destPath = undef, hOptions = {}) {
  var coffeeCode, dumpfile, j, jsCode, lNeeded, len, n, sym, word;
  if (destPath == null) {
    destPath = withExt(srcPath, '.js', {
      removeLeadingUnderScore: true
    });
  }
  if (hOptions.force || !newerDestFileExists(srcPath, destPath)) {
    coffeeCode = slurp(srcPath);
    if (hOptions.saveAST) {
      dumpfile = withExt(srcPath, '.ast');
      lNeeded = getNeededSymbols(coffeeCode, {dumpfile});
      if ((lNeeded === undef) || (lNeeded.length === 0)) {
        debug(`NO NEEDED SYMBOLS in ${shortenPath(destPath)}:`);
      } else {
        n = lNeeded.length;
        word = n === 1 ? 'SYMBOL' : 'SYMBOLS';
        debug(`${n} NEEDED ${word} in ${shortenPath(destPath)}:`);
        for (j = 0, len = lNeeded.length; j < len; j++) {
          sym = lNeeded[j];
          debug(`   - ${sym}`);
        }
      }
    }
    jsCode = brewCoffeeStr(coffeeCode);
    barf(destPath, jsCode);
  }
};

// ---------------------------------------------------------------------------
export var preBrewCoffee = function(...lBlocks) {
  var blk, err, i, importBlock, j, lNeededSymbols, lNewBlocks, len, newblk, script;
  debug("enter preBrewCoffee()");
  lNeededSymbols = [];
  lNewBlocks = [];
  for (i = j = 0, len = lBlocks.length; j < len; i = ++j) {
    blk = lBlocks[i];
    debug(`BLOCK ${i}`, blk);
    newblk = preProcessCoffee(blk);
    debug("NEW BLOCK", newblk);
    // --- will always be unique
    lNeededSymbols = getNeededSymbols(newblk);
    if (convert) {
      try {
        script = CoffeeScript.compile(newblk, {
          bare: true
        });
        debug("BREWED SCRIPT", script);
        lNewBlocks.push(postProcessCoffee(script));
      } catch (error) {
        err = error;
        log("Mapped Text:", newblk);
        croak(err, "Original Text", blk);
      }
    } else {
      lNewBlocks.push(newblk);
    }
  }
  importBlock = buildImportBlock(lNeededSymbols, process.env.DIR_ROOT);
  debug("return from preBrewCoffee()");
  return [importBlock, ...lNewBlocks];
};

// ---------------------------------------------------------------------------
/*

- converts
		<varname> <== <expr>

	to:
		`$:{`
		<varname> = <expr>
		`}`

- converts
		<==
			<code>

	to:
		`$:{`
		<code>
		`}`

*/
// ===========================================================================
export var CieloMapper = class CieloMapper extends SmartInput {
  mapString(line, level) {
    var _, code, expr, lMatches, result, varname;
    debug(`enter mapString(${OL(line)})`);
    if (line === '<==') {
      // --- Generate a reactive block
      code = this.fetchBlock(level + 1); // might be empty
      if (isEmpty(code)) {
        debug("return undef from mapString() - empty code block");
        return undef;
      } else {
        result = `\`$:{\`
${code}
\`}\``;
      }
    } else if (lMatches = line.match(/^([A-Za-z][A-Za-z0-9_]*)\s*\<\=\=\s*(.*)$/)) { // variable name
      [_, varname, expr] = lMatches;
      code = this.fetchBlock(level + 1); // must be empty
      assert(isEmpty(code), `mapString(): indented code not allowed after '${line}'`);
      assert(!isEmpty(expr), `mapString(): empty expression in '${line}'`);
      // --- Alternatively, we could prepend "<varname> = undefined"
      //     to this???
      result = `\`$:{\`
${line.replace('<==', '=')}
\`}\``;
    } else {
      debug("return from mapString() - no match");
      return line;
    }
    debug("return from mapString()", result);
    return result;
  }

};

// ---------------------------------------------------------------------------
export var preProcessCoffee = function(code) {
  var newcode, oInput;
  // --- Removes blank lines and comments
  //     inteprets <== as svelte reactive statement or block
  assert(indentLevel(code) === 0, "preProcessCoffee(): has indentation");
  oInput = new CieloMapper(code);
  newcode = oInput.getAllText();
  debug('newcode', newcode);
  return newcode;
};

// ---------------------------------------------------------------------------
export var StarbucksPostMapper = class StarbucksPostMapper extends StringInput {
  // --- variable declaration immediately following one of:
  //        $:{;
  //        $:;
  //     should be moved above this line
  mapLine(line, level) {
    var _, brace, lMatches, rest, result;
    // --- new properties, initially undef:
    //        @savedLevel
    //        @savedLine
    if (this.savedLine) {
      if (line.match(/^\s*var\s/)) {
        result = `${line}\n${this.savedLine}`;
      } else {
        result = `${this.savedLine}\n${line}`;
      }
      this.savedLine = undef;
      return result;
    }
    if ((lMatches = line.match(/^\$\:(\{)?\;(.*)$/))) { // optional {
      // any remaining text
      [_, brace, rest] = lMatches;
      assert(!rest, "StarbucksPostMapper: extra text after $:");
      this.savedLevel = level;
      if (brace) {
        this.savedLine = "$:{";
      } else {
        this.savedLine = "$:";
      }
      return undef;
    } else if ((lMatches = line.match(/^\}\;(.*)$/))) {
      [_, rest] = lMatches;
      assert(!rest, "StarbucksPostMapper: extra text after $:");
      return indented("\}", level);
    } else {
      return indented(line, level);
    }
  }

};

// ---------------------------------------------------------------------------
export var postProcessCoffee = function(code) {
  var oInput;
  // --- variable declaration immediately following one of:
  //        $:{
  //        $:
  //     should be moved above this line
  oInput = new StarbucksPostMapper(code);
  return oInput.getAllText();
};
