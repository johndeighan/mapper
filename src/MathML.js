// Generated by CoffeeScript 2.7.0
// MathML.coffee
var atom, atomList, checkArgs, getNode, getSVG, hCommands, isIdentifier, isIntegerStr, matching;

import {
  LOG,
  assert,
  croak,
  debug
} from '@jdeighan/exceptions';

import {
  undef,
  pass,
  isEmpty,
  isArray,
  isNumber,
  isString,
  escapeStr,
  OL
} from '@jdeighan/coffee-utils';

import {
  isSimpleFileName,
  fileExt,
  isFile,
  isDir,
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  TreeMapper
} from '@jdeighan/mapper/tree';

// --- commands, with allowed # of args, allowed # of children
hCommands = {
  expr: [undef, undef],
  group: [[0, 2], undef],
  svg: [1, 0],
  sub: [0, 2],
  sup: [0, 2],
  frac: [0, 2],
  SIGMA: [[0, 1], [2, undef]]
};

export var isCommand = function(str) {
  return hCommands[str] != null;
};

// ---------------------------------------------------------------------------
export var mapMath = function(line) {
  var cmd, hNode, lWords;
  debug(`enter mapMath('${escapeStr(line)}')`);
  if (isEmpty(line)) {
    debug("return undef from mapMath() - empty string");
    return undef;
  }
  // --- These should not be needed
  assert(line.indexOf("\n") === -1, "mapper(): line contains newline char");
  assert(line.indexOf("\r") === -1, "mapper(): line contains return char");
  lWords = line.split(/\s+/); // split on whitespace
  assert(lWords != null, "lWords is not defined!");
  assert(lWords.length > 0, "lWords is empty!");
  if (isCommand(lWords[0])) {
    cmd = lWords[0];
    debug(`Command '${cmd}' found`);
    hNode = getNode(cmd, lWords.slice(1));
  } else {
    debug("expression found");
    hNode = getNode('expr', lWords);
  }
  debug("return from mapMath()", hNode);
  return hNode;
};

// ---------------------------------------------------------------------------
getNode = function(cmd, lArgs) {
  var hNode, left, nArgs, right;
  // --- Converts lArgs to array of atoms lAtoms
  //     If no args, don't include key lAtoms
  //     except that the 'group' command automatically supplies default atoms
  debug(`enter getNode('${cmd}', lArgs`, lArgs);
  assert(isCommand(cmd), `getNode(): Not a command: '${cmd}'`);
  assert(isArray(lArgs), "getNode(): lArgs not an array");
  nArgs = lArgs.length;
  if (cmd === 'group') {
    // --- if cmd 'group', fill in missing values with default values
    assert(nArgs <= 2, `Invalid 'group', ${nArgs} args`);
    [left, right] = lArgs;
    if (!left) {
      left = '(';
    }
    if (!right) {
      right = matching(left);
    }
    lArgs = [left, right];
    debug('lArgs', lArgs);
  } else if (cmd === 'SIGMA') {
    assert(nArgs <= 1, `Invalid 'SIGMA', ${nArgs} args`);
    if (lArgs.length === 0) {
      lArgs = ['&#x03A3;'];
    }
    debug('lArgs', lArgs);
  }
  if (lArgs.length === 0) {
    hNode = {cmd};
  } else {
    hNode = {
      cmd,
      lAtoms: atomList(lArgs)
    };
  }
  checkArgs(cmd, hNode.lAtoms);
  debug("return from getNode()", hNode);
  return hNode;
};

// ---------------------------------------------------------------------------
checkArgs = function(cmd, lAtoms) {
  var check, max, min, nAtoms;
  assert(isCommand(cmd), `Not a command: '${cmd}'`);
  if (lAtoms != null) {
    assert(isArray(lAtoms), "checkArgs(): lAtoms not an array");
    nAtoms = lAtoms.length;
  } else {
    nAtoms = 0;
  }
  check = hCommands[cmd][0];
  if (isNumber(check)) {
    assert(nAtoms === check, `cmd ${cmd} has ${nAtoms} args, should be ${check}`);
  } else if (isArray(check)) {
    [min, max] = check;
    if (min != null) {
      assert(nAtoms >= min, `cmd ${cmd} has ${nAtoms} args, min = ${min}`);
    }
    if (max != null) {
      assert(nAtoms <= max, `cmd ${cmd} has ${nAtoms} args, max = ${max}`);
    }
  }
};

// ---------------------------------------------------------------------------
atom = function(str) {
  assert(isString(str), "atom(): not a string");
  if (isIntegerStr(str)) {
    return {
      type: 'number',
      value: str
    };
  } else if (isIdentifier(str)) {
    return {
      type: 'ident',
      value: str
    };
  } else {
    return {
      type: 'op',
      value: str
    };
  }
};

// ---------------------------------------------------------------------------
atomList = function(lItems) {
  var i, lAtoms, str;
  if ((lItems == null) || (lItems.length === 0)) {
    return undef;
  }
  lAtoms = (function() {
    var j, len, results;
    results = [];
    for (i = j = 0, len = lItems.length; j < len; i = ++j) {
      str = lItems[i];
      assert(isString(str), `atomList(): not a string: ${OL(str)} at ${i}`);
      results.push(atom(str));
    }
    return results;
  })();
  return lAtoms;
};

// ---------------------------------------------------------------------------
matching = function(bracket) {
  assert(bracket != null, "matching(): bracket is not defined");
  switch (bracket) {
    case '(':
      return ')';
    case '[':
      return ']';
    case '{':
      return '}';
    default:
      return bracket;
  }
};

// ===========================================================================
export var MathTreeWalker = class MathTreeWalker extends TreeMapper {
  // --- The @dir parameter is required if you use svg
  constructor(tree, dir1 = undef) {
    super(tree);
    this.dir = dir1;
    this.mathml = '';
  }

  visit(superNode) {
    var j, left, len, node, ref, right;
    debug("enter visit()");
    node = superNode.node;
    switch (node.cmd) {
      case 'expr':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "<mrow>";
        ref = node.lAtoms;
        for (j = 0, len = ref.length; j < len; j++) {
          atom = ref[j];
          switch (atom.type) {
            case 'number':
              this.mathml += `<mn>${atom.value}</mn>`;
              break;
            case 'ident':
              this.mathml += `<mi>${atom.value}</mi>`;
              break;
            case 'op':
              this.mathml += `<mo>${atom.value}</mo>`;
          }
        }
        break;
      case 'svg':
        debug(`cmd: ${node.cmd}`);
        left = node.lAtoms[0];
        right = node.lAtoms[1];
        this.mathml += "<semantics><annotation-xml encoding='SVG1.1'>\n";
        this.mathml += getSVG(left, this.dir);
        this.mathml += "\n</annotation-xml></semantics>\n";
        break;
      case 'group':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "<mrow>";
        this.mathml += node.lAtoms[0].value;
        break;
      case 'sub':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "<msub>";
        break;
      case 'SIGMA':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "<munderover>";
        this.mathml += "<mo class='large'> &#x03A3; </mo>";
        break;
      default:
        croak(`visit(): Not a command: '${node.cmd}'`);
    }
    debug("return from visit()");
  }

  endVisit(superNode) {
    var node;
    debug("enter endVisit()");
    node = superNode.node;
    switch (node.cmd) {
      case 'expr':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "</mrow>";
        break;
      case 'group':
        debug(`cmd: ${node.cmd}`);
        this.mathml += node.lAtoms[1].value;
        this.mathml += "</mrow>";
        break;
      case 'sub':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "</msub>";
        break;
      case 'SIGMA':
        debug(`cmd: ${node.cmd}`);
        this.mathml += "</munderover>";
        break;
      case 'svg':
        pass;
        break;
      default:
        croak(`endVisit(): Not a command: '${node.cmd}'`);
    }
    debug("return from endVisit()");
  }

  getMathML() {
    debug("CALL getMathML()");
    return this.mathml;
  }

};

// ---------------------------------------------------------------------------
getSVG = function(fname, dir) {
  var contents, fullpath;
  assert(dir && isDir(dir), "getSVG(): No search dir set");
  debug(`getSVG(): fname: ${fname}`);
  assert(isSimpleFileName(fname), "getSVG(): svg file should be simple file name");
  assert(fileExt(fname) === '.svg', "getSVG(): svg file should end with .svg");
  assert(isFile(fname), `getSVG(): file '${fname}' does not exist or is not a file`);
  fullpath = pathTo(fname, dir);
  debug(`getSVG(): fullpath: '${fullpath}'`);
  contents = slurp(fullpath);
  return `<semantics><annotation-xml encoding='SVG1.1'>
	     	${contents}
	     	</annotation-xml></semantics>`;
};

// ===========================================================================
//   Utilities
// ===========================================================================
isIntegerStr = function(str) {
  var _, lMatches, tail;
  assert(isString(str), "isIntegerStr(): not a string");
  if (lMatches = str.match(/^\d+(.*)$/)) {
    [_, tail] = lMatches;
    assert(!tail || tail.length === 0, "Invalid number");
    return true;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
isIdentifier = function(str) {
  var _, lMatches, tail;
  assert(isString(str), "isIdentifier(): not a string");
  if (lMatches = str.match(/^[A-Za-z_][A-Za-z0-9_]*(.*)$/)) {
    [_, tail] = lMatches;
    assert(!tail, "Invalid identifier");
    return true;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
