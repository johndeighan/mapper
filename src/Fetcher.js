// Generated by CoffeeScript 2.7.0
  // Fetcher.coffee
import {
  assert
} from '@jdeighan/base-utils/exceptions';

import {
  getOptions
} from '@jdeighan/base-utils/utils';

import {
  dbg,
  dbgEnter,
  dbgReturn,
  dbgYield,
  dbgResume
} from '@jdeighan/base-utils/debug';

import {
  isString,
  isInteger,
  isHash,
  isIterable,
  isFunction,
  isEmpty,
  nonEmpty,
  undef,
  defined,
  notdefined,
  rtrim,
  OL
} from '@jdeighan/coffee-utils';

import {
  indentLevel,
  splitLine,
  getOneIndent,
  undented
} from '@jdeighan/coffee-utils/indent';

import {
  toArray,
  toBlock
} from '@jdeighan/coffee-utils/block';

import {
  parseSource,
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

// ---------------------------------------------------------------------------
export var Fetcher = class Fetcher {
  constructor(hInput, options = {}) {
    var addLevel, content, done, fullpath, source, value;
    // --- Valid options:
    //        addLevel - num of levels to add to each line
    //                   unless the line is empty
    dbgEnter("Fetcher", hInput, options);
    // --- hInput can be:
    //        1. a plain string
    //        2. a hash with keys 'source' and/or 'content',
    //        3. an iterator

      // --- We need to set:
    //        @hSourceInfo - information about the source of input
    //        @iterator    - must be an iterator

      // --- Handle options
    ({addLevel} = getOptions(options));
    this.addLevel = addLevel || 0;
    if (this.addLevel > 0) {
      dbg(`add ${this.addLevel} levels`);
    }
    if (isString(hInput)) {
      dbg("string passed as hInput");
      this.hSourceInfo = {
        filename: '<unknown>'
      };
      content = toArray(hInput);
      this.iterator = content[Symbol.iterator]();
      dbg(`iterator is an array with ${content.length} items`);
    } else if (isHash(hInput)) {
      dbg("hash passed as hInput");
      ({source, content} = hInput);
      assert(defined(source) || defined(content), "No source or content");
      if (defined(source)) {
        this.hSourceInfo = parseSource(source);
      } else {
        dbg("No source, so filename is <unknown>");
        this.hSourceInfo = {
          filename: '<unknown>'
        };
      }
      if (defined(content)) {
        if (isString(content)) {
          content = toArray(content);
          dbg(`iterator is an array with ${content.length} items`);
        }
        assert(isIterable(content), "content not iterable");
        this.iterator = content[Symbol.iterator]();
      } else {
        dbg("No content - check for fullpath");
        fullpath = this.hSourceInfo.fullpath;
        assert(nonEmpty(fullpath), "No content and no fullpath");
        // --- ultimately, we want to create an iterator here
        //     rather than blindly reading the entire file
        dbg(`slurping ${fullpath}`);
        content = toArray(slurp(fullpath));
        this.iterator = content[Symbol.iterator]();
      }
    } else {
      dbg("iterable passed as hInput");
      this.hSourceInfo = {
        filename: '<unknown>'
      };
      assert(isIterable(hInput), "hInput not iterable");
      this.iterator = hInput[Symbol.iterator]();
    }
    // --- @hSourceInfo must exist and have a filename key
    dbg('hSourceInfo', this.hSourceInfo);
    assert(nonEmpty(this.hSourceInfo.filename), "parseSource returned no filename");
    this.lineNum = 0;
    this.oneIndent = undef; // set from 1st line with indentation
    
      // --- invoke iterator to fill in @lookAheadLine
    ({value, done} = this.iterator.next());
    if (done) {
      this.lookAheadLine = undef;
    } else {
      this.lookAheadLine = value;
    }
    this.lookAheadNode = this.fetchNextNode();
    // --- This is set when a stopper func returns true
    //     Fetch will always return this next if it's set
    this.fetchStopperNode = undef; // set
    
    // --- NOTE: There is always a @lookAheadLine,
    //           except when we reach EOF
    this.init(); // option for additional initialization
    dbgReturn("Fetcher");
  }

  // ..........................................................
  init() {}

  // ..........................................................
  // --- returns hNode with keys:
  //        source
  //        lineNum
  //        str
  //        srcLevel - level in source code
  //        level    - includes added levels when #include'ing
  // --- OR undef at EOF
  fetch() {
    var save;
    dbgEnter("Fetcher.fetch");
    if (defined(this.fetchStopperNode)) {
      save = this.fetchStopperNode;
      this.fetchStopperNode = undef;
      dbg("return stopper node");
      dbgReturn('Fetcher.fetch', save);
      return save;
    }
    if (defined(this.lookAheadNode)) {
      save = this.lookAheadNode;
      this.lookAheadNode = this.fetchNextNode();
      dbg("return look ahead node");
      dbgReturn('Fetcher.fetch', save);
      return save;
    }
    dbgReturn("Fetcher.fetch", undef);
    return undef;
  }

  // ..........................................................
  peek() {
    dbgEnter("Fetcher.peek");
    if (defined(this.fetchStopperNode)) {
      dbgReturn('Fetcher.peek', this.fetchStopperNode);
      return this.fetchStopperNode;
    }
    if (defined(this.lookAheadNode)) {
      dbgReturn('Fetcher.peek', this.lookAheadNode);
      return this.lookAheadNode;
    }
    dbgReturn('Fetcher.peek', undef);
    return undef;
  }

  // ..........................................................
  // --- Returns the next available Node
  //        - hNode.str includes any extension lines
  fetchNextNode() {
    var hNode, level, newlevel, next, nextLevel, nextStr, orgLineNum, str;
    dbgEnter('Fetcher.fetchNextNode');
    next = this.fetchNextStr();
    if (notdefined(next)) {
      dbgReturn("Fetcher.fetchNextNode", undef);
      return undef;
    }
    // --- NOTE: str is typically a string,
    //           but it can be an arbitrary JavaScript value
    [level, str] = next;
    // --- save current line number in case there are extension lines
    orgLineNum = this.lineNum;
    dbg('orgLineNum', orgLineNum);
    if (isString(str)) {
      // --- Check for extension lines
      while (isString(this.lookAheadLine) && (indentLevel(this.lookAheadLine, this.oneIndent) >= level + 2)) {
        // --- since @lookAheadLine is defined,
        //     we know that @fetchNextStr() won't return undef
        [nextLevel, nextStr] = this.fetchNextStr();
        str += this.extSep(str, nextStr) + nextStr;
      }
      if (isEmpty(str)) {
        newlevel = 0;
      } else {
        newlevel = level + this.addLevel;
      }
    } else {
      newlevel = 0;
    }
    dbg("create Node object");
    hNode = new Node({
      str,
      level: newlevel,
      source: this.sourceInfoStr(orgLineNum),
      lineNum: orgLineNum
    });
    dbgReturn("Fetcher.fetchNextNode", hNode);
    return hNode;
  }

  // ..........................................................
  // --- Gets the next [level, str] (or undef), where
  //        - undef is returned at EOF
  //        - __END__ acts like EOF
  //        - if @oneIndent not initially set, set it if:
  //             - item is a string
  //             - item has indentation
  //        - @lineNum is incremented if not EOF
  fetchNextStr() {
    var done, result, save, value;
    dbgEnter('Fetcher.fetchNextStr');
    if (notdefined(this.lookAheadLine)) {
      // --- indicates EOF
      dbg('lookAhead empty');
      dbgReturn('Fetcher.fetchNextStr', undef);
      return undef;
    }
    save = this.lookAheadLine; // save for later return
    dbg('@lookAheadLine saved', save);
    // --- Refill @lookAheadLine
    ({value, done} = this.iterator.next());
    if (done) {
      dbg("iterator returned done = true");
      this.lookAheadLine = undef; // we're at EOF
    } else if (isString(value) && (value === '__END__')) {
      dbg("found __END__");
      this.lookAheadLine = undef; // we're at EOF
    } else {
      dbg(`GOT ${OL(value)} from iterator, put in @lookAheadLine`);
      this.lookAheadLine = value;
      // --- Try to set @oneIndent
      if (notdefined(this.oneIndent) && isString(value)) {
        // --- will return undef if no indentation
        this.oneIndent = getOneIndent(value);
      }
    }
    this.lineNum += 1;
    dbg(`INC lineNum to ${this.lineNum}`);
    if (isString(save)) {
      result = splitLine(save, this.oneIndent);
    } else {
      result = [0, save];
    }
    dbgReturn('Fetcher.fetchNextStr', result);
    return result;
  }

  // ..........................................................
  extSep(str, nextStr) {
    // --- can be overridden
    return ' ';
  }

  // ..........................................................
  sourceInfoStr(lineNum) {
    var result;
    // --- override in FetcherEx
    dbgEnter('Fetcher.sourceInfoStr', lineNum);
    assert(isInteger(lineNum), `Bad lineNum: ${OL(lineNum)}`);
    result = `${this.hSourceInfo.filename}/${lineNum}`;
    dbgReturn('Fetcher.sourceInfoStr', result);
    return result;
  }

  // ..........................................................
  // --- GENERATOR
  * all(stopperFunc = undef) {
    var hNode;
    // --- If you provide a stopper func, and you want to
    //     skip the line that you stop on,
    //     then you'll need to fetch it when done
    dbgEnter("Fetcher.all");
    while (defined(hNode = this.fetch())) {
      if (defined(stopperFunc) && stopperFunc(hNode)) {
        this.fetchStopperNode = hNode;
        dbgReturn('Fetcher.all');
        return;
      }
      dbgYield("Fetcher.all", hNode);
      yield hNode;
      dbgResume("Fetcher.all");
    }
    dbgReturn("Fetcher.all");
  }

  // ..........................................................
  getBlock(stopperFunc = undef, oneIndent = "\t") {
    var hNode, lLines, ref, result;
    dbgEnter("Fetcher.getBlock", stopperFunc, oneIndent);
    lLines = [];
    ref = this.all(stopperFunc);
    for (hNode of ref) {
      dbg('hNode', hNode);
      lLines.push(hNode.getLine({oneIndent}));
    }
    result = this.finalizeBlock(undented(toBlock(lLines)));
    dbgReturn("Fetcher.getBlock", result);
    return result;
  }

  // ..........................................................
  finalizeBlock(block) {
    return block;
  }

};
