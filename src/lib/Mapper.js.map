{
  "version": 3,
  "file": "Mapper.js",
  "sourceRoot": "..\\..\\",
  "sources": [
    "src\\lib\\Mapper.coffee"
  ],
  "names": [],
  "mappings": ";AAAe;AAEf,OAAA;EACC,KADD;EACQ,IADR;EACc,EADd;EACkB,KADlB;EACyB,OADzB;EACkC,UADlC;EAEC,SAFD;EAEY,aAFZ;EAE2B,UAF3B;EAGC,QAHD;EAGW,MAHX;EAGmB,OAHnB;EAG4B,UAH5B;EAGwC,UAHxC;EAGoD,QAHpD;EAIC,OAJD;EAIU,QAJV;EAIoB,OAJpB;EAI6B,SAJ7B;CAAA,MAAA;;AAMA,OAAA;EAAQ,MAAR;EAAgB,KAAhB;CAAA,MAAA;;AACA,OAAA;EAAQ,GAAR;CAAA,MAAA;;AACA,OAAA;EACC,GADD;EACM,QADN;EACgB,SADhB;CAAA,MAAA;;AAGA,OAAA;EAAQ,QAAR;CAAA,MAAA;;AACA,OAAA;EAAQ,WAAR;EAAqB,SAArB;CAAA,MAAA;;AAEA,OAAA;EAAQ,IAAR;CAAA,MAAA;;AACA,OAAA;EAAQ,MAAR;CAAA,MAAA,0BAjBe;;;;;;;;;;AA4Bf,OAAA,IAAa,SAAN,MAAA,OAAA,QAAqB,OAArB;EAEN,WAAa,CAAC,MAAD,EAAS,UAAQ,CAAA,CAAjB,CAAA;IAEZ,QAAA,CAAS,QAAT,EAAmB,MAAnB,EAA2B,OAA3B;SACA,CAAM,MAAN,EAAc,OAAd,EADF;;IAIE,IAAC,CAAA,QAAD,CAAU,MAAV,EAAkB,IAAC,CAAA,WAAW,CAAC,QAA/B;IACA,IAAC,CAAA,QAAD,CAAU,KAAV,EAAkB,IAAC,CAAA,WAAW,CAAC,GAA/B;IACA,IAAC,CAAA,QAAD,CAAU,KAAV,EAAkB,IAAC,CAAA,aAAD,CAAA,CAAlB;IAEA,IAAC,CAAA,SAAD,GAAa,CAAA;IACb,IAAC,CAAA,SAAD,GAAa,GATf;;;IAYE,IAAC,CAAA,YAAD,CAAc,OAAd,EAAyB,IAAC,CAAA,WAA1B,EAAuC,IAAC,CAAA,YAAxC;IACA,IAAC,CAAA,YAAD,CAAc,SAAd,EAAyB,IAAC,CAAA,SAA1B,EAAuC,IAAC,CAAA,UAAxC;IACA,IAAC,CAAA,YAAD,CAAc,KAAd,EAAyB,IAAC,CAAA,KAA1B,EAAuC,IAAC,CAAA,MAAxC;IAEA,SAAA,CAAU,QAAV;EAlBY,CAAd;;;EAsBC,WAAa,CAAC,IAAD,CAAA;AAEZ,WAAO,OAAA,CAAQ,IAAC,CAAA,SAAS,CAAC,IAAD,CAAlB;EAFK,CAtBd;;;EA4BC,YAAc,CAAC,IAAD,EAAO,UAAP,EAAmB,MAAnB,CAAA;IAEb,IAAG,CAAE,IAAC,CAAA,SAAS,CAAC,QAAX,CAAoB,IAApB,CAAL;MACC,IAAC,CAAA,SAAS,CAAC,IAAX,CAAgB,IAAhB,EADD;;IAEA,IAAC,CAAA,SAAS,CAAC,IAAD,CAAV,GAAmB,CAClB,UADkB,EAElB,MAFkB;EAJN,CA5Bf;;;EAwCC,WAAa,CAAC,KAAD,CAAA;AAEd,QAAA,CAAA,EAAA,GAAA,EAAA,UAAA,EAAA,GAAA,EAAA,GAAA,EAAA;IAAE,QAAA,CAAS,oBAAT,EAA+B,KAA/B;IACA,CAAA,CAAC,GAAD,CAAA,GAAQ,KAAR;IAEA,MAAA,CAAO,QAAA,CAAS,GAAT,CAAP,EAAsB,CAAA,OAAA,CAAA,CAAU,EAAA,CAAG,GAAH,CAAV,CAAA,CAAtB;AACA;IAAA,KAAA,qCAAA;;MACC,UAAA,GAAa,IAAC,CAAA,SAAS,CAAC,IAAD,CAAM,CAAC;MAC9B,IAAG,UAAU,CAAC,IAAX,CAAgB,IAAhB,CAAA,CAAsB,KAAtB,CAAH;QACC,SAAA,CAAU,oBAAV,EAAgC,IAAhC;AACA,eAAO,KAFR;;IAFD;IAMA,SAAA,CAAU,oBAAV,EAAgC,KAAhC;AACA,WAAO;EAbK,CAxCd;;;EAyDC,OAAS,CAAC,KAAD,CAAA;AAEV,QAAA,CAAA,EAAA,MAAA,EAAA,IAAA,EAAA;IAAE,QAAA,CAAS,gBAAT,EAA2B,KAA3B;IACA,MAAA,CAAQ,KAAA,YAAiB,IAAzB,EAAgC,CAAA,SAAA,CAAA,CAAY,EAAA,CAAG,KAAH,CAAZ,CAAA,CAAhC;IACA,CAAA,CAAC,IAAD,CAAA,GAAS,KAAT;IACA,IAAG,IAAH;MACC,CAAA,GAAI,IAAC,CAAA,SAAS,CAAC,IAAD;MACd,MAAA,CAAO,MAAA,CAAO,CAAP,CAAP,EAAkB,CAAA,aAAA,CAAA,CAAgB,EAAA,CAAG,IAAH,CAAhB,CAAA,CAAlB;MACA,MAAA,GAAS,CAAC,CAAC,MAAM,CAAC,IAAT,CAAc,IAAd;MACT,MAAA,CAAO,UAAA,CAAW,MAAX,CAAP,EAA2B,CAAA,eAAA,CAAA,CAAkB,EAAA,CAAG,IAAH,CAAlB,CAAA,CAA3B;MACA,IAAA,GAAO,MAAA,CAAO,KAAP,EALR;KAAA,MAAA;MAOC,IAAA,GAAO,IAAC,CAAA,YAAD,CAAc,KAAd,EAPR;;IAQA,SAAA,CAAU,gBAAV,EAA4B,IAA5B;AACA,WAAO;EAdC,CAzDV;;;;;EA6EC,YAAc,CAAC,KAAD,CAAA;AAEf,QAAA,GAAA,EAAA;IAAE,CAAA,CAAC,IAAD,EAAO,GAAP,CAAA,GAAc,KAAd;IACA,MAAA,CAAO,UAAA,CAAW,IAAX,CAAP,EAAyB,CAAA,uBAAA,CAAA,CAA0B,IAA1B,CAAA,CAAzB;AACA,WAAO;EAJM,CA7Ef;;;EAqFC,WAAa,CAAC,KAAD,CAAA;AAEZ,WAAQ,KAAK,CAAC,GAAN,KAAa;EAFT,CArFd;;;EA2FC,YAAc,CAAC,KAAD,CAAA,EAAA;;;AAIb,WAAO;EAJM,CA3Ff;;;EAmGC,SAAW,CAAC,KAAD,CAAA;AAEZ,QAAA;IAAE,KAAA,GAAQ,aAAA,CAAc,KAAK,CAAC,GAApB;IACR,IAAG,OAAA,CAAQ,KAAR,CAAH;MACC,KAAK,CAAC,YAAN,GAAqB,KAAK,CAAC;AAC3B,aAAO,KAFR;KAAA,MAAA;AAIC,aAAO,MAJR;;EAHU,CAnGZ;;;EA8GC,UAAY,CAAC,KAAD,CAAA,EAAA;;;AAIX,WAAO;EAJI,CA9Gb;;;EAsHC,KAAO,CAAC,KAAD,CAAA;AAER,QAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,QAAA,EAAA;IAAE,QAAA,CAAS,cAAT;IACA,IAAG,OAAA,CAAQ,QAAA,GAAW,KAAK,CAAC,GAAG,CAAC,KAAV,CAAgB,2BAAhB,CAAnB,CAAH;;MAMC,CAAC,CAAD,EAAI,GAAJ,EAAS,MAAT,CAAA,GAAmB;MACnB,MAAA,CAAQ,GAAA,KAAO,SAAf,EAA2B,iBAA3B;MACA,KAAK,CAAC,IAAN,GAAa,CAAC,GAAD,EAAM,MAAN;MACb,MAAA,GAAS,KATV;KAAA,MAAA;MAWC,MAAA,GAAS,MAXV;;IAYA,SAAA,CAAU,cAAV,EAA0B,MAA1B;AACA,WAAO;EAhBD,CAtHR;;;;;;;EA8IC,MAAQ,CAAC,KAAD,CAAA;AAET,QAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,KAAA,EAAA,QAAA,EAAA,IAAA,EAAA;IAAE,QAAA,CAAS,eAAT,EAA0B,KAA1B,EAAF;;IAGE,CAAA,CAAC,GAAD,EAAM,MAAN,CAAA,GAAgB,KAAK,CAAC,IAAtB;IACA,MAAA,CAAO,QAAA,CAAS,GAAT,CAAP,EAAsB,yBAAtB;AACA,YAAO,GAAP;AAAA,WACM,QADN;QAEE,QAAA,GAAW,MAAM,CAAC,KAAP,CAAa,kCAAb,EAAf;QAKI,MAAA,CAAO,OAAA,CAAQ,QAAR,CAAP,EAA0B,CAAA,iBAAA,CAAA,CAAoB,GAApB,EAAA,CAAA,CAA2B,MAA3B,CAAA,CAA1B;QACA,CAAC,CAAD,EAAI,KAAJ,EAAW,IAAX,EAAiB,IAAjB,CAAA,GAAyB;QACzB,IAAG,IAAH;UACC,IAAA,GAAO,IAAI,CAAC,IAAL,CAAA,EADR;;QAEA,IAAG,KAAH;UACC,GAAA,CAAI,CAAA,YAAA,CAAA,CAAe,IAAf,CAAA,KAAA,CAAA,CAA2B,IAA3B,CAAA,CAAA,CAAJ;UACA,OAAO,CAAC,GAAG,CAAC,IAAD,CAAX,GAAoB,KAFrB;SAAA,MAAA;UAIC,GAAA,CAAI,CAAA,QAAA,CAAA,CAAW,IAAX,CAAA,KAAA,CAAA,CAAuB,IAAvB,CAAA,CAAA,CAAJ;UACA,IAAC,CAAA,QAAD,CAAU,IAAV,EAAgB,IAAhB,EALD;;QAMA,SAAA,CAAU,eAAV,EAA2B,KAA3B;AACA,eAAO;AAlBT;eAoBE,KAAA,CAAM,CAAA,iBAAA,CAAA,CAAoB,EAAA,CAAG,GAAH,CAApB,CAAA,CAAN;AApBF;EAPO;;AAhJF,EA5BQ;;;;;;;;;;AAkNf,OAAA,IAAO,GAAA,GAAM,QAAA,CAAC,KAAD,EAAQ,cAAY,MAApB,EAA4B,WAAS,CAAA,CAArC,CAAA;AAEb,MAAA,OAAA,EAAA,CAAA,EAAA,IAAA,EAAA,GAAA,EAAA,MAAA,EAAA;EAAC,QAAA,CAAS,KAAT,EAAgB,KAAhB,EAAuB,WAAvB,EAAoC,QAApC;EAEA,QAAA,GAAW,UAAA,CAAW,QAAX,EAAqB;IAC/B,EAAA,EAAI,OAD2B;IAE/B,SAAA,EAAW;EAFoB,CAArB,EAFZ;;;;;;;EAaC,IAAG,OAAA,CAAQ,WAAR,CAAH;IACC,GAAA,CAAI,oDAAJ;IAEA,OAAA,GAAU;IACV,GAAA,CAAI,kBAAJ,EAAwB,OAAxB;IACA,KAAA,6CAAA;;MACC,IAAG,OAAA,CAAQ,IAAR,CAAH;QACC,OAAA,GAAU,GAAA,CAAI,OAAJ,EAAa,IAAb,EAAmB,QAAnB;QACV,GAAA,CAAI,aAAJ,EAAmB,OAAnB,EAFD;;IADD;IAIA,SAAA,CAAU,KAAV,EAAiB,OAAjB;AACA,WAAO,QAVR;;EAYA,MAAA,CAAO,OAAA,CAAQ,WAAR,CAAP,EAA6B,0BAA7B;EAEA,MAAA,GAAS,IAAI,WAAJ,CAAgB,KAAhB;EACT,MAAA,CAAQ,MAAA,YAAkB,MAA1B,EAAmC,uBAAnC;AACA,UAAO,QAAQ,CAAC,EAAhB;AAAA,SACM,OADN;MAEE,MAAA,GAAS,MAAM,CAAC,QAAP,CAAgB,QAAQ,CAAC,SAAzB;AADL;AADN,SAGM,OAHN;MAIE,MAAA,GAAS,MAAM,CAAC,QAAP,CAAgB,QAAhB;AADL;AAHN;MAME,KAAA,CAAM,wCAAN;AANF;EAOA,SAAA,CAAU,KAAV,EAAiB,MAAjB;AACA,SAAO;AAvCK",
  "sourcesContent": [
    "# Mapper.coffee\r\n\r\nimport {\r\n\tundef, pass, OL, rtrim, defined, notdefined,\r\n\tescapeStr, isHashComment, getOptions,\r\n\tisString, isHash, isArray, isFunction, isIterable, isObject,\r\n\tisEmpty, nonEmpty, isClass, className,\r\n\t} from '@jdeighan/base-utils'\r\nimport {assert, croak} from '@jdeighan/base-utils/exceptions'\r\nimport {LOG} from '@jdeighan/base-utils/log'\r\nimport {\r\n\tdbg, dbgEnter, dbgReturn,\r\n\t} from '@jdeighan/base-utils/debug'\r\nimport {fromTAML} from '@jdeighan/base-utils/taml'\r\nimport {splitPrefix, splitLine} from '@jdeighan/base-utils/indent'\r\n\r\nimport {Node} from '@jdeighan/mapper/node'\r\nimport {Getter} from '@jdeighan/mapper/getter'\r\n\r\n# ---------------------------------------------------------------------------\r\n# class Mapper - adds:\r\n#    1. registering special types of nodes, by default:\r\n#          - empty lines\r\n#          - comments\r\n#          - commands\r\n#    2. defines constants FILE, DIR and SRC\r\n#    3. implements command #define\r\n\r\nexport class Mapper extends Getter\r\n\r\n\tconstructor: (hInput, options={}) ->\r\n\r\n\t\tdbgEnter \"Mapper\", hInput, options\r\n\t\tsuper hInput, options\r\n\r\n\t\t# --- These never change\r\n\t\t@setConst 'FILE', @hSourceInfo.fileName\r\n\t\t@setConst 'DIR',  @hSourceInfo.dir\r\n\t\t@setConst 'SRC',  @sourceInfoStr()\r\n\r\n\t\t@hSpecials = {}\r\n\t\t@lSpecials = []    # checked in this order\r\n\r\n\t\t# --- These must be bound to a specific object when called\r\n\t\t@registerType 'empty',   @isEmptyLine, @mapEmptyLine\r\n\t\t@registerType 'comment', @isComment,   @mapComment\r\n\t\t@registerType 'cmd',     @isCmd,       @mapCmd\r\n\r\n\t\tdbgReturn \"Mapper\"\r\n\r\n\t# ..........................................................\r\n\r\n\tisValidType: (type) ->\r\n\r\n\t\treturn defined(@hSpecials[type])\r\n\r\n\t# ..........................................................\r\n\r\n\tregisterType: (type, recognizer, mapper) ->\r\n\r\n\t\tif ! @lSpecials.includes(type)\r\n\t\t\t@lSpecials.push(type)\r\n\t\t@hSpecials[type] = {\r\n\t\t\trecognizer\r\n\t\t\tmapper\r\n\t\t\t}\r\n\t\treturn\r\n\r\n\t# ..........................................................\r\n\r\n\tgetItemType: (hNode) ->\r\n\r\n\t\tdbgEnter \"Mapper.getItemType\", hNode\r\n\t\t{str} = hNode\r\n\r\n\t\tassert isString(str), \"str is #{OL(str)}\"\r\n\t\tfor type in @lSpecials\r\n\t\t\trecognizer = @hSpecials[type].recognizer\r\n\t\t\tif recognizer.bind(this)(hNode)\r\n\t\t\t\tdbgReturn \"Mapper.getItemType\", type\r\n\t\t\t\treturn type\r\n\r\n\t\tdbgReturn \"Mapper.getItemType\", undef\r\n\t\treturn undef\r\n\r\n\t# ..........................................................\r\n\r\n\tmapNode: (hNode) ->\r\n\r\n\t\tdbgEnter \"Mapper.mapNode\", hNode\r\n\t\tassert (hNode instanceof Node), \"hNode is #{OL(hNode)}\"\r\n\t\t{type} = hNode\r\n\t\tif type\r\n\t\t\th = @hSpecials[type]\r\n\t\t\tassert isHash(h), \"Unknown type #{OL(type)}\"\r\n\t\t\tmapper = h.mapper.bind(this)\r\n\t\t\tassert isFunction(mapper), \"Bad mapper for #{OL(type)}\"\r\n\t\t\tuobj = mapper(hNode)\r\n\t\telse\r\n\t\t\tuobj = @mapToUserObj(hNode)\r\n\t\tdbgReturn \"Mapper.mapNode\", uobj\r\n\t\treturn uobj\r\n\r\n\t# ..........................................................\r\n\t# designed to override\r\n\t# only receives nodes without a type\r\n\r\n\tmapToUserObj: (hNode) ->\r\n\r\n\t\t{type, str} = hNode\r\n\t\tassert notdefined(type), \"mapToUserObj(): type = #{type}\"\r\n\t\treturn str\r\n\r\n\t# ==========================================================\r\n\r\n\tisEmptyLine: (hNode) ->\r\n\r\n\t\treturn (hNode.str == '')\r\n\r\n\t# ..........................................................\r\n\r\n\tmapEmptyLine: (hNode) ->\r\n\r\n\t\t# --- default: remove empty lines\r\n\t\t#     return '' to keep empty lines\r\n\t\treturn undef\r\n\r\n\t# ==========================================================\r\n\r\n\tisComment: (hNode) ->\r\n\r\n\t\thInfo = isHashComment(hNode.str)\r\n\t\tif defined(hInfo)\r\n\t\t\thNode._commentText = hInfo.text\r\n\t\t\treturn true\r\n\t\telse\r\n\t\t\treturn false\r\n\r\n\t# ..........................................................\r\n\r\n\tmapComment: (hNode) ->\r\n\r\n\t\t# --- default: remove comments\r\n\t\t# --- To keep comments, return \"# #{hNode._commentText}\"\r\n\t\treturn undef\r\n\r\n\t# ==========================================================\r\n\r\n\tisCmd: (hNode) ->\r\n\r\n\t\tdbgEnter \"Mapper.isCmd\"\r\n\t\tif defined(lMatches = hNode.str.match(///^\r\n\t\t\t\t\\#\r\n\t\t\t\t([A-Za-z_]\\w*)   # name of the command\r\n\t\t\t\t\\s*\r\n\t\t\t\t(.*)             # argstr for command\r\n\t\t\t\t$///))\r\n\t\t\t[_, cmd, argstr] = lMatches\r\n\t\t\tassert (cmd != 'include'), \"#include found!\"\r\n\t\t\thNode.uobj = {cmd, argstr}\r\n\t\t\tresult = true\r\n\t\telse\r\n\t\t\tresult = false\r\n\t\tdbgReturn \"Mapper.isCmd\", result\r\n\t\treturn result\r\n\r\n\t# ..........................................................\r\n\t# --- mapCmd returns a mapped object, or\r\n\t#        undef to produce no output\r\n\t# Override must 1st handle its own commands,\r\n\t#    then call the base class mapCmd\r\n\r\n\tmapCmd: (hNode) ->\r\n\r\n\t\tdbgEnter \"Mapper.mapCmd\", hNode\r\n\r\n\t\t# --- isCmd() put these keys here\r\n\t\t{cmd, argstr} = hNode.uobj\r\n\t\tassert nonEmpty(cmd), \"mapCmd() with empty cmd\"\r\n\t\tswitch cmd\r\n\t\t\twhen 'define'\r\n\t\t\t\tlMatches = argstr.match(///^\r\n\t\t\t\t\t\t(env\\.)?\r\n\t\t\t\t\t\t([A-Za-z_][\\w\\.]*)   # name of the variable\r\n\t\t\t\t\t\t(.*)\r\n\t\t\t\t\t\t$///)\r\n\t\t\t\tassert defined(lMatches), \"Bad #define cmd: #{cmd} #{argstr}\"\r\n\t\t\t\t[_, isEnv, name, tail] = lMatches\r\n\t\t\t\tif tail\r\n\t\t\t\t\ttail = tail.trim()\r\n\t\t\t\tif isEnv\r\n\t\t\t\t\tdbg \"set env var #{name} to '#{tail}'\"\r\n\t\t\t\t\tprocess.env[name] = tail\r\n\t\t\t\telse\r\n\t\t\t\t\tdbg \"set var #{name} to '#{tail}'\"\r\n\t\t\t\t\t@setConst name, tail\r\n\t\t\t\tdbgReturn \"Mapper.mapCmd\", undef\r\n\t\t\t\treturn undef\r\n\t\t\telse\r\n\t\t\t\tcroak \"Unknown command: #{OL(cmd)}\"\r\n\r\n\t\t\t\t# --- don't throw exception\r\n\t\t\t\t#     check for unknown commands in visitCmd()\r\n#\t\t\t\tdbgReturn \"Mapper.mapCmd\", hNode.uobj\r\n#\t\t\t\treturn hNode.uobj\r\n\r\n# ===========================================================================\r\n# --- mapperClass must be a subclass of Mapper or an array\r\n#     of subclasses of Mapper.\r\n\r\nexport map = (input, mapperClass=Mapper, hOptions={}) ->\r\n\r\n\tdbgEnter \"map\", input, mapperClass, hOptions\r\n\r\n\thOptions = getOptions hOptions, {\r\n\t\tas: 'block',\r\n\t\toneIndent: '\\t'\r\n\t\t}\r\n\r\n\t# --- Valid options:\r\n\t#        as: ('block' | 'lines')\r\n\t#        oneIndent: <string>  default: TAB\r\n\r\n\t# --- mapperClass can be an array - the input is processed\r\n\t#     by each array element sequentially\r\n\tif isArray(mapperClass)\r\n\t\tdbg \"mapperClass is an array - using each array element\"\r\n\r\n\t\tcontent = input\r\n\t\tdbg 'original content', content\r\n\t\tfor item in mapperClass\r\n\t\t\tif defined(item)\r\n\t\t\t\tcontent = map(content, item, hOptions)\r\n\t\t\t\tdbg 'new content', content\r\n\t\tdbgReturn \"map\", content\r\n\t\treturn content\r\n\r\n\tassert isClass(mapperClass), \"mapper not a constructor\"\r\n\r\n\tmapper = new mapperClass(input)\r\n\tassert (mapper instanceof Mapper), \"not a Mapper instance\"\r\n\tswitch hOptions.as\r\n\t\twhen 'block'\r\n\t\t\tresult = mapper.getBlock(hOptions.oneIndent)\r\n\t\twhen 'lines'\r\n\t\t\tresult = mapper.getLines(hOptions)\r\n\t\telse\r\n\t\t\tcroak \"option 'as' must be 'block' or 'lines'\"\r\n\tdbgReturn \"map\", result\r\n\treturn result\r\n"
  ]
}