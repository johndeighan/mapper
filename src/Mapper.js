// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  assert,
  undef,
  pass,
  croak,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isEmpty,
  nonEmpty
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
//   class Mapper
//       handles:
//          #include
//          #define
//          const replacement
export var Mapper = class Mapper extends Getter {
  constructor(source = undef, collection = undef, hOptions = {}) {
    debug("enter Mapper()");
    super(source, collection, hOptions);
    // --- These never change
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    // --- This needs to be kept updated
    this.setConst('LINE', this.lineNum);
    debug("return from Mapper()");
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    debug(`enter incLineNum(${inc})`);
    super.incLineNum(inc);
    this.setConst('LINE', this.lineNum);
    debug("return from incLineNum()");
  }

  // ..........................................................
  // --- override
  //     LATER: maintain an ordered hash of types along with
  //            methods to check for those types
  getItemType(hLine) {
    var line, str;
    debug("enter Mapper.getItemType()", hLine);
    super.getItemType(hLine); // sets 'prefix' and 'str' for strings
    ({line, str} = hLine);
    if (isString(line)) {
      assert(isString(str), `str is ${OL(str)}`);
      // --- check for empty line
      if (this.isEmptyLine(str, hLine)) {
        debug("return from getItemType()", 'empty');
        return 'empty';
      // --- check for comment
      } else if (this.isComment(str, hLine)) {
        debug("return from getItemType()", 'comment');
        return 'comment';
      // --- check for cmd
      } else if (this.isCmd(str, hLine)) {
        debug("return from getItemType()", 'cmd');
        return 'cmd';
      }
    }
    debug("return from getItemType()", undef);
    return undef;
  }

  // ..........................................................
  isEmptyLine(str, hLine) {
    return str === '';
  }

  // ..........................................................
  isComment(str, hLine) {
    var _, comment, lMatches;
    if (lMatches = str.match(/^\s*\#(?:\s+(.*))?$/)) { // a hash character
      [_, comment] = lMatches;
      hLine.comment = comment;
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  isCmd(str, hLine) {
    var _, argstr, cmd, flag, lMatches;
    debug("enter Mapper.isCmd()");
    if (lMatches = str.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      [_, cmd, argstr] = lMatches;
      hLine.cmd = cmd;
      hLine.argstr = argstr;
      flag = true;
    } else {
      // --- not a command
      flag = false;
    }
    debug("return from Mapper.isCmd()", flag);
    return flag;
  }

  // ..........................................................
  // --- override
  handleItemType(type, hLine) {
    var line, uobj;
    debug("enter Mapper.handleItemType()", type, hLine);
    assert(defined(hLine), "hLine is undef");
    ({line} = hLine);
    switch (type) {
      case 'empty':
        uobj = this.handleEmptyLine(hLine);
        break;
      case 'comment':
        uobj = this.handleComment(hLine);
        break;
      case 'cmd':
        uobj = this.handleCmd(hLine);
        break;
      default:
        croak(`Unknown item type: ${OL(type)}`);
    }
    debug("return from Mapper.handleItemType()", uobj);
    return uobj;
  }

  // ..........................................................
  handleEmptyLine(hLine) {
    // --- can override
    //     line may contain whitespace

    // --- return '' to keep empty lines
    return undef;
  }

  // ..........................................................
  handleComment(hLine) {
    debug("in Mapper.handleComment()");
    // --- return undef to remove comments
    return hLine.line;
  }

  // ..........................................................
  // --- handleCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class handleCmd
  handleCmd(hLine) {
    var _, argstr, cmd, isEnv, lMatches, name, tail;
    debug("enter Mapper.handleCmd()", hLine);
    // --- isCmd() put these keys here
    ({cmd, argstr} = hLine);
    // --- Each case should return
    switch (cmd) {
      case 'define':
        if (lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/)) { // name of the variable
          [_, isEnv, name, tail] = lMatches;
          if (tail) {
            tail = tail.trim();
          }
          if (isEnv) {
            debug(`set env var ${name} to '${tail}'`);
            process.env[name] = tail;
          } else {
            debug(`set var ${name} to '${tail}'`);
            this.setConst(name, tail);
          }
        }
        debug("return from Mapper.handleCmd()", undef);
        return undef;
      default:
        croak(`Unknown command: #${cmd}`);
    }
    return croak("Not all cases return");
  }

};

// ===========================================================================
export var doMap = function(inputClass, source, content = undef, hOptions = {}) {
  var oInput, result;
  // --- Valid options:
  //        logLines
  debug("enter doMap()", inputClass, source, content);
  assert(inputClass != null, "Missing input class");
  oInput = new inputClass(source, content);
  assert(oInput instanceof Mapper, "doMap() requires a Mapper or subclass");
  debug("got oInput object");
  result = oInput.getBlock(hOptions);
  debug("return from doMap()", result);
  return result;
};
