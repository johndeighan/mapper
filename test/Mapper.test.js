// Generated by CoffeeScript 2.7.0
// Mapper.test.coffee
var MapperTester, simple, tester;

import assert from 'assert';

import {
  UnitTester,
  UnitTesterNorm
} from '@jdeighan/unit-tester';

import {
  undef,
  pass,
  isEmpty,
  isComment,
  isString
} from '@jdeighan/coffee-utils';

import {
  indentLevel,
  undented,
  splitLine,
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  mydir,
  mkpath
} from '@jdeighan/coffee-utils/fs';

import {
  Mapper,
  doMap
} from '@jdeighan/mapper';

simple = new UnitTesterNorm();

/*
	class Mapper should handle the following:
		- #include <file> statements
		- get(), peek(), unget(), skip()
		- overriding of mapLine() to return alternate strings or objects
		- fetch() and fetchBlock() inside mapLine()
*/
// ---------------------------------------------------------------------------
// --- test get(), peek(), unget(), skip()
(function() {
  var input, lPair, pair;
  input = new Mapper(`abc
	def
		ghi`, import.meta.url);
  // --- lPair is [item, level]
  lPair = input.peek();
  simple.equal(41, lPair, ['abc', 0]);
  lPair = input.peek();
  simple.equal(44, lPair, ['abc', 0]);
  lPair = input.get();
  simple.equal(47, lPair, ['abc', 0]);
  lPair = input.get();
  simple.equal(50, lPair, ['def', 1]);
  input.unget(lPair);
  lPair = input.get();
  simple.equal(54, lPair, ['def', 1]);
  lPair = input.get();
  simple.equal(57, lPair, ['ghi', 2]);
  input.unget(lPair);
  input.skip();
  pair = input.get();
  return simple.equal(62, pair, undef);
})();

// ---------------------------------------------------------------------------
MapperTester = class MapperTester extends UnitTester {
  transformValue(input) {
    var oInput;
    // --- input may be a string or a Mapper or subclass
    if (isString(input)) {
      oInput = new Mapper(input, import.meta.url);
    } else {
      assert(input instanceof Mapper, "input should be a Mapper object");
      oInput = input;
    }
    return oInput.getBlock();
  }

};

tester = new MapperTester();

// ---------------------------------------------------------------------------
// --- Test basic reading till EOF
tester.equal(86, `abc
def`, `abc
def`);

tester.equal(94, `abc

def`, `abc

def`);

(function() {
  var TestMapper, str;
  TestMapper = class TestMapper extends Mapper {
    // --- This removes blank lines
    mapLine(line, level) {
      if (line === '') {
        return undef;
      } else {
        return line;
      }
    }

  };
  str = `abc

def`;
  tester.equal(120, new TestMapper(str, import.meta.url), `abc
def`);
  return simple.equal(125, doMap(TestMapper, str, import.meta.url), `abc
def`);
})();

// ---------------------------------------------------------------------------
// --- Test basic use of mapping function
(function() {
  var TestMapper;
  TestMapper = class TestMapper extends Mapper {
    // --- This maps all non-empty lines to the string 'x'
    mapLine(line, level) {
      if (line === '') {
        return undef;
      } else {
        return 'x';
      }
    }

  };
  return tester.equal(144, new TestMapper(`abc

def`, import.meta.url), `x
x`);
})();

// ---------------------------------------------------------------------------
// --- Test ability to access 'this' object from a mapper
//     Goal: remove not only blank lines, but also the line following
(function() {
  var TestMapper;
  TestMapper = class TestMapper extends Mapper {
    // --- Remove blank lines PLUS the line following a blank line
    mapLine(line, level) {
      var follow;
      if (line === '') {
        follow = this.fetch();
        return undef;
      } else {
        return line;
      }
    }

  };
  return tester.equal(170, new TestMapper(`abc

def
ghi`, import.meta.url), `abc
ghi`);
})();

// ---------------------------------------------------------------------------
// --- Test implementing continuation lines
(function() {
  var TestMapper;
  TestMapper = class TestMapper extends Mapper {
    mapLine(line, level) {
      var next;
      if (line === '' || isComment(line)) {
        return undef; // skip comments and blank lines
      }
      while ((this.lBuffer.length > 0) && (indentLevel(this.lBuffer[0]) >= level + 2)) {
        next = this.lBuffer.shift();
        line += ' ' + undented(next);
      }
      return line;
    }

  };
  return tester.equal(199, new TestMapper(`str = compare(
		"abcde",
		expected
		)

call func
		with multiple
		long parameters

# --- DONE ---`, import.meta.url), `str = compare( "abcde", expected )
call func with multiple long parameters`);
})();

// ---------------------------------------------------------------------------
// --- Test overriding the class
(function() {
  var TestMapper;
  TestMapper = class TestMapper extends Mapper {
    mapLine(line, level) {
      if (isEmpty(line)) {
        return undef;
      }
      if (line === 'abc') {
        return '123';
      } else if (line === 'def') {
        return '456';
      } else {
        return line;
      }
    }

  };
  return tester.equal(235, new TestMapper(`abc

def`, import.meta.url), `123
456`);
})();

// ---------------------------------------------------------------------------
// --- Test #include
tester.equal(249, `abc
	#include title.md
def`, `abc
	title
	=====
def`);

// ---------------------------------------------------------------------------
// --- Test advanced use of mapping function
//        - skip comments and blank lines
//        - replace reactive statements
(function() {
  var TestMapper;
  TestMapper = class TestMapper extends Mapper {
    mapLine(line, level) {
      var _, expr, lMatches, varName;
      if (isEmpty(line) || line.match(/^#\s/)) {
        return undef;
      }
      if (lMatches = line.match(/^(?:([A-Za-z][A-Za-z0-9_]*)\s*)?\<\=\=\s*(.*)$/)) { // variable name
        [_, varName, expr] = lMatches;
        return `\`$:{\n${varName} = ${expr}\n}\``;
      } else {
        return line;
      }
    }

  };
  return tester.equal(286, new TestMapper(`abc
myvar    <==     2 * 3

def`, import.meta.url), `abc
\`$:{
myvar = 2 * 3
}\`
def`);
})();

// ---------------------------------------------------------------------------
// --- Test #include inside block processed by fetchBlock()
(function() {
  var TestParser, block, lPair, oInput, text;
  text = `p a paragraph
div:markdown
	#include title.md`;
  block = undef;
  TestParser = class TestParser extends Mapper {
    mapLine(line, level) {
      if (line === 'div:markdown') {
        block = this.fetchBlock(1);
      }
      return line;
    }

  };
  oInput = new TestParser(text, import.meta.url);
  lPair = oInput.get();
  simple.equal(320, lPair[0], 'p a paragraph');
  lPair = oInput.get();
  simple.equal(322, lPair[0], 'div:markdown');
  return simple.equal(323, block, '\ttitle\n\t=====');
})();

// ---------------------------------------------------------------------------
// --- Test blank lines inside a block
(function() {
  var TestParser, block, lPair, oInput;
  block = undef;
  TestParser = class TestParser extends Mapper {
    mapLine(line, level) {
      if (line === 'div:markdown') {
        block = this.fetchBlock(1);
      }
      return line;
    }

  };
  oInput = new TestParser(`p a paragraph
div:markdown
	line 1

	line 3`, import.meta.url);
  lPair = oInput.get();
  simple.equal(347, lPair[0], 'p a paragraph');
  lPair = oInput.get();
  simple.equal(349, lPair[0], 'div:markdown');
  return simple.equal(350, block, `line 1

line 3`);
})();

// ---------------------------------------------------------------------------
(function() {
  var TestParser, block, lPair, oInput, text;
  text = `p a paragraph
div:markdown
	#include title.md`;
  block = undef;
  TestParser = class TestParser extends Mapper {
    mapLine(line, level) {
      if (line === 'div:markdown') {
        block = this.fetchBlock(1);
      }
      return line;
    }

  };
  oInput = new TestParser(text, import.meta.url);
  lPair = oInput.get();
  simple.equal(376, lPair[0], 'p a paragraph');
  lPair = oInput.get();
  simple.equal(379, lPair[0], 'div:markdown');
  return simple.equal(381, block, '\ttitle\n\t=====');
})();

// ---------------------------------------------------------------------------
(function() {
  var text;
  text = `p a paragraph
div:markdown
	#include header.md`;
  /* Contents of files used:
  	```header.md
  	header
  	======

  		#include para.md
  	```

  	```para.md
  	para
  	----
  	```
   */
  return tester.equal(409, text, `p a paragraph
div:markdown
	header
	======

		para
		----`);
})();

// ---------------------------------------------------------------------------
// --- Test comment
tester.equal(423, `abc

# --- this is a comment

def`, `abc

# --- this is a comment

def`);

// ---------------------------------------------------------------------------
// --- Test using getAllPairs(), i.e. retrieving non-text
(function() {
  var GatherTester2, TestMapper2, cmdRE, tester2;
  GatherTester2 = class GatherTester2 extends UnitTesterNorm {
    transformValue(oInput) {
      assert(oInput instanceof Mapper, "oInput should be a Mapper object");
      return oInput.getAllPairs();
    }

  };
  tester2 = new GatherTester2();
  cmdRE = /^\s*\#([a-z][a-z_]*)\s*(.*)$/; // skip leading whitespace
  // command name
  // skipwhitespace following command
  // command arguments
  TestMapper2 = class TestMapper2 extends Mapper {
    mapLine(line, level) {
      var lMatches;
      lMatches = line.match(cmdRE);
      if (lMatches != null) {
        return {
          cmd: lMatches[1],
          argstr: lMatches[2]
        };
      } else {
        return line;
      }
    }

  };
  return tester2.equal(468, new TestMapper2(`abc
#if x==y
	def
#else
	ghi`, import.meta.url), [
    ['abc',
    0],
    [
      {
        cmd: 'if',
        argstr: 'x==y'
      },
      0
    ],
    ['def',
    1],
    [
      {
        cmd: 'else',
        argstr: ''
      },
      0
    ],
    ['ghi',
    1]
  ]);
})();
