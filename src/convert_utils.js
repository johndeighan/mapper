// Generated by CoffeeScript 2.5.1
// convert_utils.coffee
var hExtToEnvVar;

import {
  strict as assert
} from 'assert';

import {
  dirname,
  resolve,
  parse as parse_fname
} from 'path';

import CoffeeScript from 'coffeescript';

import marked from 'marked';

import sass from 'sass';

import yaml from 'js-yaml';

import {
  say,
  undef,
  pass,
  croak,
  log,
  isEmpty,
  nonEmpty,
  isComment,
  isString,
  unitTesting,
  escapeStr,
  firstLine
} from '@jdeighan/coffee-utils';

import {
  splitLine,
  indented,
  undented,
  tabify,
  untabify
} from '@jdeighan/coffee-utils/indent';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  svelteHtmlEsc
} from '@jdeighan/coffee-utils/svelte';

import {
  StringInput,
  CoffeeMapper,
  SassMapper
} from '@jdeighan/string-input';

import {
  getNeededImports
} from '@jdeighan/string-input/code';

// ---------------------------------------------------------------------------
//   isTAML - is the string valid TAML?
export var isTAML = function(input) {
  return firstLine(input).indexOf('---') === 0;
};

// ---------------------------------------------------------------------------
//   taml - convert valid TAML string to a JavaScript value
export var taml = function(str) {
  var header;
  debug(`enter taml('${escapeStr(str)}')`);
  if (str == null) {
    debug("return undef - str is not defined");
    return undef;
  }
  assert(isString(str), "taml(): not a string");
  header = firstLine(str);
  assert(header.indexOf('---') === 0, "taml(): not a TAML string");
  return yaml.load(untabify(str, 1));
};

// ---------------------------------------------------------------------------
//   tamlStringify - convert a data structure into a valid TAML string
export var tamlStringify = function(obj) {
  var str;
  if (obj == null) {
    return 'undef';
  }
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: false,
    lineWidth: -1
  });
  return "---\n" + tabify(str);
};

// ---------------------------------------------------------------------------
//   slurpTAML - read TAML from a file
export var slurpTAML = function(filepath) {
  var contents;
  contents = slurp(filepath);
  return taml(contents);
};

// ---------------------------------------------------------------------------
export var preprocessCoffee = function(code) {
  var newcode, oInput, strImports;
  oInput = new CoffeeMapper(code);
  newcode = oInput.getAllText();
  debug("call getNeededImports()");
  strImports = getNeededImports(newcode);
  debug(strImports, "strImports:");
  if (isEmpty(strImports)) {
    return newcode;
  } else {
    return `${strImports}\n${newcode}`;
  }
};

// ---------------------------------------------------------------------------
export var brewExpr = function(expr, force = false) {
  var err, newexpr, pos;
  if (unitTesting && !force) {
    return expr;
  }
  try {
    newexpr = CoffeeScript.compile(expr, {
      bare: true
    }).trim();
    // --- Remove any trailing semicolon
    pos = newexpr.length - 1;
    if (newexpr.substr(pos, 1) === ';') {
      newexpr = newexpr.substr(0, pos);
    }
  } catch (error) {
    err = error;
    croak(err, expr, "brewExpr");
  }
  return newexpr;
};

// ---------------------------------------------------------------------------
export var brewCoffee = function(text, force = false) {
  var err, newtext, script;
  debug("enter brewCoffee()");
  debug(text, "INPUT TEXT:");
  newtext = preprocessCoffee(text);
  debug(newtext, "NEW TEXT:");
  if (unitTesting && !force) {
    return newtext;
  }
  try {
    script = CoffeeScript.compile(newtext, {
      bare: true
    });
    debug(script, "SCRIPT:");
  } catch (error) {
    err = error;
    log(newtext, "Mapped Text:");
    croak(err, text, "Original Text");
  }
  return script;
};

// ---------------------------------------------------------------------------
export var markdownify = function(text) {
  var html, result;
  debug(`enter markdownify('${escapeStr(text)}')`);
  if (unitTesting) {
    debug("return original text");
    return text;
  }
  text = undented(text);
  html = marked(text, {
    grm: true,
    headerIds: false
  });
  debug(`marked returned '${escapeStr(html)}'`);
  result = svelteHtmlEsc(html);
  debug(`return '${escapeStr(result)}'`);
  return result;
};

// ---------------------------------------------------------------------------
export var sassify = function(text) {
  var newtext, oInput, result;
  oInput = new SassMapper(text);
  newtext = oInput.getAllText();
  if (unitTesting) {
    return newtext;
  }
  result = sass.renderSync({
    data: newtext,
    indentedSyntax: true,
    indentType: "tab"
  });
  return result.css.toString();
};

// ---------------------------------------------------------------------------
hExtToEnvVar = {
  '.md': 'dir_markdown',
  '.taml': 'dir_data',
  '.txt': 'dir_data'
};

// ---------------------------------------------------------------------------
export var getFileContents = function(fname, convert = false) {
  var base, contents, dir, envvar, ext, fullpath, root;
  debug(`enter getFileContents('${fname}')`);
  if (unitTesting) {
    debug("return - unit testing");
    return `Contents of ${fname}`;
  }
  ({root, dir, base, ext} = parse_fname(fname.trim()));
  assert(!root && !dir, "getFileContents():" + ` root='${root}', dir='${dir}'` + " - full path not allowed");
  envvar = hExtToEnvVar[ext];
  debug(`envvar = '${envvar}'`);
  assert(envvar, `getFileContents() doesn't work for ext '${ext}'`);
  dir = process.env[envvar];
  debug(`dir = '${dir}'`);
  assert(dir, `env var '${envvar}' not set for file extension '${ext}'`);
  fullpath = pathTo(base, dir); // guarantees that file exists
  debug(`fullpath = '${fullpath}'`);
  assert(fullpath, `getFileContents(): Can't find file ${fname}`);
  contents = slurp(fullpath);
  if (!convert) {
    debug("return - not converting");
    return contents;
  }
  switch (ext) {
    case '.md':
      return markdownify(contents);
    case '.taml':
      return taml(contents);
    case '.txt':
      return contents;
    default:
      return croak(`getFileContents(): No handler for ext '${ext}'`);
  }
};
