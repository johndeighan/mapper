// Generated by CoffeeScript 2.7.0
  // Mapper.coffee
import {
  LOG,
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  undef,
  pass,
  OL,
  rtrim,
  defined,
  escapeStr,
  className,
  isString,
  isHash,
  isArray,
  isFunction,
  isIterable,
  isObject,
  isEmpty,
  nonEmpty,
  isSubclassOf,
  isConstructor
} from '@jdeighan/coffee-utils';

import {
  splitPrefix,
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  parseSource,
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  Node
} from '@jdeighan/mapper/node';

import {
  Getter
} from '@jdeighan/mapper/getter';

// ---------------------------------------------------------------------------
export var Mapper = class Mapper extends Getter {
  // --- handles #define
  //     performs const substitution
  //     splits mapping into special lines and non-special lines
  constructor(hInput, options = {}) {
    dbgEnter("Mapper", hInput, options);
    super(hInput, options);
    // --- These never change
    this.setConst('FILE', this.hSourceInfo.filename);
    this.setConst('DIR', this.hSourceInfo.dir);
    this.setConst('SRC', this.sourceInfoStr());
    // --- This needs to be kept updated
    this.setConst('LINE', this.lineNum);
    this.hSpecials = {};
    this.lSpecials = []; // checked in this order
    
    // --- These must be bound to a specific object when called
    this.registerSpecialType('empty', this.isEmptyLine, this.mapEmptyLine);
    this.registerSpecialType('comment', this.isComment, this.mapComment);
    this.registerSpecialType('cmd', this.isCmd, this.mapCmd);
    dbgReturn("Mapper");
  }

  // ..........................................................
  registerSpecialType(type, recognizer, mapper) {
    if (!this.lSpecials.includes(type)) {
      this.lSpecials.push(type);
    }
    this.hSpecials[type] = {recognizer, mapper};
  }

  // ..........................................................
  // --- override to keep variable LINE updated
  incLineNum(inc = 1) {
    dbgEnter("Mapper.incLineNum", inc);
    super.incLineNum(inc);
    this.setConst('LINE', this.lineNum);
    dbgReturn("Mapper.incLineNum");
  }

  // ..........................................................
  getItemType(hNode) {
    var i, len, recognizer, ref, str, type;
    dbgEnter("Mapper.getItemType", hNode);
    ({str} = hNode);
    assert(isString(str), `str is ${OL(str)}`);
    ref = this.lSpecials;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      recognizer = this.hSpecials[type].recognizer;
      if (recognizer.bind(this)(hNode)) {
        dbgReturn("Mapper.getItemType", type);
        return type;
      }
    }
    dbgReturn("Mapper.getItemType", undef);
    return undef;
  }

  // ..........................................................
  mapSpecial(type, hNode) {
    var h, mapper, uobj;
    dbgEnter("Mapper.mapSpecial", type, hNode);
    assert(hNode instanceof Node, `hNode is ${OL(hNode)}`);
    assert(hNode.type === type, `hNode is ${OL(hNode)}`);
    h = this.hSpecials[type];
    assert(isHash(h), `Unknown type ${OL(type)}`);
    mapper = h.mapper.bind(this);
    assert(isFunction(mapper), `Bad mapper for ${OL(type)}`);
    uobj = mapper(hNode);
    dbgReturn("Mapper.mapSpecial", uobj);
    return uobj;
  }

  // ..........................................................
  isEmptyLine(hNode) {
    return hNode.str === '';
  }

  // ..........................................................
  mapEmptyLine(hNode) {
    // --- default: remove empty lines
    //     return '' to keep empty lines
    return undef;
  }

  // ..........................................................
  isComment(hNode) {
    if (hNode.str.indexOf('# ') === 0) {
      hNode.uobj = {
        comment: hNode.str.substring(2).trim()
      };
      return true;
    } else {
      return false;
    }
  }

  // ..........................................................
  mapComment(hNode) {
    // --- default: remove comments
    // --- To keep comments, simply return hNode.uobj
    return undef;
  }

  // ..........................................................
  isCmd(hNode) {
    var lMatches;
    dbgEnter("Mapper.isCmd");
    if (lMatches = hNode.str.match(/^\#([A-Za-z_]\w*)\s*(.*)$/)) { // name of the command
      // argstr for command
      hNode.uobj = {
        cmd: lMatches[1],
        argstr: lMatches[2]
      };
      dbgReturn("Mapper.isCmd", true);
      return true;
    } else {
      dbgReturn("Mapper.isCmd", false);
      return false;
    }
  }

  // ..........................................................
  // --- mapCmd returns a mapped object, or
  //        undef to produce no output
  // Override must 1st handle its own commands,
  //    then call the base class mapCmd
  mapCmd(hNode) {
    var _, argstr, cmd, isEnv, lMatches, name, tail;
    dbgEnter("Mapper.mapCmd", hNode);
    // --- isCmd() put these keys here
    ({cmd, argstr} = hNode.uobj);
    assert(nonEmpty(cmd), "mapCmd() with empty cmd");
    switch (cmd) {
      case 'define':
        lMatches = argstr.match(/^(env\.)?([A-Za-z_][\w\.]*)(.*)$/); // name of the variable
        assert(defined(lMatches), `Bad #define cmd: ${cmd} ${argstr}`);
        [_, isEnv, name, tail] = lMatches;
        if (tail) {
          tail = tail.trim();
        }
        if (isEnv) {
          dbg(`set env var ${name} to '${tail}'`);
          process.env[name] = tail;
        } else {
          dbg(`set var ${name} to '${tail}'`);
          this.setConst(name, tail);
        }
        dbgReturn("Mapper.mapCmd", undef);
        return undef;
      default:
        // --- don't throw exception
        //     check for unknown commands in visitCmd()
        dbgReturn("Mapper.mapCmd", hNode.uobj);
        return hNode.uobj;
    }
  }

  // ..........................................................
  containedText(hNode, inlineText) {
    var indentedText, result, srcLevel, stopFunc;
    // --- has side effect of fetching all indented text
    dbgEnter("Mapper.containedText", hNode, inlineText);
    ({srcLevel} = hNode);
    stopFunc = function(h) {
      return nonEmpty(h.str) && (h.srcLevel <= srcLevel);
    };
    indentedText = this.getBlockUntil(stopFunc, 'keepEndLine');
    dbg("inline text", inlineText);
    dbg("indentedText", indentedText);
    assert(isEmpty(inlineText) || isEmpty(indentedText), `node ${OL(hNode)} has both inline text and indented text`);
    if (nonEmpty(indentedText)) {
      result = indentedText;
    } else if (isEmpty(inlineText)) {
      result = '';
    } else {
      result = inlineText;
    }
    dbgReturn("Mapper.containedText", result);
    return result;
  }

};

// ===========================================================================
export var FuncMapper = class FuncMapper extends Mapper {
  constructor(source = undef, collection = undef, func) {
    super(source, collection);
    this.func = func;
    assert(isFunction(this.func), "3rd arg not a function");
  }

  getBlock(hOptions = {}) {
    var block;
    block = super.getBlock(hOptions);
    return this.func(block);
  }

};

// ===========================================================================
export var map = function(hInput, mapper, hOptions = {}) {
  var content, i, item, len, obj, result, source;
  // --- Valid options:
  //        logNodes
  dbgEnter("map", hInput, mapper, hOptions);
  if (isString(hInput)) {
    dbg("hInput is a string, constructing new hInput");
    hInput = {
      content: hInput
    };
  }
  // --- An array can be provided - the input is processed
  //     by each array element sequentially
  if (isArray(mapper)) {
    dbg("mapper is an array - using each array element");
    for (i = 0, len = mapper.length; i < len; i++) {
      item = mapper[i];
      if (defined(item)) {
        hInput.content = map(hInput, item, hOptions);
      }
    }
    dbgReturn("map", hInput.content);
    return hInput.content;
  }
  assert(isHash(hInput), `hInput not a hash: ${OL(hInput)}`);
  ({source, content} = hInput);
  dbg("unpacked:");
  dbg('   source =', source);
  dbg('   content =', content);
  assert(defined(mapper), "Missing mapper");
  // --- mapper can be an object, which is an instance of Mapper
  //     or it can just be a class which, when instantiated
  //     has a getBlock() method
  if (isObject(mapper, '&getBlock')) {
    dbg("mapper is object, calling its getBlock()");
    result = mapper.getBlock(hOptions);
  } else if (isConstructor(mapper)) {
    dbg("mapper is constructor, creating instance");
    dbg('source =', source);
    dbg('content =', content);
    obj = new mapper(source, content);
    assert(isObject(obj, '&getBlock'), 'object has no getBlock method');
    result = obj.getBlock(hOptions);
  } else if (isFunction(mapper)) {
    dbg("mapper is a function, calling it");
    if (notdefined(content)) {
      assert(defined(source), "Neither source nor content defined");
      content = slurp(source);
    }
    result = mapper(content);
  } else {
    croak(`Bad mapper in map(): ${OL(mapper)}`);
  }
  dbgReturn("map", result);
  return result;
};
