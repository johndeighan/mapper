// Generated by CoffeeScript 2.5.1
// PLLParser.coffee
var PLLInput;

import {
  strict as assert
} from 'assert';

import {
  say,
  undef,
  error,
  isArray,
  isFunction
} from '@jdeighan/coffee-utils';

import {
  splitLine
} from '@jdeighan/coffee-utils/indent';

import {
  StringInput,
  FileInput
} from '@jdeighan/string-input';

// ---------------------------------------------------------------------------
PLLInput = class PLLInput extends StringInput {
  constructor(content, mapper1) {
    super(content);
    this.mapper = mapper1;
    if (!isFunction(this.mapper)) {
      error("new PLLInput(): mapper is not a function");
    }
  }

  mapLine(line) {
    var level, nextLevel, nextLine, nextStr, str;
    assert(line != null, "mapLine(): line is undef");
    [level, str] = splitLine(line);
    // --- Merge in any continuation lines
    while ((nextLine = this.fetch()) && ([nextLevel, nextStr] = splitLine(nextLine)) && (nextLevel >= level + 2)) {
      str += ' ' + nextStr;
    }
    if (nextLine) {
      this.unfetch(nextLine);
    }
    return [level, this.mapper(str)];
  }

  getTree() {
    return treeify(this.getAll());
  }

};

// ---------------------------------------------------------------------------
export var parsePLL = function(contents, mapper) {
  var oInput;
  oInput = new PLLInput(contents, mapper);
  return oInput.getTree();
};

// ---------------------------------------------------------------------------
// Each item must be a sub-array with 2 items: [<level>, <node>]
export var treeify = function(lItems, level = 0) {
  var h, item, itemLevel, itemNode, lChildren, lNodes, len;
  // --- stop when an item of lower level is found, or at end of array
  lNodes = [];
  while ((lItems.length > 0) && (lItems[0][0] >= level)) {
    item = lItems.shift();
    assert(isArray(item), "treeify(): item is not an array");
    len = item.length;
    assert(len === 2, `treeify(): item has length ${len}`);
    [itemLevel, itemNode] = item;
    assert(itemLevel === level, `treeify(): item at level ${itemLevel}, should be ${level}`);
    h = {
      node: itemNode
    };
    lChildren = treeify(lItems, level + 1);
    if (lChildren != null) {
      h.lChildren = lChildren;
    }
    lNodes.push(h);
  }
  if (lNodes.length === 0) {
    return undef;
  } else {
    return lNodes;
  }
};
