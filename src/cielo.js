// Generated by CoffeeScript 2.6.1
  // cielo.coffee
import {
  undef,
  assert,
  croak,
  isString,
  uniq
} from '@jdeighan/coffee-utils';

import {
  log
} from '@jdeighan/coffee-utils/log';

import {
  indentLevel
} from '@jdeighan/coffee-utils/indent';

import {
  joinBlocks
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  withExt,
  slurp,
  barf,
  newerDestFileExists,
  shortenPath
} from '@jdeighan/coffee-utils/fs';

import {
  doMap,
  StringInput,
  SmartInput
} from '@jdeighan/string-input';

import {
  addHereDocType
} from '@jdeighan/string-input/heredoc';

import {
  getNeededSymbols,
  buildImportList
} from '@jdeighan/string-input/symbols';

import {
  coffeeCodeToJS
} from '@jdeighan/string-input/coffee';

import {
  FuncHereDoc
} from '@jdeighan/string-input/func';

addHereDocType(new FuncHereDoc());

export var convertingCielo = true;

// ---------------------------------------------------------------------------
export var convertCielo = function(flag) {
  convertingCielo = flag;
};

// ---------------------------------------------------------------------------
export var cieloCodeToJS = function(lBlocks, hOptions = {}) {
  var code, err, i, j, jsCode, lNeededSymbols, lNewBlocks, len, newcode, orgCode, postmapper, premapper;
  // --- cielo => js    lBlocks can be a string or array
  //     Valid Options:
  //        premapper:  SmartInput or subclass
  //        postmapper: SmartInput or subclass
  //        source: name of source file
  //        hCoffeeOptions  - passed to CoffeeScript.parse()
  //           default:
  //              bare: true
  //              header: false
  debug("enter cieloCodeToJS()");
  if (isString(lBlocks)) {
    debug("string => array");
    lBlocks = [lBlocks];
  }
  premapper = hOptions.premapper;
  postmapper = hOptions.postmapper;
  lNeededSymbols = [];
  lNewBlocks = [];
  for (i = j = 0, len = lBlocks.length; j < len; i = ++j) {
    code = lBlocks[i];
    assert(indentLevel(code) === 0, "cieloCodeToJS(): has indentation");
    orgCode = code; // used in error messages
    debug(`BLOCK ${i}`, code);
    // --- Even if no premapper is defined, this will handle
    //     continuation lines, HEREDOCs, etc.
    if (premapper) {
      assert(premapper instanceof StringInput, "bad premapper");
      newcode = doMap(premapper, code, hOptions.source);
    } else {
      newcode = doMap(SmartInput, code, hOptions.source);
    }
    if (newcode !== code) {
      code = newcode;
      debug("pre mapped", code);
    }
    // --- symbols will always be unique
    lNeededSymbols = lNeededSymbols.concat(getNeededSymbols(code));
    try {
      if (convertingCielo) {
        jsCode = coffeeCodeToJS(code, hOptions.hCoffeeOptions);
        debug("jsCode", jsCode);
      } else {
        jsCode = code;
      }
      if (postmapper) {
        assert(postmapper instanceof StringInput, "bad postmapper");
        newcode = doMap(postmapper, jsCode, hOptions.source);
        if (newcode !== jsCode) {
          jsCode = newcode;
          debug("post mapped", jsCode);
        }
      }
      lNewBlocks.push(jsCode);
    } catch (error) {
      err = error;
      log("Code", code);
      croak(err, "Original Code", orgCode);
    }
  }
  jsCode = joinBlocks(...lNewBlocks);
  debug("return from cieloCodeToJS()");
  return {
    jsCode,
    lNeededSymbols: uniq(lNeededSymbols)
  };
};

// ---------------------------------------------------------------------------
export var addImports = function(jsCode, lNeededSymbols, sep = undef) {
  var lImportStmts;
  if (sep == null) {
    sep = convertingCielo ? ";\n" : "\n";
  }
  // --- These import statements don't include a trailing ';'
  lImportStmts = buildImportList(lNeededSymbols);
  if (lImportStmts.length === 0) {
    return jsCode;
  }
  return lImportStmts.join(sep) + sep + jsCode;
};

// ---------------------------------------------------------------------------
export var cieloFileToJS = function(srcPath, destPath = undef, hOptions = {}) {
  var coffeeCode, dumpfile, j, jsCode, lNeeded, len, n, sym, word;
  if (destPath == null) {
    destPath = withExt(srcPath, '.js', {
      removeLeadingUnderScore: true
    });
  }
  if (hOptions.force || !newerDestFileExists(srcPath, destPath)) {
    coffeeCode = slurp(srcPath);
    if (hOptions.saveAST) {
      dumpfile = withExt(srcPath, '.ast');
      lNeeded = getNeededSymbols(coffeeCode, {dumpfile});
      if ((lNeeded === undef) || (lNeeded.length === 0)) {
        debug(`NO NEEDED SYMBOLS in ${shortenPath(destPath)}:`);
      } else {
        n = lNeeded.length;
        word = n === 1 ? 'SYMBOL' : 'SYMBOLS';
        debug(`${n} NEEDED ${word} in ${shortenPath(destPath)}:`);
        for (j = 0, len = lNeeded.length; j < len; j++) {
          sym = lNeeded[j];
          debug(`   - ${sym}`);
        }
      }
    }
    jsCode = cieloCodeToJS(coffeeCode, hOptions);
    barf(destPath, jsCode);
  }
};
